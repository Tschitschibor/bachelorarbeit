% mainfile: ../main.tex

\section{Finite concrete categories}

\begin{definition}{(Finite and concrete categories)}
\renewcommand{\labelenumi}{(\theenumi)}
\begin{enumerate}
\item A \ul{finite} category is a category with a finite set of objects and a finite set of morphisms.
\item A \ul{concrete} category is a category whose objects have \ul{underlying sets} and whose morphisms are functions between these
underlying sets. Otherwise it's called an \ul{abstract} category.
\end{enumerate}
\end{definition}

\begin{example}
Forgetful functor / Category closure / k-Algebroid
\end{example}

When we want to calculate representations of our finite concrete categories, we make the Hom functor Hom( ccat, kMat ).
But functors from the concrete category directly are not useful when we know nothing about the relations of morphisms
in our category.
Instead we go an indirect route, first calculating the underlying quiver and from this the k-algebroid, i.e. the path algebra
with the endomorphism relations and such.

\begin{algorithm}\capstart
    \caption{\texttt{RightQuiverFromConcreteCategory}}\label{algo:RightQuiverFromConcreteCategory}
	\SetKwInput{Input}{Input~}
	\SetKwInput{Output}{Output~}
	\Input{~a finite concrete category $C$ with $n$ objects}
	\Output{~the right quiver $q(n)$}
	\BlankLine
	let $Obj$ be the set of objects of $C$\;
	let $n := Length(Obj)$\;
	let $gMor$ be the set of generating morphisms of $C$\;
	let $A$ be the empty set and let $i := 1$\;
	\ForEach{morphism $mor$ in $gMor$}{
	    let $A_{i,1}$ be the position of $Source( mor )$ in $Obj$\;
	    let $A_{i,2}$ be the position of $Range( mor )$ in $Obj$\;
	    let $i := i+1$\;
	}
	\BlankLine
	let $q$ be the right quiver with vertices $\{1,\dots,n\}$ and arrows $A$.
	\BlankLine
	\Return q\;
\end{algorithm}

Clearly every finite concrete category is a small category.

As we have seen in the previous section, a quiver $q$ with a path of length greater than $\abs{q_{0}}$ must have loops and is thus infinite.
We will construct finite concrete categories by paying attention that the arrows between different objects are only one-directional, thus we
have a partial order on the set of objects.

The following algorithm takes two integers n and m as arguments and gives a finite concrete category as output with n objects which are each
FinSets with m elements. The generating endomorphisms are each a permutation of order m, while the non-endomorphisms are bijective
mappings from each object $c \in \mathcal{C}_{0}$ to all later objects $c' \in \mathcal{C}, c' > c$ with the obvious order.

\begin{verbatim}
##
InstallMethod( ConcreteCategoryForCAP,
        "for two integers",
        [ IsInt, IsInt ],
        
  function( n, m )
	local objects, gmorphisms, permute, j, k, list, C;
  objects := [];
  for j in [1..n] do
    objects[j] := FinSet([1+(j-1)*m..j*m]);
  od;
  gmorphisms := [];
  permute := function(o, j, m)
    local r;
    r := RemInt( o+1, m );
    if r > 0 then
      return (r+(j-1)*m);
    else
      return j*m;
    fi;
  end;
  for j in [1..n] do
    for k in [j..n] do
		if j = k then
		    Add( gmorphisms, MapOfFinSets( objects[j], 
				List( objects[j], o-> [o, permute(o,j,m) ] ),
				objects[k]) );
		else # k > j
			Add( gmorphisms, MapOfFinSets( objects[j],
				List( objects[j], o -> [o, o+(k-j)*m] ),
				objects[k]) );
		fi;
	od;
  od;
  
    DeactivateCachingOfCategory( FinSets );
    CapCategorySwitchLogicOff( FinSets );
    DisableSanityChecks( FinSets );
    
    C := Subcategory( FinSets, "A finite concrete category" : overhead := false, FinalizeCategory := false );
	
	DeactivateCachingOfCategory( C );
    CapCategorySwitchLogicOff( C );
    DisableSanityChecks( C );
	
	SetFilterObj( C, IsFiniteConcreteCategory );
	
	AddIsAutomorphism( C,
      function( alpha )
        return IsAutomorphism( UnderlyingCell( alpha ) );
    end );
	
	AddInverse( C,
      function( alpha )
        return Inverse( UnderlyingCell( alpha ) ) / CapCategory( alpha );
    end );
	
	SetSetOfObjects( C, List( objects, o-> o / C ) );
	SetSetOfGeneratingMorphisms( C, List( gmorphisms, g-> g / C ) );
	
    Finalize( C );
    
    return C;
end );
\end{verbatim}