% mainfile: ../main.tex

This section serves two purposes: On the one hand, it is an introduction to quivers and category theory. On the other hand it introduces
concrete categories which we want to represent, and all the additional constructions that are needed to that goal.

\subsection{Quivers}
In this section, we first want to define the category \textbf{Quiv} and how it is the prototype for the category \textbf{Cats}.
In order to describe the category \textbf{Quiv} of quivers, we first have to define what a category is and for this we need
the definition of a quiver. Lateron we will revisit this definition as we can define quivers as the objects in the quiver category \textbf{Quiv}.

\begin{definition}{(Quiver)}\label{def:quiver}\\
A \ul{directed graph} or \ul{quiver} $q$ consists of a class of \ul{objects} (or \ul{vertices}) $q_{0} = \textup{Obj}\,q$ and
a class of \ul{morphisms} (or \ul{arrows}) $q_{1} = \textup{Mor}\,q$ together with two defining maps
\[
\begin{tikzcd}[column sep=small]
{s,t\colon q_{1}} \arrow[rr, shift left = 0.7ex] \arrow[rr, shift right = 0.7ex] & & q_{0}
\end{tikzcd}
\]
$s$ called \ul{source} and $t$ called \ul{target}.
\end{definition}

In the next definition we are giving a new characterization for $q_{1}$ by looking at all arrows between two fixed objects.

\begin{definition}{(Hom-set of a (locally) small quiver)}\label{def:hom_set}
\renewcommand{\labelenumi}{(\theenumi)}
\begin{enumerate}
\item Given two objects $M, N \in q_{0}$ we write $\textup{Hom}_{q}(M,N)$ or $q(M,N)$ for the fiber
$(s,t)^{-1} (\{(M,N)\})$ of the product map 
\begin{tikzcd}[column sep=small]
(s, t) : q_{1} \arrow[rr] &  & q_{0} \times q_{0} 
\end{tikzcd} over the pair $(M,N) \in q_{0} \times q_{0}$.
This is the class of all morphisms with source $= M$ and target $= N$.
We indicate this by writing
\begin{tikzcd}[column sep=small]
\varphi : M \arrow[rr] &  & N
\end{tikzcd} or 
\begin{tikzcd}[column sep=small]
M \arrow[rr,"\varphi"] &  & N.
\end{tikzcd} Hence $q_{1}$ is the disjoint union $\bigcup\limits^{\bigcdot}_{M,N \in q_{0}} \textup{Hom}_{q}(M,N) = q_{1}$.
As usual we define $\textup{End}_{q}(M):= \textup{Hom}_{q}(M,M)$.
\item If the class $\textup{Hom}_{q}(M,N)$ is a \ul{set} for all pairs $(M,N)$ then we call the quiver \ul{locally small}.
We therefore talk about \ul{Hom-sets}.
If additionally, $q_{0}$ is a set, then the quiver is called \ul{small}.
\item A quiver with a finite set of objects and a finite set of morphisms is called a \ul{finite} quiver.
\end{enumerate}
\end{definition}

When we don't assume the category to be locally small, but still talk about its hom-sets, we mean the class of morphisms,
if we don't explicitly use the fact that it's a set of morphisms.

\begin{example}\label{q(2)}{(Quiver with 2 objects and 3 morphisms)}\\
\[
\begin{tikzcd}
1 \arrow["a"', loop, distance=2em, in=305, out=235] \arrow[rr, "b"] &  & 2 \arrow["c"', loop, distance=2em, in=305, out=235]
\end{tikzcd}
\]
The objects of this quiver $q$ are $q_{0} = \{1, 2\}$, and the morphisms are $q_{1} = \{a, b, c\}$ with\\
$s (a) = 1 = t (a)$, $s (c) = 2 = t (c)$ and $s (b) = 1, t (b) = 2$.\\
\noindent Thus $\textup{End}_{q}(1) = \{a\}, \textup{End}_{q}(2) = \{c\}$ and $\textup{Hom}_{q}(1,2) = \{b\}$ whereas
$\textup{Hom}_{q}(2,1)=\emptyset$.\\

\noindent In \texttt{QPA} this quiver is encoded as \texttt{q(2)[a:1->1,b:1->2,c:2->2]} where the first \texttt{(2)} in parentheses stands for the total
number of objects.
\end{example}

\begin{definition}{(Composable arrows; path in a quiver)}\label{def:path}\endnote{(ref. \ref{[leit4]} 4.1)}
Let $q$ be a quiver.
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item We say two arrows $a, b \in q_{1}$ are \ul{composable} if $t(a) = s(b)$ or $t(b) = s(a)$. In this case we can write a
sequence of composable arrows $p = a_{1}a_{2}\cdots a_{n}$ where $t(a_{i}) = s(a_{i+1})$ for $i=1,\dots,n-1$.
We call this sequence a \ul{path} from $s(a_{1})$ to $t(a_{n})$ and the integer $n \in \mathbb{Z}_{\geq0}$ the \ul{length} $l(p)$ of the path $p$.
Although it may not be an arrow, we can define the source and target of a path $p = a_{1}\cdots a_{n}$ as $s(p) := s(a_{1})$ and $t(p) := t(a_{n})$.
Then again we define two paths $p$ and $p'$ as composable, if $t(p) = s(p')$ (or $t(p') = s(p)$) and we call $p'$ (or $p'p$) the
\ul{concatenation} or \ul{composition} of the two paths. We can identify each arrow again as a path of length 1.
A path $p = a_{1}\cdots a_{n}$ with $s(a_{1}) = t(a_{n})$, i.e. $s(p) = t(p)$, is called \ul{cyclic}.
\item For an endomorphism $a \in \textup{End}_{q}(M)$ we write $a^{n}$ for $aa \cdots a$ ($n$ times).
\item In the case of $n=0$ an \ul{empty path} whose source and target are the vertex $i \in q_{0}$ is called the \ul{trivial path at $i$} and
is denoted $e_{i}$. Note that the composition of paths $e_{i}e_{i}$ has length zero starting at $i$ therefore $e_{i}^{2}=e_{i}$,
in other words, each $e_{i}$ is an \ul{idempotent}.
\end{enumerate}
\end{definition}

\begin{lemma}\label{la:cyclic_paths}
Let $q$ be a quiver. If there is a path of length at least $\abs{q_{0}}$, then there are cyclic paths,
and thus infinitely many paths.\cite{[leit4]}
\end{lemma}
\begin{proof}
Assume that there exists a path of length greater or equal to $\abs{q_{0}}$. Then there exists a path of length $n = \abs{q_{0}}$, say
$\alpha_{1}\cdots \alpha_{n}$. Consider the vertices $x_{i}=s(\alpha_{i})$ for $1 \leq i \leq n$ and $x_{n+1}=t(\alpha_{n})$. Then these
are $n+1$ vertices, thus there has to exist $i<j$ with $x_{i}=x_{j}$. Let $\omega=\alpha_{i}\cdots \alpha_{j-1}$, this is a path with source and target
$x_{i}=x_{j}$, thus a cyclic path. But then $\omega^{m}$ is a path for any natural number $m$. The path $\omega$ has length $j-i\geq1$, thus
$\omega^{m}$ has length $m(j-i)$. This shows that these paths are pairwise different.
\end{proof}

\begin{example}{(A quiver with no cycles)}\\
\[
\begin{tikzcd}
2 \arrow[rrrr, "\psi"] \arrow[rrrrddd, "\psi\rho", pos=0.3] &  &  &  &
3 \arrow[ddd, "\rho"] \\
 &  &  &  & \\
 &  &  &  & \\
1 \arrow[uuu, "\varphi"] \arrow[rrrruuu, "\varphi\psi", pos=0.3] \arrow[rrrr, "\varphi\psi\rho" '] &  &  &  & 4
\end{tikzcd}
\]
The longest path $1\rightarrow2\rightarrow3\rightarrow4$ has length 3. If after the object $4$ another arrow would go to either $1,2,3$ or $4$ itself,
we would have a cyclic path and thus infinitely many paths.
\end{example}

\subsection{Categories}

\begin{definition}{(Category)}\label{def:category}\\
\noindent A \ul{category} $\mathcal{C}$ is a quiver with two further maps:
\begin{enumerate}
\renewcommand{\labelenumi}{(id)}
\item The \ul{identity map} $1_{( )}$ mapping every object $X \in\mathcal{C}_{0}$ to its \ul{identity morphism} $1_{X}$:
\[
\begin{tikzcd}[column sep=small]
\mathcal{C}_{0} \arrow[rr,"1"] &  & \mathcal{C}_{1}
\end{tikzcd}
\]
\renewcommand{\labelenumi}{($\mu$)}
\item And for any two \ul{composable} morphisms $\varphi$ and $\psi \in \mathcal{C}_{1}$, i.e. with $t(\varphi) = s(\psi)$, the
\ul{composition map} $\mu$, which maps $\varphi, \psi \in \mathcal{C}_{1}\times\mathcal{C}_{1}$ to $\mu(\varphi,\psi) \in \mathcal{C}_{1}$ which
we also write as $\varphi\psi$. 
\[
\begin{tikzcd}[column sep=small]
\mathcal{C}_{1} \times \mathcal{C}_{1} \arrow[rr,"\mu"] &  & \mathcal{C}_{1}
\end{tikzcd}
\]
\end{enumerate}
\noindent The defining properties for $1$ and $\mu$ are:
\renewcommand{\labelenumi}{(\theenumi)}
\begin{enumerate}
\item $s(1_{M}) = M = t(1_{M})$, i.e.\\
$1_{M} \in \textup{End}_{\mathcal{C}} \forall M \in \mathcal{C}$.

\item $s(\varphi\psi) = s(\varphi)$ and\\
$t(\varphi\psi) = t(\psi)$\\
for all composable morphisms $\varphi, \psi \in \mathcal{C}$.
\[
\begin{tikzcd}[column sep=small]
\mu : \textup{Hom}_{\mathcal{C}}(M,L) \times \textup{Hom}_{\mathcal{C}}(L,N) \arrow[rr] &  & \textup{Hom}_{\mathcal{C}}(M,N)
\end{tikzcd}
\]
\item \label{associativity_of_composition} \begin{minipage}{.55\textwidth} $(\varphi\psi)\rho = \varphi(\psi\rho)$ \hfill{} [associativity of composition]\end{minipage}
\begin{minipage}{.45\textwidth}\phantom{}\end{minipage}
\item \label{unit_property} \begin{minipage}{.55\textwidth} $1_{s(\varphi)}\varphi = \varphi = \varphi1_{t(\varphi)}$ \hfill{} [unit property]\end{minipage}
\begin{minipage}{.45\textwidth}\phantom{}\end{minipage}\\
The identity is a left and right unit of the composition.
\end{enumerate}
\end{definition}

\noindent So with categories you always answer the four questions
\begin{itemize}\label{category_questions}
\item What are the objects?
\item What are the morphisms? (which includes the question What are the identity morphisms?)
\item How do you compose morphisms?
\item Why is the composition associative?
\end{itemize}

\begin{example}{(The category $\FinSets$)}
\begin{itemize}
\item The objects are finite sets.
\item The morphisms are functions between sets, with the identity morphism on the set $X$ defined as $1_{X} := \mathrm{id}_{X} : X \rightarrow X; x \mapsto x$.
\item Composition of morphisms is the usual composition of functions: $f : X \rightarrow Y; x \mapsto f(x)$, \\
$g : Y \rightarrow Z; y \mapsto g(y)$. Then $f \circ g : X \rightarrow Z; x \mapsto g(f(x))$.\endnote{(The relation ``f, then g'' can be
expressed by the left-to-right application of first f, and then g, if you write $x^{f}$ for $f(x)$.
Then the contravariantly ordered $g(f(x))$ becomes $(x^{f})^{g}$.)}
\item The composition is associative: With $f, g$ as above, and $h : Z \rightarrow W$, $(f \circ(g \circ h)) (x) = (g \circ h)(f(x)) = h(g(f(x)))
= h((f \circ g)(x)) = ((f \circ g) \circ h)(x), \forall x \in X$.
\end{itemize}
\end{example}

\begin{definition}{(Subobject; Subcategory)}
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item A \ul{subobject} $K \leq M$ is an equivalence class of monos with $M$ as target under the equivalence relation
of mutual dominance.
\item A \ul{subcategory} $\mathcal{C} \leq \mathcal{D}$ is a subobject in the category $\Cat$ of categories.
\end{enumerate}
\end{definition}

\begin{definition}{(Concrete category)}
A \ul{concrete category} is a category $\mathcal{C}$ together with a faithful functor $U : \mathcal{C} \rightarrow \Set$.\\
This functor $U$ typically carries an object of $\mathcal{C}$ to its \textit{underlying set} and is called \textit{forgetful functor}.
For more on functors see the next subsection, for more on the forgetful functor see \ref{sec:fin_concrete_cat_free_forgetful}.

\end{definition}

\begin{example}
The categories $\FinSets$ which is a subcategory of $\Set$ are both concrete categories.
A \ul{finite concrete category} $\mathcal{C}$ is a finite subcategory of $\FinSets$.
\end{example}

\begin{remark}{(Endomorphism monoid; explicitly cyclic monoid)}\label{rmk:endo_monoid}
Let $\mathcal{C}$ be a category and $M \in \mathcal{C}_{0}$ an object. Then the \ul{endomorphism set} $\mathrm{End}_{\mathcal{C}}(M)$
together with the composition of morphisms as operation, and $1_{M}$ as identity element, is a monoid, called the \ul{endomorphism monoid}.
We call the endomorphism monoid \ul{explicitly cyclic} if it is generated by one object, i.e. of the form $\{1_{M} = \alpha^{0}, \alpha^{1},
\alpha^{2}, \dots \}$ for an $\alpha \in \mathrm{End}_{\mathcal{C}}(M)$.\\
If the endomorphism monoid is finite and explicitly cyclic, it is of the form $\{1_{M}, \alpha^{1}, \dots, \alpha^{n}\}$ for an $n \in \mathbb{N}$.
\end{remark}
\begin{proof}
The properties of a monoid are precisely the associativity of composition and the unit property from \ref{associativity_of_composition} and
\ref{unit_property}.
\end{proof}

\subsection{Functors}

Categories are themselves objects in the category of categories, which leads to a question: What is a morphism between categories?

\begin{definition}{(Functor)}\label{def:functor}\\
\noindent A \ul{functor} $F : \mathcal{C} \rightarrow \mathcal{D}$, between categories $\mathcal{C}$ and $\mathcal{D}$, consists of the
following data:

\begin{itemize}
\item An object $Fc\in\mathcal{D}_{0}$, for each object $c \in \mathcal{C}_{0}$.
\item A function $Ff : Fc \rightarrow Fc' \in \mathcal{D}_{1}$, for each morphism $f : c \rightarrow c' \in \mathcal{C}_{1}$, so that the
source and target of $Ff$ are, respectively, equal to $F$ applied to the source or target of $f$, in other words,
$s(Ff) = Fs(f)$ and $t(Ff) = Ft(f)$.
\end{itemize}

\noindent The assignments are required to satisfy the following two \ul{functoriality axioms}:
\begin{itemize}\label{functoriality}
\item For any composable pair $f, g \in \mathcal{C}_{1}, Fg \cdot Ff = F(g \cdot f)$.
\item For each object $c \in \mathcal{C}_{0}, F(1_{c}) = 1_{Fc}$.
\end{itemize}

Put concisely, a functor consists of a mapping on objects and a mapping on morphisms that preserves all of the structure of a category,
namely domains and codomains, composition, and identities.
\end{definition}

\noindent So with functors you always answer the four questions
\begin{itemize}\label{four_functor_questions}
\item How does it work on objects?
\item How does it work on morphisms?
\item Why does it respect composition?
\item Why does it respect identity morphisms?
\end{itemize}

We have already seen an example for a functor in definition \ref{def:hom_set} where we defined the hom-set $\textup{Hom}(M,N)$ between two
objects $M$ and $N$. There are two ways to leave blank one of the objects and thus define the 

\begin{example}{(partial Hom-functor)}\label{ex:hom_functor}
Let $\mathcal{C}$ be a category and $P \in \mathcal{C}_{0}$ any object. The \ul{Hom-functor}, also called \ul{partial Hom-functor},
\begin{enumerate}
\item $\textup{Hom}(P,-)$ is a functor from $\mathcal{C}$ to $\mathcal{C}_{1}$ where objects in $\mathcal{C}_{1}$ are the hom-sets 
$\textup{Hom}(P,N)$, and morphisms are maps from one hom-set to another.
$\textup{Hom}(P,-)$ works on objects by mapping the object $N \in \mathcal{C}_{0}$ to
the hom-set $\textup{Hom}(P,N) \in \mathcal{C}_{1}$.
$\textup{Hom}(P,-)$ works on morphisms by mapping the morphism $(f : M \rightarrow N ) \in \mathcal{C}_{1}$ to the transformation
$\textup{Hom}(P,f) : \textup{Hom}(P,M) \rightarrow \textup{Hom}(P,N); \varphi \mapsto \varphi f$, so for every morphism
$\varphi \in \textup{Hom}(P,M)$, you post-compose $f \in \textup{Hom}(M,N)$ to get a new morphism $\varphi f \in \textup{Hom}(P,N)$.

\item $\textup{Hom}(-,P)$ is a functor from $\mathcal{C}$ to $\mathcal{C}_{1}$ where objects in $\mathcal{C}_{1}$ are the hom-sets 
$\textup{Hom}(N,P)$, and morphisms are maps from one hom-set to another.
$\textup{Hom}(-,P)$ works on objects by mapping the object $N \in \mathcal{C}_{0}$ to
the hom-set $\textup{Hom}(N,P) \in \mathcal{C}_{1}$.
$\textup{Hom}(-,P)$ works on morphisms by mapping the morphism $(f : M \rightarrow N ) \in \mathcal{C}_{1}$ to the transformation
$\textup{Hom}(f,P) : \textup{Hom}(N,P) \rightarrow \textup{Hom}(M,P); \varphi \mapsto f\varphi$, so for every morphism
$\varphi \in \textup{Hom}(N,P)$, you pre-compose $f \in \textup{Hom}(M,N)$ to get a new morphism $f\varphi \in \textup{Hom}(M,P)$.
\end{enumerate}

The important difference between these two functors was how they worked on morphisms. If in both cases we take a morphism
$f : M \rightarrow N$ as given, then we have to arrange the source and target for $\textup{Hom}(P,f)$ and $\textup{Hom}(f,P)$
according to the post-composition and pre-composition. Thus if we wanted $\textup{Hom}(f,P)$ to be defined by pre-composition
$\varphi \mapsto f\varphi$, then we were forced to invert $M$ and $N$ as source and target to get 
$\textup{Hom}(f,P): \textup{Hom}(N,P) \rightarrow \textup{Hom}(M,P)$. 
This process of inverting source and target is caught in the following definition.
\end{example}

\begin{definition}{(covariant / contravariant functor)}\endnote{(Def 1.3.5. in \cite{[context]}, p. 17 (35/258))}\\
The way we defined a functor in definition \ref{def:functor} was in the \ul{covariant} way.\\
A \ul{contravariant} functor $F : \mathcal{C} \rightarrow \mathcal{D}$ works on objects the same way as a covariant one, i.e.
an object $Fc \in \mathcal{D}_{0}$ for each object $c \in \mathcal{C}_{0}$. For morphisms on the other hand, we have
a morphism $F f : Fc' \rightarrow Fc \in \mathcal{D}_{1}$ for each morphism $f : c \rightarrow c' \in \mathcal{C}_{1}$, so that
$s(F f) = F t(f)$ and $t(F f) = F s(f)$.
The \ul{functoriality axioms} are also inverted for a contravariant functor:
For any composable pair, $f, g \in \mathcal{C}_{1}$, $F f \cdot F g = F(g \cdot f)$.
For the identity morphisms, it is again the same as in the covariant case:
For each object $c \in \mathcal{C}_{0}$, $F(1_{c}) = 1_{Fc}$.
\end{definition}

In the following definitions, we define different subclasses of functors. These adjectives often come in opposite pairs, so that you may be
tempted to think, duality lets you just swap all the adjectives for the opposite ones, but be careful there. E.g. when 
$\textup{Hom}(P,-)$ is a \ul{covariant}, \ul{left-exact} functor, the opposite $\textup{Hom}(-,P)$ is a \ul{contravariant}, but still \ul{left-exact} functor.
But their respective \ul{right-exactedness} is equivalent to dual concepts concerning \ul{projective} and \ul{injective} objects.

\begin{definition}{(Exact functor)}\label{def:exact_functor}\endnote{(Def 4.5.9. in \cite{[context]}, p. 139 (157/258))}\\
A functor is \ul{right exact} or \ul{finitely cocontinuous} if it preserves finite colimits, and \ul{left exact} or \ul{finitely continuous} if it preserves finite limits.
\end{definition}

\begin{remark}
Without going into the details of defining what a limit and a colimit is, and with \ul{pullbacks} and \ul{pushouts} as specific kinds of
finite limits or colimits, and with the following proposition characterizing monomorphisms and epimorphisms,
we can give a definition for exact functor that is useful enough for our purposes.\endnote{(For a more on exact functors see above footnote,
on limits and colimits the same \cite{[context]}, chapter 3, pages 73 (91/258) onward, on pullback and pushout Def 3.1.15 p. 78 / Ex. 3.1.22, p. 80 f)}
\end{remark}

\begin{lemma}\label{prop:mono_pullback}
A morphism $f : a \rightarrow b$ is a monomorphism if and only if
the pullback of $f$ and $f$ exists and is $a$, together with the identity maps $1_{a} : a \rightarrow a$.
In other words, $f : a \rightarrow b$ is a monomorphism if and only if the commutative square
\[
\begin{tikzcd}
a \arrow[r, "1_{a}"] \arrow[d, "1_{a}"'] & a \arrow[d, "f"] \\
a \arrow[r, "f"]                         & b               
\end{tikzcd}
\]
is a pullback square.\endnote{(Cited from \cite{[Annoying Precision]})}

A dual statement exists for epimorphisms and pushouts, which are finite colimits.
\end{lemma}

\begin{corollary}{(from \ref{prop:mono_pullback})}\label{cor:preserve_mono_epi}

\begin{enumerate}
\item Being a monomorphism is a “limit property”: more precisely, any functor which preserves pullbacks
(in particular any functor which preserves finite limits, in particular any functor which preserves all limits)
preserves monomorphisms.
\item Being an epimorphism is a “colimit property”: more precisely, any functor which preserves pushouts
(in particular any functor which preserves finite colimits, in particular any functor which preserves all colimits)
preserves epimorphisms.\endnote{(Cited from \cite{[Annoying Precision]},
after pullback square and pushout square respectively)}
\end{enumerate}
\end{corollary}

\begin{lemma}
For functors between Abelian categories, left/right exactness is equivalent to preserving monos/epis.
\end{lemma}

\begin{lemma}\label{la:hom_functor_left_exact}
The hom functors $\textup{Hom}(P,-)$ and $\textup{Hom}(-,P)$ from \ref{ex:hom_functor} are left exact, i.e. respect monos.
\begin{proof}
Let $f : M \rightarrow N \in \mathcal{C}_{1}$ be a monomorphism, and let $O \in \mathcal{C}_{0}$ be any object.
Let $\mathfrak{g} : \textup{Hom}(P,N) \rightarrow \textup{Hom}(P,O); \varphi \mapsto \mathfrak{g}(\varphi)$
and $\mathfrak{h} : \textup{Hom}(P,N) \rightarrow \textup{Hom}(P,O); \varphi \mapsto \mathfrak{h}(\varphi)$
such that $\textup{Hom}(P,f) \cdot \mathfrak{g} : \textup{Hom}(P,M) \rightarrow \textup{Hom}(P,O); \psi \mapsto \mathfrak{g}(\psi f)$
and  $\textup{Hom}(P,f) \cdot \mathfrak{h} : \textup{Hom}(P,M) \rightarrow \textup{Hom}(P,O); \psi \mapsto \mathfrak{h}(\psi f)$
yield the same morphism, i.e. $\forall \psi \in \textup{Hom}(P,M), \mathfrak{g}(\psi f) = \mathfrak{h}(\psi f)$.
We want to show that - under the assumption that $f : M \rightarrow N$ was a monomorphism, already $\mathfrak{g} = \mathfrak{h}$.
TODO
\end{proof}
\end{lemma}

\begin{definition}{(Full functor)}\label{def:full_functor}\endnote{(Def 1.5.7. in \cite{[context]}, p. 30 (48/258))}\\
A functor $F : \mathcal{C} \rightarrow \mathcal{D}$ is \ul{full} if
$\forall x, y \in \mathcal{C}_{0}$, the map $\mathcal{C}(x, y) \rightarrow \mathcal{D}(Fx, Fy)$ is surjective.
\end{definition}

\begin{definition}{(Faithful functor)}\label{def:faithful_functor}\endnote{(ebd.)}\\
A functor $F$ as in \ref{def:full_functor} is \ul{faithful} if
$\forall x, y \in \mathcal{C}_{0}$, the map $\mathcal{C}(x, y) \rightarrow \mathcal{D}(Fx, Fy)$ is injective.
\end{definition}

\begin{definition}{(Essentially surjective on objects)}\label{def:ess_surj_o_o}\endnote{(ebd.)}\\
A functor $F$ as in \ref{def:full_functor} is \ul{essentially surjective on objects} if for every object $d \in \mathcal{D}_{0}$ there
is some $c \in \mathcal{C}_{0}$ such that $d$ is isomorphic to $Fc$.
\end{definition}

\begin{definition}{(Embedding)}\label{def:embedding}\endnote{(Rmk 1.5.8. in \cite{[context]}, p. 31 (49/258))}\\
A faithful functor that is injective on objects is called an \ul{embedding} and identifies the source category
as a subcategory of the target. In this case, faithfulness implies that the functor is (globally) injective on arrows.
\end{definition}

\begin{definition}{(Full embedding / full subcategory)}\label{def:full_fully}\endnote{(ebd.)}\\
A full and faithful functor, called \ul{fully faithful} for short, that is injective on objects defines a \ul{full embedding} of the
source category into the target category. The source then defines a \ul{full subcategory} of the target category.
\end{definition}

\begin{theorem}{(characterizing equivalences of categories)}\label{thm:equiv_fully_faithful}\endnote{(Cited from \cite{[context]} Theorem
1.5.9)}
A functor defining an equivalence of categories is full, faithful, and essentially surjective on objects. Assuming the axiom of choice,
any functor with these properties defines an equivalence of categories.
\end{theorem}

% cut-pasted from k-Algebroid.tex
\noindent As we have seen, every category is a quiver, but in general, to become a category, a quiver is lacking identity morphisms
and the composition of morphisms. To be more precise, there is a \ul{functor} $U$ from the \ul{category of categories} $\textup{CAT}$ to the
\ul{category of quivers} $\textup{Quiv}$, called the \ul{underlying quiver} or \ul{forgetful functor}.
\[
\begin{tikzcd}
\textup{Cat} \arrow[rr,"U"] &  & \textup{Quiv}
\end{tikzcd}
\]
mapping every object $M \in \mathcal{C}_{0}$ to the same objects in $q_{0}$, mapping every arrow $\varphi \in \mathcal{C}_{1}$ to 
an arrow $a \in q_{1}$, respecting source and target, but forgetting the special role of the identity morphisms and of the composition morphisms.

\begin{example}{(Free / Forgetful functor)}\label{ex:forgetful_functor}\\
TODO

$Free : \mathbf{Quiv} \rightarrow \mathbf{Cat}$

$U : \mathbf{Cat} \rightarrow \mathbf{Quiv}$
\end{example}

% Was bisher bei Category Closure geschah...
\begin{example}{(Category closure)}\\

\noindent\begin{minipage}{.08\textwidth}
\phantom{}
\end{minipage}
\begin{minipage}{.37\textwidth}
\begin{tikzcd}[boxedcd={inner xsep=1.5em, inner ysep=3em}]
B \arrow[rrrr, "\psi"] &  &  &  & C \arrow[ddd, "\rho"] \\
 &  &  &  & \\
 &  &  &  & \\
A \arrow[uuu, "\varphi"] &  &  &  & D
\end{tikzcd}
\end{minipage}
%
\begin{minipage}{.10\textwidth}
$\xrightarrow{\text{  Free }}$
\end{minipage}
%
\begin{minipage}{.37\textwidth}
\begin{tikzcd}[boxedcd={inner xsep=1.5em, inner ysep=3em}]
B \arrow[rrrr, "\psi"] \arrow[rrrrddd, "\psi\rho", pos=0.3] \arrow["1_{B}"', loop, distance=2em, in=125, out=55] &  &  &  &
C \arrow[ddd, "\rho"] \arrow["1_{C}"', loop, distance=2em, in=125, out=55]\\
 &  &  &  & \\
 &  &  &  & \\
A \arrow[uuu, "\varphi"] \arrow[rrrruuu, "\varphi\psi", pos=0.3] \arrow[rrrr, bend left, "(\varphi\psi)\rho" ', shift right=2]
\arrow[rrrr, "\varphi(\psi\rho)", bend right] \arrow["1_{A}"', loop, distance=2em, in=305, out=235] &  &  &  &
D \arrow["1_{D}"', loop, distance=2em, in=305, out=235]
\end{tikzcd}
\end{minipage}
\begin{minipage}{.08\textwidth}
\phantom{}
\end{minipage}\\

We can think of a quiver as a prototype for a category. That means we can construct the missing data for a category
from a quiver by adding the identity morphisms and the composed arrows.
\end{example}

% to be seen how useful this example is...
\begin{example}{(Underlying quiver)}\\

\noindent\begin{minipage}{.08\textwidth}
\phantom{}
\end{minipage}
\begin{minipage}{.37\textwidth}
\begin{tikzcd}[boxedcd={inner xsep=1.5em, inner ysep=3em}]
2 \arrow[rrrr, "b"] \arrow[rrrrddd, "e", pos=0.3] \arrow["h"', loop, distance=2em, in=125, out=55] &  &  &  &
3 \arrow[ddd, "c"] \arrow["i"', loop, distance=2em, in=125, out=55]\\
 &  &  &  & \\
 &  &  &  & \\
1 \arrow[uuu, "a"] \arrow[rrrruuu, "d", pos=0.3] \arrow[rrrr, bend left, "f" ', shift right=2]
\arrow[rrrr, "f", bend right] \arrow["g"', loop, distance=2em, in=305, out=235] &  &  &  &
4 \arrow["j"', loop, distance=2em, in=305, out=235]
\end{tikzcd}
\end{minipage}
%
\begin{minipage}{.10\textwidth}
$\xleftarrow{\text{   U   }}$
\end{minipage}
%
\begin{minipage}{.37\textwidth}
\begin{tikzcd}[boxedcd={inner xsep=1.5em, inner ysep=3em}]
B \arrow[rrrr, "\psi"] \arrow[rrrrddd, "\psi\rho", pos=0.3] \arrow["1_{B}"', loop, distance=2em, in=125, out=55] &  &  &  &
C \arrow[ddd, "\rho"] \arrow["1_{C}"', loop, distance=2em, in=125, out=55]\\
 &  &  &  & \\
 &  &  &  & \\
A \arrow[uuu, "\varphi"] \arrow[rrrruuu, "\varphi\psi", pos=0.3] \arrow[rrrr, bend left, "(\varphi\psi)\rho" ', shift right=2]
\arrow[rrrr, "\varphi(\psi\rho)", bend right] \arrow["1_{A}"', loop, distance=2em, in=305, out=235] &  &  &  &
D \arrow["1_{D}"', loop, distance=2em, in=305, out=235]
\end{tikzcd}
\end{minipage}
\begin{minipage}{.08\textwidth}
\phantom{}
\end{minipage}\\

\noindent In the category on the left, associativity of composition guaranteed that $(\varphi\psi)\rho = \varphi(\psi\rho)$, so those two arrows
were already the same, so they are mapped to the same arrow $f = U((\varphi\psi)\rho) = U(\varphi(\psi\rho))$ in the quiver on the right.
We didn't have to draw both arrows for $f$, but since they are equal, there is still only one arrow in the hom-set $\textup{Hom}_{q}(1,4)=\{f,f\} = \{f\}$.\\
All the other identities are not preserved under the forgetful functor, e.g. $d$ doesn't know what it has to do with $a$ and $b$ apart from
$s(d) = s(a)$ and $t(d) = t(b)$. Especially the former identity arrows are now just endomorphisms with no defining property.\\
The paths $g^{2}f, gf$ and $fj^{3}$ are all different, while in the category, they all simplify to
$1_{A}1_{A}(\varphi\psi)\rho = 1_{A}(\varphi\psi)\rho = (\varphi\psi)\rho1_{D}1_{D}1_{D} =  (\varphi\psi)\rho$ due to the unit property and associativity.
\end{example}


\subsection{Natural transformations}

With fixed categories $\mathcal{C}$ and $\mathcal{D}$ we can consider functors $F, G \in \textup{Hom}(\mathcal{C},\mathcal{D})$ themselves
as objects in the category $\textup{Hom}(\mathcal{C},\mathcal{D})$ of functors between $\mathcal{C}$ and $\mathcal{D}$. In this \ul{functor category},
the morphisms between two functors are called \ul{natural transformations}.

\begin{definition}{(Natural transformations)}\label{def:natural_transformation}\\
\noindent Given categories $\mathcal{C}$ and $\mathcal{D}$ and functors $F : \mathcal{C} \rightarrow \mathcal{D}$ and
$G : \mathcal{C} \rightarrow \mathcal{D}$, a \ul{natural transformation} $\alpha : F \Rightarrow G$ consists of:
\begin{itemize}
\item a morphism $\alpha_{c} : Fc \rightarrow Gc \in \mathcal{D}_{1}$ for each object $c \in \mathcal{C}_{0}$, the collection of which
define the \ul{components} of the natural transformation, so that, for any morphism $f : c \rightarrow c' \in \mathcal{C}_{1}$, the following
square of morphisms in $\mathcal{D}$
\[\begin{tikzcd}
Fc \arrow[rr, "\alpha_{c}"] \arrow[dd, "Ff"] &  & Gc \arrow[dd, "Gf"] \\
                                             &  &                     \\
Fc' \arrow[rr, "\alpha_{c'}"]                &  & Gc'                
\end{tikzcd}\]

\ul{commutes}, i.e., has a a common composite $Fc \rightarrow Gc' \in \mathcal{D}_{1}$.
\end{itemize}
\end{definition}

\begin{definition}[Monic, epic and iso natural transformations]
When each component $\alpha_{c}$ is a...
\begin{itemize}
\item monomorphism, we call $\alpha$ a \ul{natural monomorphism},
\item epimorphism, we call $\alpha$ a \ul{natural epimorphism},
\item isomorphism, we call $\alpha$ a \ul{natural isomorphism}.
\end{itemize}
\end{definition}

\subsection{The functor category}

\begin{definition}{(The functor category)}\label{def:functor_category}\endnote{(cited from ncatlab \cite{[ncatlab_functor_category]})}\\
Given categories $\mathcal{C}$ and $\mathcal{D}$, the \ul{functor category} - written $\mathcal{D}^{\mathcal{C}}$, $\textup{Hom}(\mathcal{C},
\mathcal{D})$ or $[\mathcal{C}, \mathcal{D}]$ -
is the category whose
\begin{itemize}
\item objects are functors $F : \mathcal{C} \rightarrow \mathcal{D}$
\item morphisms are natural transformations between these functors.
\end{itemize}
Main usage of functor categories is as $\textup{Hom}$ categories in place of hom-sets (comp. \ref{def:hom_set} and \ref{ex:hom_functor}) where
we have much more than a set, namely a whole category of morphisms between two objects (together with the morphisms between morphisms).
\end{definition}
