% mainfile: ../main.tex

\section{Finite concrete categories}

\begin{definition}{(Finite and concrete categories)}
\renewcommand{\labelenumi}{(\theenumi)}
\begin{enumerate}
\item A \ul{finite} category is a category with a finite set of objects and a finite set of morphisms.
\item A \ul{concrete} category is a category whose objects have \ul{underlying sets} (or are themselves sets) and whose morphisms are
functions between these underlying sets. Otherwise it's called an \ul{abstract} category.
\end{enumerate}
\end{definition}

\noindent Clearly every finite concrete category is a small category.

\begin{remark}[Implementation]
Using the implementation of \texttt{FinSets} in %\cite{[BMZ20]} 
we implement a finite concrete category as a subcategory of FinSets.
The finite concrete category is generated by its set of generating morphisms $\{g_{1},\dots,g_{r}\}$.
\end{remark}

When our goal is representation of finite concrete categories, i.e. functors $\mathcal{C} \rightarrow k\text{-Mat}$, why are we not
defining the functor $\textup{Hom}(\mathcal{C},k\text{-Mat})$ but instead first define the $k$-Algebroid $kq$ of the\\
$\texttt{RightQuiverFromConcreteCategory}(\mathcal{C})$ and then the functor $\textup{Hom}(kq,k\textup{-Mat})$?

\begin{definition}
A \ul{congruence relation} $\sim$ on a category $\mathcal{C}$ is an equivalence relation on the set of morphisms $\mathcal{C}_{1}$ such that
for pre-composable $c$ and post-composable $d \in \mathcal{C}_{1}$:
\[ a \sim b => ca \sim cb \land ad \sim bd \]
The equivalence classes $[f]_{\sim}$ again form a set of morphisms $\mathcal{C}_{1}/\sim$.
\end{definition}

We can calculate the \texttt{RightQuiverFromConcreteCategory}. We can calculate the \texttt{CategoryClosure} of that quiver indirectly by first
calculating the \texttt{Algebroid}$( k, \mathcal{C} )$ and then the \texttt{UnderlyingCategory}.


As a subcategory of \textbf{FinSets}, our finite concrete category $\mathcal{C}$ does not have a pre-additive structure on it, i.e. for
two objects $M,N, \textup{Hom}_{\mathcal{C}}(M,N)$ does not have the structure of an abelian group.

The category \textbf{FinSets} as a subcategory of \textbf{Sets} does not have a zero object, since the empty set $\emptyset$ is the
unique initial object and every singleton is a terminal object which is different from the initial object.

\begin{example}
Forgetful functor / Category closure / k-Algebroid
\end{example}

When we want to calculate representations of our finite concrete categories, we make the Hom functor Hom( ccat, kMat ).
But functors from the concrete category directly are not useful when we know nothing about the relations of morphisms
in our category.
Instead we go an indirect route, first calculating the underlying quiver and from this the k-algebroid, i.e. the path algebra
with the endomorphism relations and such.

\begin{algorithm}\capstart
    \caption{\texttt{RightQuiverFromConcreteCategory}}\label{algo:RightQuiverFromConcreteCategory}
	\SetKwInput{Input}{Input~}
	\SetKwInput{Output}{Output~}
	\Input{~a finite concrete category $C$ with $n$ objects}
	\Output{~the right quiver $q(n)$}
	\BlankLine
	let $Obj$ be the set of objects of $C$\;
	let $n := Length(Obj)$\;
	let $gMor$ be the set of generating morphisms of $C$\;
	let $A$ be the empty set and let $i := 1$\;
	\ForEach{morphism $mor$ in $gMor$}{
	    let $A_{i,1}$ be the position of $Source( mor )$ in $Obj$\;
	    let $A_{i,2}$ be the position of $Range( mor )$ in $Obj$\;
	    let $i := i+1$\;
	}
	\BlankLine
	let $q$ be the right quiver with vertices $\{1,\dots,n\}$ and arrows $A$.
	\BlankLine
	\Return q\;
\end{algorithm}
