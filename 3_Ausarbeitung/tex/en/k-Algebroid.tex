% mainfile: ../main.tex

Our goal is to represent finite concrete categories, for this we need the source and target categories of our functors, which the
representations are.
As subcategories of $\textup{FinSets}$, our finite concrete categories only have definitions for their objects and their
morphisms, methods to check when two morphisms are congruent or equivalent, but not much else.
A competing theory to category theory is that of quivers and path algebras. We already used their terminology in
\ref{def:path}, \ref{la:cyclic_paths} and \ref{def:path_algebra}, for instance when talking about the trivial path,
which in the language of category theory is nothing but the identity morphism, composition of arrows to a path is nothing but
composition of morphisms (if you make the path explicit by writing a new arrow for every path).

So what we called a \ul{path algebra} in \ref{def:path_algebra} is a different data structure for a category. 
For one, the path algebra is an algebra, i.e. a vector space with additional structure, and thus a single set, comparable to the
class of morphisms $\mathcal{C}_{1}$ of a category $\mathcal{C}$.
But as it is an algebra, it not only contains the generating morphisms of the category, but also $\Bbbk$-linear combinations of
morphisms and paths. This is what our concrete categories lack, and what additional structure we have to give them in order
to represent them by matrices.

In practise, there is already developed software for \ul{q}uivers and \ul{p}ath \ul{a}lgebras, namely the \textsc{Gap} package
\textsc{QPA$2$}\endnote{(see \cite{[QPA2]})}.
What we are actually doing to represent finite concrete categories, is going from $\mathcal{C} \in \mathbf{Cats}$ to $q \in \mathbf{Quiv}$,
in theory by \ul{forgetting} (see \ref{ex:forgetful_functor}) the category concepts of identity morphism and composition, in practise by calculating the
underlying quiver $q$, and then for a commutative ring $\Bbbk$, constructing the path algebra $\Bbbk q$, which we then
take back into the category theoretical context by constructing the $\Bbbk$-\textbf{Algebroid} $\mathcal{A}$ from the path algebra $\Bbbk q$.

The source category for our representation is then the $\Bbbk$-\textbf{Algebroid} $\mathcal{A}$ and not anymore our finite concrete
category $\mathcal{C}$, but it behaves in the same way regarding composition of morphisms and which morphisms are congruent.

The target category of our category representations will be $\Bbbk$-\textbf{Mat} which we will describe in the next section.\endnote{
In \cite{[Ab-Cat]}, Posur used the equivalence between categories $\textup{mat}_{\Bbbk} \cong \textup{vec}^{\text{fd}}_{\Bbbk}$,
as described in \cite{[context]}, \textsc{Example} 1.5.6 on page 30 (48/258), to justify that $\Bbbk$-\textbf{Mat} is a good
\textbf{computational model} to
%\setquotestyle[guillemets]{english} don't do that!
\blockquote{transform otherwise inaccessible mathematical objects into computationally easily graspable entities}
\setquotestyle{default}, which is what we are doing with \textbf{CatReps}.
}

With source and target categories defined, the category where our category representations lie in is \textbf{CatReps} for which we
show that it's a subcategory of the \textbf{Functor Category}.

\subsection{Ab-categories}

\begin{example}{(Group as a category)}\\
\noindent A group $\mathbf{G}$ defines a category $\mathcal{B}\mathbf{G}$ with a single object $\ast$. The group elements are its morphisms, which are
all automorphisms (i.e. bijective endomorphisms) of the single object. Composition of morphisms is defined by the binary group operation.
The identity element $e \in G$ acts as the identity morphism for the unique object in this category. The hom-set of that category is itself
a group.
\end{example}

This example can be generalized to categories where the hom-set is a ring or an R-algebra. But for this we need a commutative ring R and thus
the category R-Mod.

\begin{definition}{Ab-Category}
An \ul{Ab-category} is a category in which all homomorphism sets are abelian groups. That means in addition to the composition
of morphisms \begin{tikzcd}[column sep=small] \mu:\mathcal{C}_{1} \times \mathcal{C}_{1} \arrow[rr] &  & \mathcal{C}_{1}
\end{tikzcd} we have another binary operation \begin{tikzcd}[column sep=small] +:\mathcal{C}_{1} \times \mathcal{C}_{1} \arrow[rr] &  & \mathcal{C}_{1}
\end{tikzcd}, that distributes over the composition, i.e. \[\mu(f+g,h) = \mu(f,h)+\mu(g,h)\].
\end{definition}

The concept of a functor is central in category theory. It is how the objects and morphisms of two categories relate to one another.

\begin{definition}{(Functor)}\\
In the category \textbf{Cat} which has categories as objects, \ul{functors} are the morphisms between these objects.
Let $\mathcal{C},\mathcal{D} \in \textup{Obj}\,\textbf{Cat}$ be categories. A \ul{functor} \begin{tikzcd}
F: \mathcal{C} \arrow[r] & \mathcal{D}
\end{tikzcd} between $\mathcal{C}$ and $\mathcal{D}$ consists
of the following data:
\renewcommand{\labelenumi}{(\theenumi)}
\begin{enumerate}
\item For every object $c \in \mathcal{C}_{0}$ there is an object $Fc \in \mathcal{D}$.
\item For every morphism $f \in \mathcal{C}_{1}$, i.e. \begin{tikzcd} c \arrow[r, "f"] & c' \end{tikzcd} there is a morphism
$Ff \in \mathcal{D}_{1}$ with \begin{tikzcd} Fc \arrow[r, "Ff"] & Fc' \end{tikzcd}, i.e. $s(Ff) = F\,s(f)$ and $t(Ff) = F\,t(f)$
\newcounter{saveenum}
\setcounter{saveenum}{\value{enumi}}
\end{enumerate}
Functors are compatible with the identity map and the composition map:
\begin{enumerate}
\setcounter{enumi}{\value{saveenum}}
\item For every object $c \in \mathcal{C}_{0}$ we have $1_{c} \in \mathcal{C}_{1}$ and for the functor $F$ we demand that
$F\,1_{c} = 1_{Fc} \in \mathcal{D}_{1}$. 
\item For every pair of morphisms $f,g \in \mathcal{C}_{1}$ with $t(f) = s(g)$ we have $fg \in \mathcal{C}_{1}$ and we demand that
$Fg\,Fg = F\,gf$.
\end{enumerate}
\end{definition}

With the definition of a category and the category of functors finished, we can come back and use them to define the category of quivers
\textbf{Quiv}.

\begin{definition}{(The category \textbf{Quiv})}\cite{[4681]}
Let the \ul{Kronecker category} $\mathcal{K}$ be the category with two objects, $0$ and $1$, and two non-identity morphisms, s and t
\begin{tikzcd}
1 \arrow[r, "s", shift left] \arrow[r, "t"', shift right] & 0
\end{tikzcd}.
Let \textbf{FinSets} be the category of finite sets with morphisms being maps between those sets.
The \ul{category of quivers} \textbf{Quiv} is the category of functors from $\mathcal{K}$ to \textbf{FinSets}.
For a quiver $q \in \textup{Obj}\,\textbf{Quiv}$ we write $q_{x}$ for the image of $x \in \{0,1\}$ under $q$.
The images under $q$ of the morphisms $s$ and $t$ are again denoted by $s$ and $t$.
\end{definition}


\noindent As we have seen, every category is a quiver, but in general, to become a category, a quiver is lacking identity morphisms
and the composition of morphisms. To be more precise, there is a \ul{functor} $U$ from the \ul{category of categories} $\textup{CAT}$ to the
\ul{category of quivers} $\textup{Quiv}$, called the \ul{underlying quiver} or \ul{forgetful functor}.
\[
\begin{tikzcd}
\textup{Cat} \arrow[rr,"U"] &  & \textup{Quiv}
\end{tikzcd}
\]
mapping every object $M \in \mathcal{C}_{0}$ to the same objects in $q_{0}$, mapping every arrow $\varphi \in \mathcal{C}_{1}$ to 
an arrow $a \in q_{1}$, respecting source and target, but forgetting the special role of the identity morphisms and of the composition morphisms.

\newpage
\begin{example}{(Underlying quiver)}\\

\noindent\begin{minipage}{.08\textwidth}
\phantom{}
\end{minipage}
\begin{minipage}{.37\textwidth}
\begin{tikzcd}[boxedcd={inner xsep=1.5em, inner ysep=3em}]
B \arrow[rrrr, "\psi"] \arrow[rrrrddd, "\psi\rho", pos=0.3] \arrow["1_{B}"', loop, distance=2em, in=125, out=55] &  &  &  &
C \arrow[ddd, "\rho"] \arrow["1_{C}"', loop, distance=2em, in=125, out=55]\\
 &  &  &  & \\
 &  &  &  & \\
A \arrow[uuu, "\varphi"] \arrow[rrrruuu, "\varphi\psi", pos=0.3] \arrow[rrrr, bend left, "(\varphi\psi)\rho" ', shift right=2]
\arrow[rrrr, "\varphi(\psi\rho)", bend right] \arrow["1_{A}"', loop, distance=2em, in=305, out=235] &  &  &  &
D \arrow["1_{D}"', loop, distance=2em, in=305, out=235]
\end{tikzcd}
\end{minipage}
%
\begin{minipage}{.10\textwidth}
\begin{tikzcd}
{} \arrow[r, "U", Rightarrow] & {}
\end{tikzcd}
\end{minipage}
%
\begin{minipage}{.37\textwidth}
\begin{tikzcd}[boxedcd={inner xsep=1.5em, inner ysep=3em}]
2 \arrow[rrrr, "b"] \arrow[rrrrddd, "e", pos=0.3] \arrow["h"', loop, distance=2em, in=125, out=55] &  &  &  &
3 \arrow[ddd, "c"] \arrow["i"', loop, distance=2em, in=125, out=55]\\
 &  &  &  & \\
 &  &  &  & \\
1 \arrow[uuu, "a"] \arrow[rrrruuu, "d", pos=0.3] \arrow[rrrr, bend left, "f" ', shift right=2]
\arrow[rrrr, "f", bend right] \arrow["g"', loop, distance=2em, in=305, out=235] &  &  &  &
4 \arrow["j"', loop, distance=2em, in=305, out=235]
\end{tikzcd}
\end{minipage}
\begin{minipage}{.08\textwidth}
\phantom{}
\end{minipage}\\

\noindent In the category on the left, associativity of composition guaranteed that $(\varphi\psi)\rho = \varphi(\psi\rho)$, so those two arrows
were already the same, so they are mapped to the same arrow $f = U((\varphi\psi)\rho) = U(\varphi(\psi\rho))$ in the quiver on the right.
We didn't have to draw both arrows for $f$, but since they are equal, there is still only one arrow in the hom-set $\textup{Hom}_{q}(1,4)=\{f,f\} = \{f\}$.\\
All the other identities are not preserved under the forgetful functor, e.g. $d$ doesn't know what it has to do with $a$ and $b$ apart from
$s(d) = s(a)$ and $t(d) = t(b)$. Especially the former identity arrows are now just endomorphisms with no defining property.\\
The paths $g^{2}f, gf$ and $fj^{3}$ are all different, while in the category, they all simplify to
$1_{A}1_{A}(\varphi\psi)\rho = 1_{A}(\varphi\psi)\rho = (\varphi\psi)\rho1_{D}1_{D}1_{D} =  (\varphi\psi)\rho$ due to the unit property and associativity.
\end{example}


\begin{definition}{(Ab-category)}
An \ul{Ab-category} is a category in which all homomorphism sets are abelian groups, and composition distributes over addition.\\
In other words,
A category $\mathcal{C}$ is an \ul{Ab-category} if for every pair of objects $M,N \in \mathcal{C}_{0}$, $( \textup{Hom}_{\mathcal{C}}(M,N), + )$ is
an abelian group (with the neutral element called \ul{zero morphism}), and for all morphisms $\gamma, \delta \in \textup{Hom}_{\mathcal{C}}(M,N),
\alpha, \beta \in \textup{Hom}_{\mathcal{C}}(N,L)$
\[
(\gamma + \delta)\alpha = \gamma\alpha + \delta\alpha \textup{ and }\]\[
\gamma(\alpha+\beta) = \gamma\alpha + \gamma\beta.
\]
Note that every hom-set has its own unique zero morphism. E.g. in $\textup{Mat}_{\mathbb{Q}}$ the 2-by-3 zero-matrix $\mathbf{0} \in \textup{Hom}(2,3)$ is different from
the 4-by-4 zero-matrix $\mathbf{0} \in \textup{Hom}(4,4)$.
\end{definition}

\begin{definition}{(Initial object, terminal object, zero object)}

\end{definition}

\begin{example}{}

\end{example}

\begin{definition}{(Kernel of a morphism}

\end{definition}

\begin{definition}{(Abelian category)}

\end{definition}
\begin{definition}{(k-linear category)}

\end{definition}


Quiver -> CAT: U: forget 1, forget composition

search $U^{-1}$

Beispiel für Adjunktion


Path Algebra: