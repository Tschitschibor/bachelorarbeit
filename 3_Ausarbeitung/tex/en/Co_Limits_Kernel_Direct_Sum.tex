% mainfile: ../main.tex

\subsection{Limit and colimit of a functor}

\begin{definition}{(Source of a functor)}
Let $D : \mathbf{I} \rightarrow \mathcal{C}$ be a functor. A \ul{source} of $D$ consists of the following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $S \in \mathcal{C}$.
\item A dependent function $s$ mapping an object $i \in \mathbf{I}_{0}$ to a morphism
$s(i) : S \rightarrow D(i)$ such that for all $i, j \in \mathbf{I}, \iota : i \rightarrow j$, we have $D(\iota) \cdot s(i) = s(j)$.
\end{enumerate}
\end{definition}

\begin{definition}{(Limit and colimit of a functor)}\label{def:limit}
Let $D : \mathbf{I} \rightarrow \mathcal{C}$ be a functor. A \ul{limit} of $D$ consists of the
following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item A source of $D$ given by the data $(\mathrm{lim}\, D, (\lambda(i) : \mathrm{lim}\, D \rightarrow D(i))_{i\in\mathbf{I}_{0}})$.
\item A dependent function $u$, called the \ul{lift}, mapping every source $\tau = (T, (\tau(i) : T \rightarrow D(i))_{i \in \mathbf{I}})$ to a
morphism $u(\tau) : T \rightarrow \mathrm{lim}\, D$ such that $\lambda(i) \cdot u(\tau) = \tau(i)$ for all $i \in \mathbf{I}$.\label{itm:2}
\item For any other dependent function $v$ satisfying (\ref{itm:2}), we have $u = v$.
\end{enumerate}
A \ul{colimit} of $D$ is a limit of $D' : \mathbf{I} \rightarrow \mathcal{C}^{\mathrm{op}}$.
\end{definition}

\begin{definition}{(Limits of type \textbf{I})}
Let $\mathbf{I}$ be a category. We say a category $\mathcal{C}$ \ul{has limits of type} $\mathbf{I}$ if it is
equipped with a dependent function $\lambda$ mapping a functor $D : \mathbf{I} \rightarrow \mathcal{C}$ to a limit
$(\mathrm{lim}\, D, \lambda_{D}, u_{D})$ of $D$.
We say $\mathcal{C}$ \ul{has colimits of type} $\mathbf{I}$ if $\mathcal{C}^{\mathrm{op}}$ has limits of that type.
\end{definition}

\begin{example}\label{ex:limits}
Depending on \textbf{I} some limits and colimits have special names:
\begin{center}
\begin{tabular}{c|c|c}
generating quiver of $\mathbf{I}$ & limit & colimit \\
\hline
$\emptyset$ & terminal object & initial object \\
$\cdot \text{\phantom{$\rightarrow$}} \cdot$ & binary product & binary coproduct \\
$\cdot \rightarrow \cdot \leftarrow \cdot$ & binary pullback & - \\
$\cdot \leftarrow \cdot \rightarrow \cdot$  & - & binary pushout \\
$ \cdot \rightrightarrows \cdot$ & binary equalizer & binary coequalizer
\end{tabular}
\end{center}
\end{example}

In the following subsections, we give explicit definitions for the limits in \ref{ex:limits} and define the
doctrines for our categories with such limits. The doctrine we are interested is that of an abelian category with
enough projectives and enough injectives.
We are starting simple with pre-additive categories. All we need is a zero object:

\subsection{Pre-additive categories}

\begin{remark}[Terminal object, initial object, zero object]\label{def:init_term_zero_object}
The limit / colimit of $\emptyset$.\\
\renewcommand{\labelenumi}{(\theenumi)}
\begin{enumerate}
\item A \ul{terminal object} $T$ in a category $\mathcal{C}$ is an object such that $\textup{Hom}_{\mathcal{C}}(-,T)$ is a singleton.
\item An \ul{initial object} $I$ in a category $\mathcal{C}$ is an object such that $\textup{Hom}_{\mathcal{C}}(I,-)$ is a singleton.
\item An object $Z$ or $0$ is a \ul{zero object} if it is both initial and terminal.
\end{enumerate}
\end{remark}

\begin{definition}[Zero morphism]\label{def:zero_morphism}\phantom{}\\
A \ul{zero morphism} in a category with a zero object $0$ is a morphism factoring over $0$, i.e. $\varphi : M \rightarrow N$ is called a zero
morphism, if\\
\begin{minipage}{.35\textwidth}
\begin{tikzcd}
M \arrow[rr, "\varphi"] \arrow[rd, "\varphi_{1}"] &                              & N \\
                                                  & 0 \arrow[ru, "\varphi_{2}"'] &  
\end{tikzcd}
\end{minipage}
\begin{minipage}{.65\textwidth}
$\exists \varphi_{1} : M \rightarrow 0, \varphi_{2} : 0 \rightarrow N$\\
such that $\varphi = \varphi_{1}\varphi_{2}$.
\end{minipage}
Since the zero object $0$ is both initial and terminal, a zero morphism is uniquely defined by its source and target, thus we can
talk about \textit{the} zero morphism from $M$ to $N$, which we denote by $0_{M,N}$.
\end{definition}

\begin{definition}[Pre-additive category]
A \ul{pre-additive category} (also called  \ul{Ab-category}) is a category in which all homomorphism sets are abelian groups,
and composition distributes over addition.\\
In other words, a category $\mathcal{C}$ is an Ab-category if for every pair of objects $M,N \in \mathcal{C}_{0}$,
$( \textup{Hom}_{\mathcal{C}}(M,N), + )$ is an abelian group (with the zero morphism $0_{M,N}$ as the neutral element),
and for all morphisms $\gamma, \delta \in \textup{Hom}_{\mathcal{C}}(M,N),
\alpha, \beta \in \textup{Hom}_{\mathcal{C}}(N,L)$
\begin{align}
(\gamma + \delta)\alpha &=\label{eq:dist1} \gamma\alpha + \delta\alpha \textup{ and }\\
\gamma(\alpha+\beta) &=\label{eq:dist2} \gamma\alpha + \gamma\beta.
\end{align}
Note that every hom-set has its own unique zero morphism. E.g. in $\kmat$ the $2 \times 3$ zero-matrix
$0_{2,3} \in \textup{Hom}_{\kmat}(2,3)$ is different from the $4 \times 4$ zero-matrix $0_{4,4} \in \textup{Hom}_{\kmat}(4,4)$.
\end{definition}

\begin{definition}{(Ab-functor)}
A functor between Ab-categories is called an \ul{Ab-functor} if in the functor definition \ref{def:functor} the function $Ff$ for each
morphism $f$ is a homomorphism of abelian groups, i.e. $F(f+g) = Ff + Fg$.
\end{definition}

\subsection{Additive categories}
The definition of the binary operation $+$ in a pre-additive category came as arbitrary outside data and could be defined
in multiple ways. A category with the following limits is additive in at most one way, warrenting the name additive category.

\begin{definition}[Product, coproduct]\label{def:prod_coprod}
The limit / colimit of a set $\cdot \text{\phantom{$\rightarrow$}} \cdot$ of objects.\\
Let $I$ be an index set and $\{A_{i}\}_{i\in I}$ a family of objects in a category $\mathcal{C}$.
\setlist[description]{font=\normalfont}
\begin{description}
\item[(prod)] The \ul{product} of the family $\{A_{i}\}_{i\in I}$ is an object $\invamalg A_{i}$ together with a family of morphisms
\[
\{ \pi_{i} : \invamalg A_{i} \rightarrow A_{i} \}
\]
called \ul{projections}, such that the following universal property is satisfied:\\
For any object $M \in \mathcal{C}_{0}$ and any family $\{ \varphi_{i} : M \rightarrow A_{i} \}_{i\in I}$ of morphisms, there exists
a unique morphism $\varphi : M \rightarrow \invamalg A_{i}$ called the \ul{product morphism} such that
\[
\varphi \pi_{i} = \varphi_{i} \, \forall i \in I.
\]
\begin{tikzcd}
                                                                                                                            &  &                                                          & A_{1} \\
M \arrow[rrru, "\varphi_{1}", bend left] \arrow[rrrd, "\varphi_{2}"', bend right] \arrow[rr, "\exists^{1} \varphi", dashed] &  & A_{1}\invamalg A_{2} \arrow[ru, "\pi_{1}"] \arrow[rd, "\pi_2"] &       \\
                                                                                                                            &  &                                                          & A_{2}
\end{tikzcd}
\item[(coprod)] The dual notion to product is the \ul{coproduct} of the family $\{A_{i}\}_{i\in I}$, that is an object $\amalg A_{i}$ together with
a family of morphisms
\[
\{ \iota_{i} : A_{i} \rightarrow \amalg A_{i} \}
\]
called \ul{coprojections} or sometimes \ul{injections} or \ul{inclusions}, such that the following universal property is satisfied:\\
For any object $M \in \mathcal{C}$ and any family $\{ \psi_{i} : A_{i} \rightarrow M \}$ of morphisms, there exists a unique
morphism $\psi : \amalg A_{i} \rightarrow M$ called the \ul{coproduct morphism} such that
\[
\iota_{i} \psi = \psi_{i} \, \forall i \in I.
\]
\begin{tikzcd}
  &  &                                                           & A_{1} \arrow[llld, "\psi_{1}"', bend right] \arrow[ld, "\iota_{1}"'] \\
M &  & A_{1}\amalg A_{2} \arrow[ll, "\exists^{1} \psi"', dashed] &                                                                      \\
  &  &                                                           & A_{2} \arrow[lllu, "\psi_{2}", bend left] \arrow[lu, "\iota_2"]     
\end{tikzcd}
\end{description}
\end{definition}

\begin{definition}[Biproduct]\label{def:biproduct}
Let $I$ be an index set and $\{S_{i}\}_{i\in I}$ a family of objects in a category $\mathcal{C}$.
A \ul{biproduct} is a product and a coproduct simultaneously, i.e. consists of the following data:
\begin{itemize}
\item an object $S \in \mathcal{C}_{0}$,
\item a family of morphisms $\pi = \{ \pi_{i} : S \rightarrow S_{i} \}_{i\in I}$,
\item a family of morphisms $\iota = \{ \iota_{i} : S_{i} \rightarrow S \}_{i\in I}$,
\item a dependent function $u_{\text{in}}$ mapping every family $\tau = \{ \tau_{i} : T \rightarrow S_{i} \}_{i\in I}$ to a morphism
$u_{\text{in}}(\tau) : T \rightarrow S$ such that $u_{\text{in}}(\tau) \pi_{i} \sim \tau_{i}$ for all $i \in I$,
\item a dependent function $u_{\text{out}}$ mapping every family $\rho = \{ \rho_{i} : S_{i} \rightarrow R \}_{i\in I}$ to a morphism
$u_{\text{out}}(\rho) : S \rightarrow R$ such that $\iota_{i} u_{\text{out}}(\rho) \sim \rho_{i}$ for all $i \in I$,
\end{itemize}
\end{definition}

\begin{definition}{(Direct sum)}\label{def:direct_sum}
A \ul{direct sum} is a biproduct of objects in an Ab-category such that
\begin{itemize}
\item $\sum_{i\in I}  \pi_{i} \iota_{i} \sim 1_{S}$,
\item $ \iota_{i} \pi_{j} \sim \delta_{i, j} =  \begin{cases}
            1_{S_{i}} & \text{ if } i = j  \\
            0_{ij} & \text{ if } i \neq j
        \end{cases}$,
\end{itemize}
where $\delta_{i, j} \in \mathrm{Hom}(S_{i}, S_{j})$ is the identity if $i = j$, and the zero morphism $0_{ij} := 0_{S_{i}, S_{j}}$ otherwise.
\end{definition}

\begin{definition}\label{def:additive_category}
An \ul{additive category} is a pre-additive category $\mathcal{C}$ together with a dependent function $\oplus^{\mathcal{C}}$ mapping
a finite set $I$ and a family $(A_{i})_{i\in I}$ of objects in $\mathcal{C}$ to a corresponding direct sum $(\oplus_{i\in I}^{\mathcal{C}} A_{i},
(\pi_{i})_{i\in I}, (\iota_{i})_{i\in I})$.
\end{definition}

\begin{remark}[Addition of morphisms]
In an additive category the abelian group structure on $\mathrm{Hom}_{\mathcal{C}}(M,N)$ can be derived from the direct sum:
For $\rho_{1}, \rho_{2} \in \mathrm{Hom}_{\mathcal{C}}(M,N)$
\[
\rho_{1} + \rho_{2} = u_{\mathrm{in}}(1_{M},1_{M}) u_{\mathrm{out}}(\rho_{1},\rho_{2}) 
= u_{\mathrm{in}}(\rho_{1},\rho_{2}) u_{\mathrm{out}}(1_{N},1_{N})
\]
This makes $\kmat$ an example of an additive category. The above equation illustrates that an additive category is
pre-additive in at most one way, i.e. we don't have a choice how we define the abelian group structure on the hom-sets.
\endnote{This result is already implemented in \textsc{Cap} as a derivation of \texttt{AdditionForMorphisms} from the four morphisms
\texttt{UniversalMorphismIntoDirectSum}, \texttt{IdentityMorphism}, \texttt{UniversalMorphismFromDirectSum} and \texttt{PreCompose}.
See 
\url{https://github.com/homalg-project/CAP_project/blob/v2019.06.06/CAP/gap/DerivedMethods.gi\#L1024})}
\end{remark}

\subsection{Pre-abelian categories}

The dashed arrow in the diagrams of last subsection carried the meaning of uniqueness in the sense of \ref{def:limit}(3).
Throughout the thesis we will be using two other kinds of arrows $\hookrightarrow$ and $\twoheadrightarrow$ carrying the
following meaning:

\begin{definition}[Monomorphism and epimorphism]
A morphism $f : A \rightarrow B$ in a category is
\begin{itemize}
\item a \ul{monomorphism} if for any parallel morphisms $h, k : Z \rightrightarrows A, hf = kf$ implies that
$h = k$; or
\item an \ul{epimorphism} if for any parallel morphisms $h, k : B \rightrightarrows C, fh = fk$ implies that
$h = k$.
\end{itemize}
We write $f : A \hookrightarrow B$ for a monomorphism and $f : A \twoheadrightarrow B$ for an epimorphism.
\endnote{We can define monomorphisms and epimorphisms in a different way which gives us an opportunity to use the limit of
$\cdot \rightarrow \cdot \leftarrow \cdot$ called \ul{pullback} and the colimit of $\cdot \leftarrow \cdot \rightarrow \cdot$ called \ul{pushout}. 
A morphism $f : A \rightarrow B$ is a monomorphism if and only if the pullback of $f$ and $f$ exists and is equal to $A$
(together with the identity maps $1_{A}$). Dually, a morphism $f : A \rightarrow B$ is an epimorphism if and only if the pushout of
$f$ and $f$ exists and is equal to $B$ (together with the identity maps $1_{B}$). Since we will not be using pullbacks and pushouts any further,
this definition was moved to the endnotes, and proving the equivalences is left as an exercise for the reader. For further reading
\url{https://qchu.wordpress.com/2012/09/29/monomorphisms-and-epimorphisms/}}
\end{definition}

\begin{definition}[binary equalizer]
The limit of two parallel morphisms $\cdot \rightrightarrows \cdot$\\
If it exists in a category $\mathcal{C}$, the \ul{equalizer} of two morphisms $f, g : A \rightrightarrows B \in \mathcal{C}_{1}$
consists of the data
\begin{itemize}
\item an object $E := \mathrm{eq}(f,g) \in \mathcal{C}_{0}$
\item a morphism $\iota := \mathrm{eq}(f,g) \rightarrow A$ such that pulled back to
$\mathrm{eq}(f,g)$ both morphisms are equal
\[
\iota f = \iota g
\]
\item a dependent function $u$ such that for any other morphism $\tau : T \rightarrow A$ with $\tau f = \tau g$
we have a morphism $u( \tau ) : T \rightarrow E$ such that $u( \tau ) \iota = \tau$.
\end{itemize}
The dual concept is that of a \ul{coequalizer}.
\end{definition}

The following definition is a special case of an equalizer where $g = 0_{A,B}$. We will write it all out explicitly with their
own names for objects and morphisms.

\begin{definition}[Kernel]
In an additive category $\mathcal{C}$, the \ul{kernel} of a morphism $f : A \rightarrow B \in \mathcal{C}_{1}$ is the equalizer
of $f$ and $0_{A,B}$, i.e. consists of the data
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $K = \mathrm{Ker}(f)$
\item A morphism $\mathrm{KernelEmbedding}(f) := \kappa : K \rightarrow A$ such that
\[
\kappa \cdot f = 0_{K,B}
\]
\item A dependent function $\mathrm{KernelLift}(f,-) := ( - /\kappa)$ mapping a morphism $\tau : T \rightarrow A$ with $\tau f = 0_{T,B}$ to a
morphism $\mathrm{KernelLift}(f,\tau) (\tau / \kappa) : T \rightarrow K$ such that
\[
\tau =\label{eq:kernel_lift} (\tau / \kappa) \cdot \kappa.
\]
\item For any other dependent function $v$ satisfying \eqref{eq:kernel_lift}, $v = ( - / \kappa)$.
\end{enumerate}
\[
\begin{tikzcd}
K \arrow[rrr, "\mathrm{KernelEmbedding}(\alpha)", hook]                                     &  &  & A \arrow[r, "\alpha"] & B \\
T \arrow[rrru, "\tau"', bend right] \arrow[u, "{\mathrm{KernelLift}(\alpha,\tau)}", dashed] &  &  &                       &  
\end{tikzcd}
\]
\end{definition}

\begin{definition}[Cokernel]
In an additive category $\mathcal{C}$, the \ul{cokernel} of a morphism $f : A \rightarrow B \in \mathcal{C}_{1}$ is the coequalizer of
$f$ and $0_{A,B}$, i.e. consists of the data
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $C = \mathrm{Coker}(f)$
\item A morphism $\mathrm{CokernelProjection}(f) := \varepsilon : B \rightarrow C$ such that
\[
f \cdot \varepsilon = 0_{A,C}
\]
\item A dependent function $\mathrm{CokernelColift}(f,-) := ( \varepsilon \backslash -)$ mapping a morphism $\tau : B \rightarrow T$ with
$f \tau  = 0_{A,T}$ to a morphism $\mathrm{CokernelColift}(f,\tau) := ( \varepsilon \backslash \tau) : C \rightarrow T$ such that
\[
\tau =\label{eq:cokernel_colift} \varepsilon \cdot (\varepsilon \backslash \tau).
\]
\item For any other dependent function $v$ satisfying \eqref{eq:cokernel_colift}, $v = ( \varepsilon \backslash - )$.
\end{enumerate}
\[
\begin{tikzcd}
A \arrow[r, "\alpha"] & B \arrow[rrr, "\mathrm{CokernelProjection}(\alpha)", two heads] \arrow[rrrd, "\tau"', bend right] &  &  & C \arrow[d, "{\mathrm{CokernelColift}(\alpha,\tau)}", dashed] \\
                      &                                                                                                   &  &  & T                                                            
\end{tikzcd}
\]
\end{definition}

\begin{definition}[Lift and colift]
\begin{itemize}
\item For objects $A, K, T \in \kmat_{0}$ and morphisms $\iota : K \rightarrow A, \tau : T \rightarrow A$ we have a lift of $\tau$ along $\iota$
given by a morphism $u : T \rightarrow K$ such that $u \iota = \tau$.
\[
\begin{tikzcd}
                                              & K \arrow[rd, "\iota"] &   \\
T \arrow[rr, "\tau"'] \arrow[ru, "u", dashed] &                       & A
\end{tikzcd}
\]
\item For objects $A,C,T \in \kmat_{0}$ and morphisms $\varepsilon : A \rightarrow C, \tau : A \rightarrow T$ we have a colift of $\tau$ along
$\varepsilon$ given by a morphism $u : C \rightarrow T$ such that $\varepsilon u = \tau$.
\[
\begin{tikzcd}
A \arrow[rr, "\tau"] \arrow[rd, "\varepsilon"'] &                            & T \\
                                                & C \arrow[ru, "u"', dashed] &  
\end{tikzcd}
\]
\end{itemize}
\end{definition}

With these limits we get our next categorical doctrine:

\begin{definition}{(Pre-Abelian category)}
A \ul{pre-abelian category} consists of the following data:
\begin{enumerate}
\item An additive category $\mathcal{C}$.
\item A dependent function mapping every morphism $f : A \rightarrow B$ for $A, B \in \mathcal{C}_{0}$ to a
kernel of $f$.
\item A dependent function mapping every morphism $f : A \rightarrow B$ for $A, B \in \mathcal{C}_{0}$ to a
cokernel of $f$.
\end{enumerate}
\end{definition}

\subsection{Abelian categories}



\subsection{Categorical doctrines}





\begin{definition}[Abelian category]\label{def:abelian_category}
An \ul{abelian category} is
\begin{itemize}
\item a pre-abelian category $\mathcal{A}$ where
\item every monomorphism $\iota$ is a kernel-embedding of some kernel object $K$ and
\item every epimorphism $\varepsilon$ is a cokernel-projection of some cokernel object $C$.
\end{itemize}
\end{definition}

\begin{definition}{(Abelian category)}\endnote{(From \cite{[context]}, appendix E.5, Def. E.5.1)}
A category $\mathcal{C}$ is \ul{abelian} if
\begin{itemize}
\item it has a zero object $0$,
\item it has all \ul{binary products} and \ul{binary coproducts},
\item it has all \ul{kernels} and \ul{cokernels}, defined repsectively to be the \ul{equalizer} and
\ul{coequalizer} of a map $f : A \rightarrow B$ with the zero map $A \rightarrow 0 \rightarrow B$, and
\item all monomorphisms and epimorphisms arise as kernels or cokernels, respectively.
\end{itemize}
\end{definition}






\begin{example}{(The matrix category $\kmat$ over a commutative ring $\Bbbk$)}\label{ex:kmat1}
\begin{itemize}
\item Objects are natural numbers $\kmat_{0} = \mathbb{N} = \mathbb{N}_{0} = \{0,1,2,\dots\}$
\item Morphisms $\kmat_{1} \ni (m \rightarrow n)$ are $m \times n$ matrices over $\Bbbk$.
We write the set of morphisms between $m$ and $n$, as $\Bbbk^{m\times n} := \textup{Hom}_{\kmat}(m,n)$. Identity morphisms are the
identity matrices.
\item Composition is matrix multiplication (associative).
\item It is a skeletal category, i.e. $m$ is isomorphic to $n \Rightarrow m = n$. Only quadratic matrices ($m = n$) can be
isomorphisms.
\end{itemize}
In this category, the number $0$ is \ul{the} zero object.\\
A zero matrix (zero morphism) is a matrix factoring through the zero object $0$.\\
\begin{minipage}{.2\textwidth}\phantom{ }\end{minipage}
\begin{minipage}{.25\textwidth}
$\Bbbk^{m\times n} \ni A = 0_{m,n}$
\end{minipage}
\begin{minipage}{.08\textwidth}
$\Longleftrightarrow$
\end{minipage}
\begin{minipage}{.32\textwidth}
\begin{tikzcd}
m \arrow[rr, "A"] \arrow[rd, "(m \times 0)"'] &                               & n \\
                                              & 0 \arrow[ru, "(0 \times n)"'] &  
\end{tikzcd}\\
$\Rightarrow A = (m \times 0) \cdot (0 \times n)$.
\end{minipage}
\begin{minipage}{.15\textwidth}\phantom{ }\end{minipage}\\

\noindent The matrices $(m \times 0)$ and $(0 \times n)$ have zero columns or zero rows respectively, but it is
important to note that for each $m \in \kmat_{0}$ there is exactly one such matrix $(m \times 0)$ and $(0 \times m)$
(that's what initial and terminal object means), and for different $m$, these morphisms are different.
\end{example}

\begin{example}{($\kmat$ is an Ab-category)}
For two natural numbers $m,n \in {\kmat}_{0} = \mathbb{N} = \mathbb{N}_{0}$, the set of morphisms with source $m$ and target $n$ is
$\Bbbk^{m\times n}$, the set of $m \times n$-matrices. This is an abelian group:
\begin{itemize}
\item The neutral element of the addition is the $m \times n$ zero matrix $0_{m,n}$.
\item Addition of matrices is associative and commutative.
\end{itemize}
Composition of matrices is defined as matrix multiplication, which is bilinear, i.e. satisfies the distributive laws \eqref{eq:dist1} and \eqref{eq:dist2}.
\end{example}

\begin{example}[$\kmat$ is an additive category]\label{ex:kmat_additive}
Let for $I = \{1,\dots,N\},$ the set $\{n_{1},\dots,n_{N}\}$ be a family of objects in $\kmat_{0}$. Their direct sum is
\begin{itemize}
\item the object $n = \sum_{i=1}^{N} n_{i}$
\item For $i \in I$ we have as identity morphism $1_{n_{i}}$ of the object $n_{i}$ the $n_{i} \times n_{i}$ identity matrix.\\
The projection $\pi_{i} : n \rightarrow n_{i}$ is an $n \times n_{i}$ matrix that is a block matrix of $0_{n_{-i},n_{i}}$ and $1_{n_{i}}$.
\begin{align}
\pi_{i} = \label{eq:projection_direct_sum_matrix}
\begin{pmatrix}
0_{n_{1},\,n_{i}} \\
0_{n_{2},\,n_{i}} \\
\vdots \\
0_{n_{i-1},\,n_{i}} \\
1_{n_{i}} \\
0_{n_{i+1},\,n_{i}} \\
\vdots \\
0_{n_{N},\,n_{i}}
\end{pmatrix}
=
\begin{pmatrix}
0_{\sum\limits_{j=1}^{i-1} n_{j},\,n_{i}} \\
1_{n_{i}} \\
0_{\sum\limits_{j=i+1}^{N} n_{j},\,n_{i}}
\end{pmatrix}
\end{align}
\item The coprojection $\iota_{i} : n_{i} \rightarrow n$ is the transposed matrix $\iota_{i} = \pi_{i}^{T}$, i.e. an $n_{i} \times n$ block matrix
\begin{align}
\iota_{i} = \label{eq:coprojection_direct_sum_matrix}
\begin{pmatrix}
0_{n_{i},\,\sum\limits_{j=1}^{i-1} n_{j}} & 1_{n_{i}} & 0_{n_{i},\,\sum\limits_{j=i+1}^{N} n_{j}}
\end{pmatrix}
\end{align}
\item For a family $\tau = (\tau_{i} : t \rightarrow n_{i})_{i\in I}$ we have the morphism $u_{\text{in}}(\tau)$ which is a $t \times n$ block matrix of
the $\tau_{i}$:
\begin{align}
u_{\text{in}}(\tau) = \label{eq:u_in_direct_sum_matrix}
\begin{pmatrix}
\tau_{1} & \cdots & \tau_{N}
\end{pmatrix}
\end{align}
with $u_{\text{in}}(\tau) \pi_{i} = \tau_{i}$.
\item For a family $\tau = (\tau_{i} : n_{i} \rightarrow t)_{i \in I}$ we have the morphism $u_{\text{out}}(\tau)$ which is an $n \times t$ block matrix
of the $\tau_{i}$:
\begin{align}
u_{\text{out}}(\tau) = \label{eq:u_out_direct_sum_matrix}
\begin{pmatrix}
\tau_{1} \\
\vdots \\
\tau_{N}
\end{pmatrix}
\end{align}
with $\iota_{i} u_{\text{out}}(\tau) = \tau_{i}$.
\end{itemize}
One can easily verify the conditions for $\pi$, $\iota$, $u_{\text{in}}$ and $u_{\text{out}}$ in Definitions \ref{def:biproduct} and \ref{def:direct_sum}.
\end{example}

\begin{example}[Block-Diagonal matrices]\phantom{}\label{ex:block_diagonal_matrix}\\
In a situation with an index set $I = \{1,\dots,N\}$, two families of objects $\{m_{i}\}_{i\in I}, \{n_{i}\}_{i\in I}$ and a family of
morphisms $\{a_{i} : m_{i} \rightarrow n_{i}\}$ we have the two direct sums
\begin{align}
m &:= \bigoplus_{i\in I} m_{i}, &&(\pi_{i})_{m} : m \rightarrow m_{i}, &&(\iota_{i})_{m} : m_{i} \rightarrow m, \\
n &:= \bigoplus_{i\in I} n_{i}, &&(\pi_{i})_{n} : n \rightarrow n_{i}, &&(\iota_{i})_{n} : n_{i} \rightarrow n.
\end{align}
This situation is displayed in the following diagram
\[
\begin{tikzcd}
m \arrow[dd, "(\pi_{i})_{m}", shift left=2]                           &  & n \arrow[dd, "(\pi_{i})_{n}", shift left=2]       \\
                                                                      &  &                                                   \\
m_{i} \arrow[uu, "(\iota_{i})_{m}", shift left=2] \arrow[rr, "a_{i}"] &  & n_{i} \arrow[uu, "(\iota_{i})_{n}", shift left=2]
\end{tikzcd}
\]
The morphism $a : m \rightarrow n$ defined as
\begin{align}
a = \sum_{i \in I} (\pi_{i})_{m} a_{i} (\iota_{i})_{n}
\end{align}
satisfies
\begin{align}
(\iota_{i})_{m} a (\pi_{i})_{n} &= a_{i}
\end{align}
This an be interpreted in two ways:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item For the family $\iota_{m} a := \{ (\iota_{i})_{m} a : m_{i} \rightarrow n \}$ of morphisms with same target $n$, we have the morphism
$u_{\text{out}}(\iota_{m} a) : m \rightarrow n$ such that $(\iota_{i})_{m} u_{\text{out}}(\iota_{m} a) = (\iota_{i})_{m} a$, and
\item For the family $a \pi_{n} := \{ a (\pi_{i})_{n} : m \rightarrow n_{i} \}$ of morphisms with same source $m$, we have the morphism
$u_{\text{in}}(a \pi_{n}) : m \rightarrow n$ such that $u_{\text{in}}(a \pi_{n}) (\pi_{i})_{n} = a (\pi_{i})_{n}$.
\end{enumerate}
So we have
\begin{align}
(\iota_{i})_{m} u_{\text{out}}(\iota_{m} a) (\pi_{i})_{n} = a_{i} = (\iota_{i})_{m} u_{\text{in}}(a \pi_{n}) (\pi_{i})_{n}
\end{align}
\end{example}


\begin{example}[A number example for the direct sum in $\kmat$]
The direct sum of $m = 3, n = 5 \in \kmat_{0}$ is the object $m+n = 8 \in \kmat_{0}$ together with the following morphisms:
\begin{align*}
\pi_{1} = \begin{pmatrix}
1 \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand 1 \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand 1 \\
\cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot
\end{pmatrix},
\pi_{2} = \begin{pmatrix}
\cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
1 \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand 1 \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand 1 \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \ampersand 1 \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand 1
\end{pmatrix}, 
\begin{array}{rr}
\iota_{1} &= \begin{pmatrix}
1 \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand 1 \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand 1 \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot
\end{pmatrix} \\
\\
\iota_{2} &= \begin{pmatrix}
\cdot \ampersand \cdot \ampersand \cdot \ampersand 1 \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand 1 \ampersand \cdot \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand 1 \ampersand \cdot \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand 1 \ampersand \cdot \\
\cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand \cdot \ampersand 1
\end{pmatrix}
\end{array}
\end{align*}\\
\noindent One can easily verify that $\pi_{1} \iota_{1} + \pi_{2} \iota_{2} = 1_{(3+5)} = 1_{8}$ and e.g. $\iota_{1} \pi_{2} = 0_{3,5}$.\\

\noindent \begin{minipage}[t]{.5\textwidth}
For $t = 4$, $\tau = (\tau_{1}, \tau_{2})$ defined as
\begin{align*}
\tau_{1} = \begin{pmatrix}
1 \ampersand 2 \ampersand 2 \\
4 \ampersand 3 \ampersand 1 \\
\cdot \ampersand 1 \ampersand \cdot \\
1 \ampersand 2 \ampersand 1
\end{pmatrix},
\tau_{2} = \begin{pmatrix}
1 \ampersand 1 \ampersand 2 \ampersand 2 \ampersand 3 \\
3 \ampersand 4 \ampersand 4 \ampersand 5 \ampersand 5 \\
6 \ampersand 6 \ampersand 7 \ampersand 7 \ampersand 8 \\
8 \ampersand 9 \ampersand 9 \ampersand 4 \ampersand 4
\end{pmatrix}
\end{align*}
we get the matrix
\begin{align*}
u_{\text{in}}(\tau) = \begin{pmatrix}
1 \ampersand 2 \ampersand 2 \ampersand 1 \ampersand 1 \ampersand 2 \ampersand 2 \ampersand 3 \\
4 \ampersand 3 \ampersand 1 \ampersand 3 \ampersand 4 \ampersand 4 \ampersand 5 \ampersand 5 \\
\cdot \ampersand 1 \ampersand \cdot \ampersand 6 \ampersand 6 \ampersand 7 \ampersand 7 \ampersand 8 \\
1 \ampersand 2 \ampersand 1 \ampersand 8 \ampersand 9 \ampersand 9 \ampersand 4 \ampersand 4
\end{pmatrix}
\end{align*}
\end{minipage}
\begin{minipage}[t]{.5\textwidth}
and for $r = 2$, $\rho = (\rho_{1}, \rho_{2})$ we get the matrix
\begin{align*}
\begin{array}{rr}
\rho_{1} &= \begin{pmatrix}
\cdot \ampersand 1 \\
1 \ampersand 1 \\
2 \ampersand 2
\end{pmatrix} \\
\\
\rho_{2} &= \begin{pmatrix}
4 \ampersand 5 \\
7 \ampersand \cdot \\
\cdot \ampersand 5 \\
\cdot \ampersand \cdot \\
1 \ampersand 1
\end{pmatrix}
\end{array}
u_{\text{out}}(\rho) = \begin{pmatrix}
\cdot \ampersand 1 \\
1 \ampersand 1 \\
2 \ampersand 2 \\
4 \ampersand 5 \\
7 \ampersand \cdot \\
\cdot \ampersand 5 \\
\cdot \ampersand \cdot \\
1 \ampersand 1
\end{pmatrix}
\end{align*}
\end{minipage}\\

\noindent One can easily verify that e.g. $\tau_{1} = u_{\mathrm{in}}(\tau) \pi_{1}$ and $\rho_{2} = \iota_{2} u_{\mathrm{out}}(\rho)$.
\end{example}



\begin{example}[$\kmat$ is a pre-abelian category]
Construction 2.14 in \cite{[Posur]} defines four algorithms deduced from Gaussian elimination
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item SyzygiesOfRows
\item SyzygiesOfColumns
\item LeftDivide
\item RightDivide
\end{enumerate}
from which we can build kernels and cokernels in the matrix category:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item Let $A \in \Bbbk^{m\times n}$, then we define:
\begin{enumerate}
\renewcommand{\labelenumii}{(\alph{enumii})}
\item $\mathrm{ker}(A) :=\,\text{ number of rows of }\,\mathrm{SyzygiesOfRows}(A)$,
\item $\mathrm{KernelEmbedding}(A) := \mathrm{SyzygiesOfRows}(A) \in \mathrm{Hom}_{\kmat}(\mathrm{ker}(A), m)$,
\item for any $T \in \Bbbk^{o\times m}$ such that $TA = 0$, set the universal morphism
\[
\mathrm{KernelLift}(A,T) := \mathrm{RightDivide}(T, \mathrm{SyzygiesOfRows}(A)).
\]
\end{enumerate}
\item Let $A \in \Bbbk^{m\times n}$, then we define:
\begin{enumerate}
\renewcommand{\labelenumii}{(\alph{enumii})}
\item $\mathrm{coker}(A) :=\,\text{ number of columns of }\,\mathrm{SyzygiesOfColumns}(A)$,
\item $\mathrm{CokernelProjection}(A) := \mathrm{SyzygiesOfColumns}(A) \in \mathrm{Hom}_{\kmat}(n, \mathrm{coker}(A))$,
\item for any $T \in \Bbbk^{n\times o}$ such that $AT = 0$, set the universal morphism
\[
\mathrm{CokernelColift}(A,T) := \mathrm{LeftDivide}(\mathrm{SyzygiesOfColumns}(A), T).
\]
\end{enumerate}
\end{enumerate}
With these constructions, $\kmat$ becomes a pre-abelian category.
\end{example}


\subsection{Kernel and cokernel; image and coimage}




%%% functors between abelian categories.

\begin{theorem}
The functor category has all limits, colimits and bilimits which exist in the target category.
\end{theorem}

Instead of proving this in general, we prove this as part of \ref{thm:functor_category_abelian} for the direct sum, which is a very special bilimit.

