% mainfile: ../main.tex

\subsection{Limit and colimit of a functor}

\begin{definition}{(Source of a functor)}
Let $D : \mathbf{I} \rightarrow \mathcal{C}$ be a functor. A \ul{source} of $D$ consists of the following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $S \in \mathcal{C}$.
\item A dependent function $s$ mapping an object $i \in \mathbf{I}_{0}$ to a morphism
$s(i) : S \rightarrow D(i)$ such that for all $i, j \in \mathbf{I}, \iota : i \rightarrow j$, we have $D(\iota) \cdot s(i) = s(j)$.
\end{enumerate}
\end{definition}

\begin{definition}{(Limit and colimit of a functor)}\label{def:limit}
Let $D : \mathbf{I} \rightarrow \mathcal{C}$ be a functor. A \ul{limit} of $D$ consists of the
following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item A source of $D$ given by the data $(\mathrm{lim}\, D, (\lambda(i) : \mathrm{lim}\, D \rightarrow D(i))_{i\in\mathbf{I}_{0}})$.
\item A dependent function $u$, called the \ul{lift}, mapping every source $\tau = (T, (\tau(i) : T \rightarrow D(i))_{i \in \mathbf{I}})$ to a
morphism $u(\tau) : T \rightarrow \mathrm{lim}\, D$ such that $\lambda(i) \cdot u(\tau) = \tau(i)$ for all $i \in \mathbf{I}$.\label{itm:2}
\item For any other dependent function $v$ satisfying (\ref{itm:2}), we have $u = v$, i.e. $u$ is unique with that property.
\end{enumerate}
A \ul{colimit} of $D$ is a limit of $D' : \mathbf{I} \rightarrow \mathcal{C}^{\mathrm{op}}$.
\end{definition}

\begin{definition}[Limits of type \textbf{I}]
Let $\mathbf{I}$ be a category. We say a category $\mathcal{C}$ \ul{has limits of type} $\mathbf{I}$ if it is
equipped with a dependent function $\lambda$ mapping a functor $D : \mathbf{I} \rightarrow \mathcal{C}$ to a limit
$(\mathrm{lim}\, D, \lambda_{D}, u_{D})$ of $D$.
We say $\mathcal{C}$ \ul{has colimits of type} $\mathbf{I}$ if $\mathcal{C}^{\mathrm{op}}$ has limits of that type.
\end{definition}

\begin{example}\label{ex:limits}
Depending on \textbf{I} some limits and colimits have special names:
\begin{center}
\begin{tabular}{c|c|c}
generating quiver of $\mathbf{I}$ & limit & colimit \\
\hline
$\emptyset$ & terminal object & initial object \\
$\cdot \text{\phantom{$\rightarrow$}} \cdot$ & binary product & binary coproduct \\
$\cdot \rightarrow \cdot \leftarrow \cdot$ & binary pullback & - \\
$\cdot \leftarrow \cdot \rightarrow \cdot$  & - & binary pushout \\
$ \cdot \rightrightarrows \cdot$ & binary equalizer & binary coequalizer
\end{tabular}
\end{center}
\end{example}

A category having or lacking limits and colimits of a certain type formalizes the notion of what one can or cannot \textit{do} in a category.
Since we are \textit{doing} constructive category theory, this all boils down to which limits and colimits we can \ul{compute}, i.e. for which we
have algorithms, and what needs to be true for the category in order for those algorithms to terminate with a correct output.
Just as in algebra words like ``field'' or ``ring'' or ``abelian group'' are established names and adjectives for sets with additional structure,
in category theory we give special names for categories which have certain limits. This is summarized under the vaguely defined
notion of ``doctrine''.

\begin{definition}[Categorical doctrine]
We say a category is of a certain \ul{categorical doctrine}, if it has all limits and colimits of a specified set of types.
In this thesis, we will define hierarchies of categorical doctrines as sets of algorithms that compute the (co-)limits in that category.
But there are other categorical doctrines that don't directly translate into algorithms computing (co-)limits.
\end{definition}

To give an example, recall the definition of isomorphism

\begin{definition}[Isomorphism]
An \ul{isomorphism} in a category $\mathcal{C}$ is a morphism $f : X \rightarrow Y$ for which there exists a morphism
$g : Y \rightarrow X$ so that $fg = 1_{X}$ and $gf = 1_{Y}$. The objects $X$ and $Y$ are \ul{isomorphic} whenever there
exists an isomorphism between $X$ and $Y$, in which case one writes $X \cong Y$.
\end{definition}

\begin{definition}[Skeletal category, skeleton]
A category $\mathcal{C}$ is \ul{skeletal} if $A \cong A'$ implies $A = A'$ for all objects $A, A' \in \mathcal{C}_{0}$.
We define a \ul{skeleton} S$\mathcal{C}$ to be a skeletal subcategory of $\mathcal{C}$ whose inclusion functor exhibits it
as equivalent to $\mathcal{C}$.
\end{definition}

\begin{example}[$\Bbbk\textnormal{-}\mathbf{vec}^{\text{fd}}$ is not skeletal]
In the category $\Bbbk\textnormal{-}\mathbf{vec}^{\text{fd}}$ of finite-dimensional vector spaces over a field $\Bbbk$,
a tuple $[a_{0},a_{1},a_{2}]$ can be interpreted as coordinates $(a_{0},a_{1},a_{2})$ in $3$D space, i.e. an element of $\Bbbk^{3}$, or
as the coefficients of a polynomial $a_{0} + a_{1}x + a_{2}x^{2} + x^{3}\Bbbk[x] \in \Bbbk[x] \backslash (x^{3})$ of degree
$\leq 2$. Both $3$-dimensional vector spaces are isomorphic $\Bbbk[x] \backslash (x^{3}) \cong \Bbbk^{3}$ but not equal.
\end{example}

An example for a categorical doctrine could therefore be $\mathtt{IsSkeletal}$ which in itself doesn't yield any algorithms,
but the assumption that a category is skeletal could simplify computation in those categories tremendously or even make computation
possible in the first place.

\subsection{The categorical doctrines of abelian categories}

In this subsection, we give explicit definitions for the (co-)limits in \ref{ex:limits} and define the
doctrines for our categories with such (co-)limits. The doctrine we are interested in is that of an abelian category with
enough projectives and enough injectives. For now we will describe the doctrines up to and including abelian categories, and
leave projective and injective objects for section 5. In section 3 we will work on the doctrines of explicitly cyclic finite concrete
categories and leading up to $\Bbbk$-Algebroids or $\Bbbk$-linear categories.

\subsubsection{Ab-categories}
We are starting simple with Ab-categories. All we need is an abelian group structure on the hom-set between two objects.
Since this involves neutral elements of addition, we are skipping ahead and define the zero object and from it the zero morphism.

\begin{remark}[Terminal object, initial object, zero object]\label{def:init_term_zero_object}
The limit / colimit of $\emptyset$.
\renewcommand{\labelenumi}{(\theenumi)}
\begin{enumerate}
\item A \ul{terminal object} $T$ in a category $\mathcal{C}$ is an object such that $\textup{Hom}_{\mathcal{C}}(-,T)$ is a singleton.
\item An \ul{initial object} $I$ in a category $\mathcal{C}$ is an object such that $\textup{Hom}_{\mathcal{C}}(I,-)$ is a singleton.
\item An object $Z$ or $0$ is a \ul{zero object} if it is both initial and terminal.
\end{enumerate}
\end{remark}

\begin{definition}[Zero morphism]\label{def:zero_morphism}\phantom{}\\
A \ul{zero morphism} in a category with a zero object $0$ is a morphism factoring over $0$, i.e. $\varphi : M \rightarrow N$ is called a zero
morphism, if\\
\begin{minipage}{.35\textwidth}
\begin{tikzcd}
M \arrow[rr, "\varphi"] \arrow[rd, "\varphi_{1}"] &                              & N \\
                                                  & 0 \arrow[ru, "\varphi_{2}"'] &  
\end{tikzcd}
\end{minipage}
\begin{minipage}{.65\textwidth}
$\exists \varphi_{1} : M \rightarrow 0, \varphi_{2} : 0 \rightarrow N$\\
such that $\varphi = \varphi_{1}\varphi_{2}$.
\end{minipage}
Since the zero object $0$ is both initial and terminal, a zero morphism is uniquely defined by its source and target, thus we can
talk about \textit{the} zero morphism from $M$ to $N$, which we denote by $0_{M,N}$.\endnote{We could define the zero morphism without
the zero object, just as the neutral element of the abelian group $\mathrm{Hom}_{\mathcal{C}}(M,N)$. Therefore $\mathtt{ZeroMorphism}(M,N)$
is needed in the doctrine of $\mathtt{IsAbCategory}$, but the $\mathtt{ZeroObject}$ is not. Eventually at additive categories the
zero object arrises naturally as the direct sum of $\emptyset$, which is why $\mathtt{ZeroObject}$ is listed only there.}
\end{definition}

\begin{definition}[Ab-category]
An \ul{Ab-category} (also called \ul{pre-additive category}) is a category in which all homomorphism sets are abelian groups,
and composition distributes over addition.\\
In other words, a category $\mathcal{C}$ is an Ab-category if for every pair of objects $M,N \in \mathcal{C}_{0}$,
$( \textup{Hom}_{\mathcal{C}}(M,N), + )$ is an abelian group (with the zero morphism $0_{M,N}$ as the neutral element),
and for all morphisms $\gamma, \delta \in \mathrm{Hom}_{\mathcal{C}}(M,N),
\alpha, \beta \in \textup{Hom}_{\mathcal{C}}(N,L)$
\begin{align}
(\gamma + \delta)\alpha &=\label{eq:dist1} \gamma\alpha + \delta\alpha \textup{ and }\\
\gamma(\alpha+\beta) &=\label{eq:dist2} \gamma\alpha + \gamma\beta.
\end{align}
Note that every hom-set has its own unique zero morphism. E.g. in $\kmat$ the $2 \times 3$ zero-matrix
$0_{2,3} \in \textup{Hom}_{\kmat}(2,3)$ is different from the $4 \times 4$ zero-matrix $0_{4,4} \in \textup{Hom}_{\kmat}(4,4)$.
\end{definition}

\begin{doctrine}[Ab-category]\label{doc:ab-category}
The doctrine $\mathtt{IsAbCategory}$ therefore involves algorithms for
\begin{itemize}
\item $\mathtt{AdditionForMorphisms}$,
\item $\mathtt{ZeroMorphism}$,
\item $\mathtt{IsZeroForMorphisms}$,
\item $\mathtt{SubtractionForMorphisms}$,
\item $\mathtt{AdditiveInverseForMorphisms}$
\end{itemize}
\end{doctrine}

\begin{definition}[Ab-functor]
A functor between Ab-categories is called an \ul{Ab-functor} if in the functor definition \ref{def:functor} the function $Ff$ for each
morphism $f$ is a homomorphism of abelian groups, i.e. $F(f+g) = Ff + Fg$.
\end{definition}

\subsubsection{Additive categories}
The definition of the binary operation $+$ in a pre-additive category came as arbitrary outside data and could be defined
in multiple ways. A category with the following limits is additive in at most one way, warrenting the name additive category.

\begin{definition}[Product, coproduct]\label{def:prod_coprod}
The limit / colimit of a set of objects $\,\cdot \text{\phantom{$\rightarrow$}} \cdot$\\
Let $I$ be an index set and $\{A_{i}\}_{i\in I}$ a family of objects in a category $\mathcal{C}$.
\setlist[description]{font=\normalfont}
\begin{description}
\item[(prod)] The \ul{product} of the family $\{A_{i}\}_{i\in I}$ is an object $\invamalg A_{i}$ together with a family of morphisms
\[
\{ \pi_{i} : \invamalg A_{i} \rightarrow A_{i} \}
\]
called \ul{projections}, such that the following universal property is satisfied:\\
For any object $M \in \mathcal{C}_{0}$ and any family $\{ \varphi_{i} : M \rightarrow A_{i} \}_{i\in I}$ of morphisms, there exists
a unique morphism $\varphi : M \rightarrow \invamalg A_{i}$ called the \ul{product morphism} such that
\[
\varphi \pi_{i} = \varphi_{i} \, \forall i \in I.
\]
\begin{tikzcd}
                                                                                                                            &  &                                                          & A_{1} \\
M \arrow[rrru, "\varphi_{1}", bend left] \arrow[rrrd, "\varphi_{2}"', bend right] \arrow[rr, "\exists^{1} \varphi", dashed] &  & A_{1}\invamalg A_{2} \arrow[ru, "\pi_{1}"] \arrow[rd, "\pi_2"] &       \\
                                                                                                                            &  &                                                          & A_{2}
\end{tikzcd}
\item[(coprod)] The dual notion to product is the \ul{coproduct} of the family $\{A_{i}\}_{i\in I}$, that is an object $\amalg A_{i}$ together with
a family of morphisms
\[
\{ \iota_{i} : A_{i} \rightarrow \amalg A_{i} \}
\]
called \ul{coprojections} or sometimes \ul{injections}, \ul{inclusions} or \ul{embeddings}, such that the following universal property is satisfied:\\
For any object $M \in \mathcal{C}$ and any family $\{ \psi_{i} : A_{i} \rightarrow M \}$ of morphisms, there exists a unique
morphism $\psi : \amalg A_{i} \rightarrow M$ called the \ul{coproduct morphism} such that
\[
\iota_{i} \psi = \psi_{i} \, \forall i \in I.
\]
\begin{tikzcd}
  &  &                                                           & A_{1} \arrow[llld, "\psi_{1}"', bend right] \arrow[ld, "\iota_{1}"'] \\
M &  & A_{1}\amalg A_{2} \arrow[ll, "\exists^{1} \psi"', dashed] &                                                                      \\
  &  &                                                           & A_{2} \arrow[lllu, "\psi_{2}", bend left] \arrow[lu, "\iota_2"]     
\end{tikzcd}
\end{description}
\end{definition}

\begin{definition}[Biproduct]\label{def:biproduct}
Let $I$ be an index set and $\{S_{i}\}_{i\in I}$ a family of objects in a category $\mathcal{C}$.
A \ul{biproduct} is a product and a coproduct simultaneously, i.e. consists of the following data:
\begin{itemize}
\item an object $S \in \mathcal{C}_{0}$,
\item a family of morphisms $\pi = \{ \pi_{i} : S \rightarrow S_{i} \}_{i\in I}$,
\item a family of morphisms $\iota = \{ \iota_{i} : S_{i} \rightarrow S \}_{i\in I}$,
\item a dependent function $u_{\text{in}}$ mapping every family $\tau = \{ \tau_{i} : T \rightarrow S_{i} \}_{i\in I}$ to a morphism
$u_{\text{in}}(\tau) : T \rightarrow S$ such that $u_{\text{in}}(\tau) \pi_{i} \sim \tau_{i}$ for all $i \in I$,
\item a dependent function $u_{\text{out}}$ mapping every family $\rho = \{ \rho_{i} : S_{i} \rightarrow R \}_{i\in I}$ to a morphism
$u_{\text{out}}(\rho) : S \rightarrow R$ such that $\iota_{i} u_{\text{out}}(\rho) \sim \rho_{i}$ for all $i \in I$,
\end{itemize}
\end{definition}

\begin{definition}{(Direct sum)}\label{def:direct_sum}
A \ul{direct sum} is a biproduct of objects in an Ab-category such that
\begin{itemize}
\item $\sum_{i\in I}  \pi_{i} \iota_{i} \sim 1_{S}$,
\item $ \iota_{i} \pi_{j} \sim \delta_{i, j} =  \begin{cases}
            1_{S_{i}} & \text{ if } i = j  \\
            0_{ij} & \text{ if } i \neq j
        \end{cases}$,
\end{itemize}
where $\delta_{i, j} \in \mathrm{Hom}(S_{i}, S_{j})$ is the identity if $i = j$, and the zero morphism $0_{ij} := 0_{S_{i}, S_{j}}$ otherwise.
\end{definition}

\begin{example}[The direct sum of $\emptyset$]
For the index set $I = \emptyset$ we get an empty family of objects in a category $\mathcal{C}$. Its direct sum is
\begin{itemize}
\item an object $Z \in \mathcal{C}_{0}$,
\item empty morphism sets $\pi$ and $\iota$,
\item a dependent function $u_{\text{in}}$ maps an empty collection $\tau$ of morphisms with same source $T$ to a unique
morphism $u_{\text{in}}(\tau) : T \rightarrow Z$.
\item a dependent function $u_{\text{out}}$ maps an empty collection $\rho$ of morphisms with same target $R$ to a unique
morphism $u_{\text{out}}(\rho) : Z \rightarrow R$.
\end{itemize}
The unique morphisms $T \rightarrow Z$ and $Z \rightarrow T$ for any object $T$ (the empty family $\tau$ imposing no further condition)
suggests that our object $Z = \mathrm{DirectSum}(\emptyset)$ is in fact the zero object from \ref{def:init_term_zero_object}, and the
unique morphisms are the unique zero morphisms in $\mathrm{Hom}(Z,T)$ and $\mathrm{Hom}(T,Z)$ from \ref{def:zero_morphism}.
\end{example}

\begin{definition}\label{def:additive_category}
An \ul{additive category} is a pre-additive category $\mathcal{C}$ together with a dependent function $\oplus^{\mathcal{C}}$ mapping
a finite set $I$ and a family $(A_{i})_{i\in I}$ of objects in $\mathcal{C}$ to a corresponding direct sum $(\oplus_{i\in I}^{\mathcal{C}} A_{i},
(\pi_{i})_{i\in I}, (\iota_{i})_{i\in I})$.
\end{definition}

\begin{remark}[Addition of morphisms]\label{rmk:addition_derived_from_direct_sum}
In an additive category the abelian group structure on $\mathrm{Hom}_{\mathcal{C}}(M,N)$ can be derived from the direct sum:
For $\rho_{1}, \rho_{2} \in \mathrm{Hom}_{\mathcal{C}}(M,N)$
\[
\rho_{1} + \rho_{2} = u_{\mathrm{in}}(1_{M},1_{M}) u_{\mathrm{out}}(\rho_{1},\rho_{2}) 
= u_{\mathrm{in}}(\rho_{1},\rho_{2}) u_{\mathrm{out}}(1_{N},1_{N})
\]
The above equation illustrates that an additive category is
pre-additive in at most one way, i.e. we don't have a choice how we define the abelian group structure on the hom-sets.
\endnote{This result is already implemented in \textsc{Cap} as a derivation of \texttt{AdditionForMorphisms} from the four morphisms
\texttt{UniversalMorphismIntoDirectSum}, \texttt{IdentityMorphism}, \texttt{UniversalMorphismFromDirectSum} and \texttt{PreCompose}.
See 
\url{https://github.com/homalg-project/CAP_project/blob/v2019.06.06/CAP/gap/DerivedMethods.gi\#L1024}}
\end{remark}

\begin{doctrine}[Additive category]
The doctrine $\mathtt{IsAdditiveCategory}$ therefore involves algorithms of $\mathtt{IsAbCategory}$ together with algorithms for
\begin{itemize}
 \item $\mathtt{ZeroObject}$,
 \item $\mathtt{UniversalMorphismFromZeroObject}$,
 \item $\mathtt{UniversalMorphismIntoZeroObject}$,
 \item $\mathtt{DirectSum}$,
 \item $\mathtt{ProjectionInFactorOfDirectSum}$,
 \item $\mathtt{InjectionOfCofactorOfDirectSum}$,
 \item $\mathtt{UniversalMorphismIntoDirectSum}$,
 \item $\mathtt{UniversalMorphismFromDirectSum}$
\end{itemize}
\end{doctrine}

\subsubsection{Pre-abelian categories}

TODO: (Some short introduction in subsubsection)
%The dashed arrow in the diagrams of last subsection carried the meaning of uniqueness in the sense of \ref{def:limit}(3).
%Throughout the thesis we will be using two other kinds of arrows $\hookrightarrow$ and $\twoheadrightarrow$ which we will define next.
%We encourage the reader to prove themselves the use of these arrows, i.e. that the indicated arrows are in fact a mono or an epi.

\begin{definition}[Monomorphism and epimorphism]
A morphism $f : A \rightarrow B$ in a category is
\begin{itemize}
\item a \ul{monomorphism} if for any parallel morphisms $h, k : Z \rightrightarrows A, hf = kf$ implies that
$h = k$
\item an \ul{epimorphism} if for any parallel morphisms $h, k : B \rightrightarrows C, fh = fk$ implies that
$h = k$.
\end{itemize}
We write $f : A \hookrightarrow B$ for a monomorphism and $f : A \twoheadrightarrow B$ for an epimorphism.
\endnote{We can define monomorphisms and epimorphisms in a different way which gives us an opportunity to use the limit of
$\cdot \rightarrow \cdot \leftarrow \cdot$ called \ul{pullback} and the colimit of $\cdot \leftarrow \cdot \rightarrow \cdot$ called \ul{pushout}. 
A morphism $f : A \rightarrow B$ is a monomorphism if and only if the pullback of $f$ and $f$ exists and is equal to $A$
(together with the identity maps $1_{A}$). Dually, a morphism $f : A \rightarrow B$ is an epimorphism if and only if the pushout of
$f$ and $f$ exists and is equal to $B$ (together with the identity maps $1_{B}$). Since we will not be using pullbacks and pushouts any further,
this definition was moved to the endnotes, and proving the equivalences is left as an exercise for the reader. For further reading
\url{https://qchu.wordpress.com/2012/09/29/monomorphisms-and-epimorphisms/}}
\end{definition}

\begin{definition}[binary equalizer]
The limit of two parallel morphisms $\,\cdot \rightrightarrows \cdot$\\
If it exists in a category $\mathcal{C}$, the \ul{equalizer} of two morphisms $f, g : A \rightrightarrows B \in \mathcal{C}_{1}$
consists of the data
\begin{itemize}
\item an object $E := \mathrm{Eq}(f,g) \in \mathcal{C}_{0}$
\item a morphism $\iota := E \hookrightarrow A$ such that pulled back to $E$, both morphisms are equal $\iota\,f = \iota\,g$:
\begin{align*}
&E \xrightarrow{\iota} A \xrightarrow{f} B \\
=\, &E \xrightarrow{\iota} A \xrightarrow{g} B
\end{align*}
\item a dependent function $u$ such that for any other morphism $\tau : T \rightarrow A$ with
\begin{align*}
&T \xrightarrow{\tau} A \xrightarrow{f} B \\
=\, &T \xrightarrow{\tau} A \xrightarrow{g} B
\end{align*}
we have a unique morphism $u( \tau ) : T \rightarrow E$ such that $u( \tau ) \iota = \tau$.
\[
\begin{tikzcd}
E \arrow[r, "\iota", hook]                              & A \arrow[r, "f", shift left] \arrow[r, "g"', shift right] & B \\
T \arrow[ru, "\tau"] \arrow[u, "u(\tau)", dashed] &                                                           &  
\end{tikzcd}
\]
\end{itemize}
The dual concept is that of a \ul{coequalizer}, which is the colimit of $\,\cdot \rightrightarrows \cdot$.
\end{definition}

The following definition is a special case of an equalizer where $g = 0_{A,B}$. We will write it all out explicitly with their
own names for objects and morphisms.

\begin{definition}[Kernel]
In an additive category $\mathcal{C}$, the \ul{kernel} of a morphism $f : A \rightarrow B \in \mathcal{C}_{1}$ is the equalizer
of $f$ and $0_{A,B}$, i.e. consists of the data
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $K = \mathrm{Ker}(f)$
\item A morphism $\mathrm{KernelEmbedding}(f) := \kappa : K \rightarrow A$ such that $\kappa\,f = \kappa\,0_{A,B} = 0_{K,B}$:
\begin{align*}
\begin{tikzcd}[
  ampersand replacement=\&,
  row sep=1em,
]
{\phantom{=\, }K} \arrow[r, "\kappa"]                 \& A \arrow[r, "f"] \& B \\
{=\, K} \arrow[r, "\kappa"]   \& A \arrow[r, "0_{A,B}"] \& B \\
{= \, K} \arrow[rr, "{0_{K,B}}"] \&                            \& B
\end{tikzcd}
\end{align*}
\item A dependent function $\mathrm{KernelLift}(f,-) := ( - /\kappa)$ mapping a morphism $\tau : T \rightarrow A$ with $\tau f = 0_{T,B}$ to a
morphism $\mathrm{KernelLift}(f,\tau) = (\tau / \kappa) : T \rightarrow K$ such that
\[
\tau =\label{eq:kernel_lift} (\tau / \kappa)\, \kappa.
\]
\item For any other dependent function $v$ satisfying \eqref{eq:kernel_lift}, $v = ( - / \kappa)$.
\end{enumerate}
\[
\begin{tikzcd}
K \arrow[r, "\kappa"]                            & A \arrow[r, "f"] & B \\
T \arrow[ru, "\tau"'] \arrow[u, "(\tau/\kappa)", dashed] &                  &  
\end{tikzcd}
\]
\end{definition}

\begin{definition}[Cokernel]
In an additive category $\mathcal{C}$, the \ul{cokernel} of a morphism $f : A \rightarrow B \in \mathcal{C}_{1}$ is the coequalizer of
$f$ and $0_{A,B}$, i.e. consists of the data
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $C = \mathrm{Coker}(f)$
\item A morphism $\mathrm{CokernelProjection}(f) := \varepsilon : B \rightarrow C$ such that $f\,\varepsilon = 0_{A,B}\,\varepsilon = 0_{A,C}$:
\begin{align*}
\begin{tikzcd}[
  ampersand replacement=\&,
  row sep=1em,
]
{\phantom{=\, }A} \arrow[r, "f"]                 \& B \arrow[r, "\varepsilon"] \& C \\
{=\, A} \arrow[r, "{0_{A,B}}"]   \& B \arrow[r, "\varepsilon"] \& C \\
{= \, A} \arrow[rr, "{0_{A,C}}"] \&                            \& C
\end{tikzcd}
\end{align*}
\item A dependent function $\mathrm{CokernelColift}(f,-) := ( \varepsilon \backslash -)$ mapping a morphism $\tau : B \rightarrow T$ with
$f \tau  = 0_{A,T}$ to a morphism $\mathrm{CokernelColift}(f,\tau) = ( \varepsilon \backslash \tau) : C \rightarrow T$ such that
\[
\tau =\label{eq:cokernel_colift} \varepsilon \, (\varepsilon \backslash \tau).
\]
\item For any other dependent function $v$ satisfying \eqref{eq:cokernel_colift}, $v = ( \varepsilon \backslash - )$.
\end{enumerate}
\[
\begin{tikzcd}
A \arrow[r, "f"] & B \arrow[r, "\varepsilon", two heads] \arrow[rd, "\tau"] & C \arrow[d, "(\varepsilon\backslash\tau)", dashed] \\
                 &                                                          & T                                                 
\end{tikzcd}
\]
\end{definition}

\begin{definition}[Image]
In an additive category $\mathcal{C}$ we define the \ul{image} of a morphism\\
$f : A \rightarrow B \in \mathcal{C}_{1}$ as the kernel of its cokernel:\\
\begin{minipage}{.06\textwidth} \phantom{} \end{minipage}
\begin{minipage}{.39\textwidth}
\[
\begin{tikzcd}[
  ampersand replacement=\&,
]
A \arrow[r, "f"] \arrow[d, "(f/\kappa_{\varepsilon})"', dashed]         \& B \arrow[r, "\varepsilon", shift left, two heads]
\arrow[r, "{0_{B,C}}"', shift right] \& C \\
K \arrow[ru, "\kappa_{\varepsilon}", hook]                                    \&                            \&   \\
T \arrow[u, "(\tau/\kappa_{\varepsilon})", dashed] \arrow[ruu, "\tau"'] \&                            \&  
\end{tikzcd}
\]
\end{minipage}
\begin{minipage}{.49\textwidth}
Since $\varepsilon$ is the cokernel projection of $f$, the morphism $f : A \rightarrow B$ with $f\,\varepsilon = 0_{A,C}$ plays the
same role as any $\tau : T \rightarrow B$ with $\tau\,\varepsilon = 0_{T,C}$ in that it factors over the kernel object $K$ in a
unique way: 
\[
f = (f/\kappa_{\varepsilon})\,\kappa_{\varepsilon}
\]
\end{minipage}
\begin{minipage}{.06\textwidth} \phantom{} \end{minipage}

Thus, the image is
\begin{itemize}
\item An object $\mathrm{Im}(f) := \mathrm{Ker}(\varepsilon)$ where $\varepsilon = \mathrm{CokernelProjection}(f)$,
\item A morphism $\mathrm{ImageEmbedding}(f) := \mathrm{KernelEmbedding}(\mathrm{CokernelProjection}(f))$
\end{itemize}
To differentiate the image of $f$ (which is a kernel, but not the kernel of $f$) from the kernel of $f$,
we are using $I$ for $\mathrm{Im}(f)$ and $\iota$ for $\mathrm{ImageEmbedding}(f)$.
\end{definition}

\begin{definition}[Coimage]
In an additive category $\mathcal{C}$ we define the \ul{coimage} of a morphism $f : A \rightarrow B \in \mathcal{C}_{1}$ as the 
cokernel of its kernel:\\
\begin{minipage}{.06\textwidth} \phantom{} \end{minipage}
\begin{minipage}{.39\textwidth}
\[
\begin{tikzcd}[
  ampersand replacement=\&,
]
K \arrow[r, "\kappa", hook, shift left] \arrow[r, "{0_{K,A}}"', shift right] \& A \arrow[r, "f"] \arrow[rd, "{\varepsilon_{\kappa}}", two heads] \arrow[rdd, "\tau"'] \& B                                                                                                   \\
                                                                             \&                                                                            \& C \arrow[u, "({\varepsilon_{\kappa}}\backslash f)"', dashed] \arrow[d, "({\varepsilon_{\kappa}}\backslash \tau)", dashed] \\
                                                                             \&                                                                            \& T                                                                                                  
\end{tikzcd}
\]
\end{minipage}
\begin{minipage}{.49\textwidth}
Since $\kappa$ is the kernel embedding of $f$, the morphism $f : A \rightarrow B$ with $\kappa\,f = 0_{K,B}$ plays the
same role as any $\tau : A \rightarrow T$ with $\kappa\,\tau = 0_{K,T}$ in that it factors over the cokernel object $C$ in a
unique way:
\[
f = \varepsilon_{\kappa}\,(\varepsilon_{\kappa}\backslash f)
\]
\end{minipage}
\begin{minipage}{.06\textwidth} \phantom{} \end{minipage}

Thus, the coimage is
\begin{itemize}
\item An object $\mathrm{Coim}(f) := \mathrm{Coker}(\kappa)$ where $\kappa = \mathrm{KernelEmbedding}(f)$,
\item A morphism $\varepsilon_{\kappa} := \mathrm{CoimageProjection}(f) := \mathrm{CokernelProjection}(\mathrm{KernelEmbedding}(f))$
\end{itemize}
Since it was reserved for cokernel, we are not using $C$ to denote the coimage object. In fact, in the doctrine of abelian
categories we will not need a distinct variable name for the coimage, which will be more clear in \ref{cor:kernel_cokernel_sequence}.
\end{definition}

\begin{definition}{(Pre-Abelian category)}
A \ul{pre-abelian category} consists of the following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An additive category $\mathcal{C}$.
\item A dependent function mapping every morphism $f : A \rightarrow B$ for $A, B \in \mathcal{C}_{0}$ to a
kernel of $f$.
\item A dependent function mapping every morphism $f : A \rightarrow B$ for $A, B \in \mathcal{C}_{0}$ to a
cokernel of $f$.
\end{enumerate}
\end{definition}

\begin{doctrine}[Pre-abelian category]
The doctrine $\mathtt{IsPreAbelianCategory}$ therefore involves algorithms of $\mathtt{IsAdditiveCategory}$ together with algorithms for
\begin{itemize}
\item $\mathtt{KernelObject}$,
\item $\mathtt{KernelEmbedding}$,
\item $\mathtt{KernelLift}$,
\item $\mathtt{CokernelObject}$,
\item $\mathtt{CokernelProjection}$,
\item $\mathtt{CokernelColift}$
\end{itemize}
\end{doctrine}

\newpage
\subsubsection{Abelian categories}

In categories with kernels and cokernels we can compute images and coimages together with an induced morphism
$\overline{\varphi} : \mathrm{Coim}(\varphi) \rightarrow \mathrm{Im}(\varphi)$. This morphism being an isomorphism
is one of the defining axioms of Abelian categories.

The kernel lift of the cokernel colift
$(\varepsilon_{\kappa}\backslash\varphi)/\kappa_{\varepsilon} : \mathrm{Coim}(\varphi) \rightarrow \mathrm{Im}(\varphi)$

\[
\begin{tikzcd}
\mathrm{Ker}(\varphi) \arrow[rd, "\kappa", hook] \arrow[rddd, "0"', bend right] \arrow[rrrd, "0", bend left] &                                                                                                                                                                                             &  &                                                                                               & \mathrm{Coker}(\varphi) \\
                                                                                                             & M \arrow[rrru, "0", bend left] \arrow[rr, "\varphi"] \arrow[dd, "\varepsilon_{\kappa}"', two heads]                                                                                         &  & N \arrow[ru, "\varepsilon", two heads]                                                        &                         \\
                                                                                                             &                                                                                                                                                                                             &  &                                                                                               &                         \\
                                                                                                             & \mathrm{Coim}(\varphi) \arrow[rruu, "(\varepsilon_{\kappa}\backslash \varphi)"'] \arrow[rr, "(\varepsilon_{\kappa}\backslash\varphi)/\kappa_{\varepsilon}"'] \arrow[rrruuu, "0", pos=.7, color=red, bend left] &  & \mathrm{Im}(\varphi) \arrow[uu, "\kappa_{\varepsilon}"', hook] \arrow[ruuu, "0"', bend right] &                        
\end{tikzcd}
\]

We want to prove that the composition
$(\varepsilon_{\kappa}\backslash\varphi) \varepsilon : \mathrm{Coim}(\varphi) \rightarrow \mathrm{Coker}(\varphi)$ is the zero morphism (as
indicated by the red arrow).
Assuming
\begin{align*}
&M \xrightarrow{\varphi} N \\
=\, &M \xrightarrow{\varepsilon_{\kappa}} \mathrm{Coim}(\varphi) \xrightarrow{(\varepsilon_{\kappa}\backslash\varphi)} N \\
=\, &M \xrightarrow{\varepsilon_{\kappa}} \mathrm{Coim}(\varphi) \xrightarrow{(\varepsilon_{\kappa}\backslash\varphi)/\kappa_{\varepsilon}}
\mathrm{Im}(\varphi) \xrightarrow{\kappa_{\varepsilon}} N,
\end{align*}
i.e. that both triangles and thus the square commute.
Then 

The cokernel colift of the kernel lift
$\varepsilon_{\kappa}\backslash(\varphi/\kappa_{\varepsilon}) : \mathrm{Coim}(\varphi) \rightarrow \mathrm{Im}(\varphi)$

\[
\begin{tikzcd}
\mathrm{Ker}(\varphi) \arrow[rd, "\kappa", hook] \arrow[rddd, "0"', bend right] \arrow[rrrd, "0", bend left] \arrow[rrrddd, "0", pos=.3, color=red, shift left=2, bend right] &                                                                                                                                                    &  &                                                                                               & \mathrm{Coker}(\varphi) \\
                                                                                                                                             & M \arrow[rrru, "0", bend left] \arrow[rr, "\varphi"] \arrow[dd, "\varepsilon_{\kappa}"', two heads] \arrow[rrdd, "(\varphi/\kappa_{\varepsilon})"] &  & N \arrow[ru, "\varepsilon", two heads]                                                        &                         \\
                                                                                                                                             &                                                                                                                                                    &  &                                                                                               &                         \\
                                                                                                                                             & \mathrm{Coim}(\varphi) \arrow[rr, "\varepsilon_{\kappa}\backslash(\varphi/\kappa_{\varepsilon})"']                                                 &  & \mathrm{Im}(\varphi) \arrow[uu, "\kappa_{\varepsilon}"', hook] \arrow[ruuu, "0"', bend right] &                        
\end{tikzcd}
\]






\begin{corollary}\label{cor:kernel_cokernel_sequence}
\[
\begin{tikzcd}
K \arrow[rd, "\kappa", hook] &                                                       &                             &                                        & C \\
                             & M \arrow[rr, "\varphi"] \arrow[rd, "\pi"', two heads] &                             & N \arrow[ru, "\varepsilon", two heads] &   \\
                             &                                                       & I \arrow[ru, "\iota", hook] &                                        &  
\end{tikzcd}
\]
\end{corollary}

\begin{definition}[Abelian category]\label{def:abelian_category}
An \ul{abelian category} is
\begin{itemize}
\item a pre-abelian category $\mathcal{C}$ where
\item every monomorphism $\kappa$ is a kernel-embedding of its cokernel-projection and
\item every epimorphism $\varepsilon$ is a cokernel-projection of  its kernel-embedding.
\end{itemize}
\end{definition}

The above definition, that we can regard
\begin{itemize}
\item every monomorphism $\kappa : K \hookrightarrow A$ as a kernel-embedding
of its cokernel-projection $\varepsilon_{\kappa} : A \twoheadrightarrow C$, with $K$ being the kernel object
$\mathrm{Ker}(\varepsilon_{\kappa})$,
\item and every epimorphism
$\varepsilon : B \twoheadrightarrow C$ as a cokernel-projection of its kernel-embedding $\kappa_{\varepsilon} : K \hookrightarrow B$,
with $C$ being the cokernel object $\mathrm{Coker}(\kappa_{\varepsilon})$
\end{itemize}
implies that we also have the third ingredient
for kernels and cokernels, namely the dependent functions
\begin{itemize}
\item kernel lift $(-/\kappa) : \underline{\phantom{T}} \rightarrow K$ mapping a morphism $\tau : T \rightarrow A$ with same
target $t(\tau) = t(\kappa) = A$ and same cokernel $\varepsilon_{\kappa} = \varepsilon_{\tau}$ (i.e. $\tau\varepsilon_{\kappa} = 0_{T,C}$)
as $\kappa$ to a unique kernel lift $(\tau / \kappa) : T \rightarrow K$
\[
\begin{tikzcd}
K \arrow[r, "\kappa", hook] \arrow[r, "{0_{K,A}}", bend left, shift left=2]                                & A \arrow[r, "\varepsilon_{\kappa}", two heads] \arrow[r, "\varepsilon_{\tau}"', two heads] & C \\
T \arrow[ru, "{0_{T,A}}"', bend right, shift right=2] \arrow[ru, "\tau"] \arrow[u, "(\tau/\kappa)", dashed] &                                                                                            &  
\end{tikzcd}
\]
\item cokernel colift $(\varepsilon \backslash - ) : C \rightarrow \underline{\phantom{T}}$ mapping a morphism $\tau : B \rightarrow T$ with
same source $s(\tau) = s(\varepsilon) = B$ and same kernel $\kappa_{\varepsilon} = \kappa_{\tau}$
(i.e. $\kappa_{\varepsilon}\tau = 0_{K,T}$)  as $\varepsilon$ to a unique cokernel
colift $(\varepsilon \backslash \tau) : C \rightarrow T$.
\[
\begin{tikzcd}
K \arrow[r, "\kappa_{\varepsilon}", hook] \arrow[r, "\kappa_{\tau}"', hook] & B \arrow[r, "\varepsilon", two heads] \arrow[r, "{0_{B,C}}", bend left, shift left=2] \arrow[rd, "\tau"] \arrow[rd, "{0_{B,T}}"', bend right, shift right=2] & C \arrow[d, "(\varepsilon\backslash\tau)", dashed] \\
                                                                            &                                                                                                                                                   & T                                                 
\end{tikzcd}
\]
\end{itemize}


\begin{definition}[Lift and colift] The limit of \\
Let $A, K, C, T \in \mathcal{C}_{0}$ be objects in a category $\mathcal{C}$.
\begin{itemize}
\item For two morphisms with the same target $\iota : K \rightarrow A, \tau : T \rightarrow A$ we call a morphism $u : T \rightarrow K$ a
\ul{lift of $\tau$ along $\iota$} if $u \iota = \tau$.
\[
\begin{tikzcd}
                                              & K \arrow[rd, "\iota"] &   \\
T \arrow[rr, "\tau"'] \arrow[ru, "u", dashed] &                       & A
\end{tikzcd}
\]
In this case we say that $\iota$ \ul{dominates} $\tau$
\item For two morphisms with the same source $\varepsilon : A \rightarrow C, \tau : A \rightarrow T$ we call a morphism
$u : C \rightarrow T$ a \ul{colift of $\tau$ along $\varepsilon$} if $\varepsilon u = \tau$.
\[
\begin{tikzcd}
A \arrow[rr, "\tau"] \arrow[rd, "\varepsilon"'] &                            & T \\
                                                & C \arrow[ru, "u"', dashed] &  
\end{tikzcd}
\]
In this case we say that $\varepsilon$ \ul{codominates} $\tau$.
\end{itemize}
\end{definition}

\begin{remark}[Lift along mono, colift along epi]
If they exist, lifts along monos and colifts along epis are necessarily unique.
\end{remark}
\begin{proof}
In the above diagram for $\iota$ a monomorphism and as lifts of $\tau$ along $\iota$ we have the two competing
$u, v : T \rightrightarrows K$, both with $u \iota = \tau = v \iota$, the definition of $\iota$ being a monomorphism
implies $u = v$. Dually for colifts along epis.
\end{proof}

The existence of all lifts along monos and all colifts along epis
in a pre-abelian category is therefore an equivalent definition of an abelian category.

\begin{definition}[Abelian category]
An \ul{Abelian category} consists of the following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item A pre-abelian category $\mathcal{C}$.
\item A dependent function $( - / - )$ mapping a monomorphism $\kappa : K \hookrightarrow A$ and a morphism $\tau : T \rightarrow A$ with
the same target $t(\tau) = t(\kappa)$ and the same cokernel projection $\varepsilon_{\tau} = \varepsilon_{\kappa}$ to a lift $(\tau / \kappa)$ of
$\tau$ along $\kappa$.
\item A dependent function $( - \backslash - )$ mapping an epimorphism $\varepsilon : B \twoheadrightarrow C$ and a morphism
$\tau : B \rightarrow T$ with same source $s(\tau) = s(\varepsilon)$ and the same kernel embedding $\kappa_{\tau} = \kappa_{\varepsilon}$
to a colift $(\varepsilon \backslash \tau)$ of $\tau$ along $\varepsilon$.
\end{enumerate}
\end{definition}

\begin{doctrine}[Abelian category]
The doctrine $\mathtt{IsAbelianCategory}$ therefore involves algorithms of $\mathtt{IsPreAbelianCategory}$ together with algorithms for
\begin{itemize}
\item $\mathtt{LiftAlongMonomorphism}$,
\item $\mathtt{ColiftAlongEpimorphism}$
\end{itemize}
\end{doctrine}

\newpage
\subsection{The matrix category $\kmat$ is an abelian category}

The following is an example of a category which has all the limits and colimits mentioned so far, and has them implemented constructively.
We will check the four doctrines $\mathtt{IsAbCategory}$, $\mathtt{IsAdditiveCategory}$, $\mathtt{IsPreAbelianCategory}$ and
$\mathtt{IsAbelianCategory}$ by providing the needed algorithms.

\begin{example}{(The matrix category $\kmat$ over a commutative ring $\Bbbk$)}\label{ex:kmat_skeletal}
\begin{itemize}
\item Objects are natural numbers $\kmat_{0} = \mathbb{N} = \mathbb{N}_{0} = \{0,1,2,\dots\}$ for wich we use small latin letters
($m,n,k,dots$).
\item Morphisms $(m \rightarrow n) \in \kmat_{1}$ are $m \times n$ matrices over $\Bbbk$.
We write the set of morphisms between $m$ and $n$, as $\Bbbk^{m\times n} := \textup{Hom}_{\kmat}(m,n)$. 
For variables that are Matrices we use small greek letters ($\varphi, \psi,\dots$) or capital latin letters ($A, B, C,\dots$). When only source and target are relevant,
we write $(m \times n)$.
\item $s(\varphi) = \mathtt{Source}(\varphi) := \mathtt{NrRows}(\varphi)$
\item $t(\varphi) = \mathtt{Range}(\varphi) := \mathtt{NrColumns}(\varphi)$
\item Identity morphisms are the identity matrices.
\[
1_{m} = \mathtt{IdentityMorphism}(m) := \mathtt{IdentityMat}(m,\Bbbk).
\]
\item Composition is matrix multiplication which is associative.
\[
\varphi\psi = \mathtt{PreCompose}(\varphi,\psi) := \mathtt{MatMul}(\varphi,\psi).
\]
\item It is a skeletal category, i.e. $m \simeq n \Rightarrow m = n$. Only quadratic matrices ($m = n$) can be
isomorphisms.
\end{itemize}
\end{example}

\begin{example}[$\kmat$ is an Ab-category]\label{ex:kmat_pre-additive}
In $\kmat$, the number $0$ is the zero object.\\
A zero matrix (zero morphism) is a matrix factoring through the zero object $0$.\\
\begin{minipage}{.2\textwidth}\phantom{ }\end{minipage}
\begin{minipage}{.25\textwidth}
$\Bbbk^{m\times n} \ni A = 0_{m,n}$
\end{minipage}
\begin{minipage}{.08\textwidth}
$\Longleftrightarrow$
\end{minipage}
\begin{minipage}{.32\textwidth}
\begin{tikzcd}
m \arrow[rr, "A"] \arrow[rd, "(m \times 0)"'] &                               & n \\
                                              & 0 \arrow[ru, "(0 \times n)"'] &  
\end{tikzcd}\\
$\Rightarrow A = (m \times 0) \cdot (0 \times n)$.
\end{minipage}
\begin{minipage}{.15\textwidth}\phantom{ }\end{minipage}\\

\noindent The matrices $(m \times 0)$ and $(0 \times n)$ have zero columns or zero rows respectively, but it is
important to note that for each $m \in \kmat_{0}$ there is exactly one such matrix $(m \times 0)$ and $(0 \times m)$
(that's what initial and terminal object means), and for different $m$, these morphisms are different.

For two natural numbers $m,n \in {\kmat}_{0} = \mathbb{N} = \mathbb{N}_{0}$, the set of morphisms with source $m$ and target $n$ is
$\Bbbk^{m\times n}$, the set of $m \times n$-matrices. This is an abelian group:
\begin{itemize}
\item The neutral element of the addition is the $m \times n$ zero matrix $0_{m,n}$.
\item Addition of matrices is associative and commutative.
\item For every matrix $A \in \Bbbk^{m\times n}$ there is a negative matrix $-A \in \Bbbk^{m \times n}$ such that $A + (-A) = 0_{m,n}$.
\end{itemize}
Composition of matrices is defined as matrix multiplication, which is bilinear, i.e. satisfies the distributive laws \eqref{eq:dist1} and
\eqref{eq:dist2}.\\
It is an easy exercise to provide the algorithms for an Ab-category mentioned in doctrine \ref{doc:ab-category}.
\end{example}

\begin{example}[$\kmat$ is an additive category]\label{ex:kmat_additive}
Let for $I = \{1,\dots,N\},$ the set $\{n_{1},\dots,n_{N}\}$ be a family of objects in $\kmat_{0}$. Their direct sum is
\begin{itemize}
\item the object $n := \bigoplus_{i=1}^{N} n_{i} := \sum_{i=1}^{N} n_{i} = \mathtt{Sum}$
\item For $i \in I$ we have as identity morphism $1_{n_{i}}$ of the object $n_{i}$ the $n_{i} \times n_{i}$ identity matrix.
Define
\[
n_{<i} := \sum_{j=1}^{i-1} n_{j}\quad \text{ and }\quad n_{>i} := \sum_{j=i+1}^{N} n_{j}.
\]
Then we have
\item The projection $\pi_{i} : n \rightarrow n_{i}$ is an $n \times n_{i}$ matrix that is a stacked matrix of the $n_{j}\times n_{i}$
zero matrices not including $0_{n_{i},n_{i}}$ and the identity matrix $1_{n_{i}}$.
\begin{align}
\pi_{i} = \label{eq:projection_direct_sum_matrix}
\begin{pmatrix}
0_{n_{1},\,n_{i}} \\
0_{n_{2},\,n_{i}} \\
\vdots \\
0_{n_{i-1},\,n_{i}} \\
1_{n_{i}} \\
0_{n_{i+1},\,n_{i}} \\
\vdots \\
0_{n_{N},\,n_{i}}
\end{pmatrix}
=
\begin{pmatrix}
0_{n_{<i},\,n_{i}} \\
1_{n_{i}} \\
0_{n_{>i},\,n_{i}}
\end{pmatrix}
\end{align}
\item The coprojection $\iota_{i} : n_{i} \rightarrow n$ is the transposed matrix $\iota_{i} = \pi_{i}^{T}$, i.e. an $n_{i} \times n$ matrix of
the $n_{i} \times n_{j}$ zero matrices not including $0_{n_{i},n_{i}}$ and the identity matrix $1_{n_{i}}$ lined up next to each other.
\begin{align}
\iota_{i} = \label{eq:coprojection_direct_sum_matrix}
\begingroup
\setlength\arraycolsep{2pt}
\begin{pmatrix}
0_{n_{i},n_{1}} & 0_{n_{i},n_{2}} & \dots & 0_{n_{i},n_{i-1}} & 1_{n_{i}} & 0_{n_{i},n_{i+1}} & \dots & 0_{n_{i},n_{N}}
\end{pmatrix}
= \begin{pmatrix}
0_{n_{i},\,n_{<i}} & 1_{n_{i}} & 0_{n_{i},\,n_{>i}}
\end{pmatrix} \endgroup
\end{align}

\item For a family $\tau = (\tau_{i} : t \rightarrow n_{i})_{i\in I}$ we have the morphism $u_{\text{in}}(\tau)$ which is a $t \times n$ block matrix of
the $\tau_{i}$:
\begin{align}
u_{\text{in}}(\tau) = \label{eq:u_in_direct_sum_matrix}
\begin{pmatrix}
\tau_{1} & \cdots & \tau_{N}
\end{pmatrix}
\end{align}
with $u_{\text{in}}(\tau) \pi_{i} = \tau_{i}$.
\item For a family $\tau = (\tau_{i} : n_{i} \rightarrow t)_{i \in I}$ we have the morphism $u_{\text{out}}(\tau)$ which is an $n \times t$ block matrix
of the $\tau_{i}$:
\begin{align}
u_{\text{out}}(\tau) = \label{eq:u_out_direct_sum_matrix}
\begin{pmatrix}
\tau_{1} \\
\vdots \\
\tau_{N}
\end{pmatrix}
\end{align}
with $\iota_{i} u_{\text{out}}(\tau) = \tau_{i}$.
\end{itemize}
One can easily verify the conditions for $\pi$, $\iota$, $u_{\text{in}}$ and $u_{\text{out}}$ in Definitions \ref{def:biproduct} and \ref{def:direct_sum}.
\end{example}


\begin{computation} 
If we assume algorithms for adding natural numbers
\begin{alignat*}{3}
&\mathtt{Sum}( [ m, n &&] ) = m + n, \\
&\mathtt{Sum}( [  &&] ) = 0,
\end{alignat*}
transposing matrices
\begin{align*}
\varphi : m \rightarrow n \\
\mathtt{TransposedMatrix}( \varphi ) = \varphi^{T} : n \rightarrow m
\end{align*}
and for stacking two matrices with the same target on top of each other
\begin{align*}
\varphi : k \rightarrow n \\
\psi : l \rightarrow n\\
\mathtt{StackMatrix}( \varphi, \psi ) =
\begin{pmatrix}
\varphi \\
\psi
\end{pmatrix} : k + l \rightarrow n
\end{align*}
together with the algorithms from $\mathtt{IsAbCategory}$, then we can calculate all the algorithms in the doctrine $\mathtt{IsAdditiveCategory}$.

In the following \Gap{} session, we demonstrate the algorithms of\\
$\mathtt{IsAdditiveCategory}$.
The implementation of objects in the matrix category $\kmat$ in \textsc{Cap} is slightly different than simply natural numbers, since
we always have to mention the commutative ring $\Bbbk$ for the objects. We are using the finite field
$\Bbbk := \mathrm{GF}_{3} := \{ \mathtt{ \cdot, 1, 2 } \}$ for most our calculations.
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@dims := [ 3, 5, 2 ];|
  [ 3, 5, 2 ]
  !gapprompt@gap>| !gapinput@n := Sum( dims );|
  10
  !gapprompt@gap>| !gapinput@GF3 := HomalgRingOfIntegers( 3 );|
  GF(3)
  !gapprompt@gap>| !gapinput@V3 := VectorSpaceObject( 3, GF3 );|
  <A vector space object over GF(3) of dimension 3>
  !gapprompt@gap>| !gapinput@V5 := VectorSpaceObject( 5, GF3 );|
  <A vector space object over GF(3) of dimension 5>
  !gapprompt@gap>| !gapinput@V2 := VectorSpaceObject( 2, GF3 );|
  <A vector space object over GF(3) of dimension 2>
  !gapprompt@gap>| !gapinput@D := [ V3, V5, V2 ];|
  [ <A vector space object over GF(3) of dimension 3>,
    <A vector space object over GF(3) of dimension 5>,
    <A vector space object over GF(3) of dimension 2> ]
  !gapprompt@gap>| !gapinput@S := DirectSum( D );|
  <A vector space object over GF(3) of dimension 10>
  !gapprompt@gap>| !gapinput@V10 := VectorSpaceObject( Sum( [3, 5, 2 ] ), GF3 );|
  <A vector space object over GF(3) of dimension 10>
  !gapprompt@gap>| !gapinput@one3 := IdentityMorphism( V3 );|
  <An identity morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( one3 );|
   1 . .
   . 1 .
   . . 1
   
   An identity morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@zero53 := ZeroMorphism( V5, V3 );|
  <A zero morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( zero53 );|
   . . .
   . . .
   . . .
   . . .
   . . .
   
   A zero morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@zero23 := ZeroMorphism( V2, V3 );|
  <A zero morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( zero23 );|
   . . .
   . . .
   
   A zero morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@factor1 := StackMatrix( [ one3, zero53, zero23 ] );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@pi1 := ProjectionInFactorOfDirectSum( D, 1 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@pi1 = factor1;|
  true
  !gapprompt@gap>| !gapinput@Display( factor1 );|
   1 . .
   . 1 .
   . . 1
   . . .
   . . .
   . . .
   . . .
   . . .
   . . .
   . . .
  
  A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@jot1 := TransposedMatrix( factor1 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( jot1 );|
   1 . . . . . . . . .
   . 1 . . . . . . . .
   . . 1 . . . . . . .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@iota1 := InjectionOfCofactorOfDirectSum( D, 1 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@jot1 = iota1;|
   true
\end{Verbatim}

We can also verify the result in \ref{rmk:addition_derived_from_direct_sum} that the abelian group operation
$\mathtt{AdditionForMorphisms}$ can be derived from $\mathtt{UniversalMorphismIntoDirectSum}$,
$\mathtt{UniversalMorphismFromDirectSum}$,\\
$\mathtt{IdentityMorphism}$ and
$\mathtt{PreCompose}$. As an example we add two $\mathrm{GF}_{3}$-matrices from $\mathtt{V2}$ to $\mathtt{V3}$ in three
different ways.

\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mat1 := HomalgMatrix( [ 0, 1, 2, 1, 1, 2 ], 2, 3, GF3 );|
  <A 2 x 3 matrix over an internal ring>
  !gapprompt@gap>| !gapinput@mat2 := HomalgMatrix( [ 1, 1, 1, 1, 1, 1 ], 2, 3, GF3 );|
  <A 2 x 3 matrix over an internal ring>
  !gapprompt@>| !gapinput@mor1 := VectorSpaceMorphism( V2, mat1, V3 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@>| !gapinput@mor2 := VectorSpaceMorphism( V2, mat2, V3 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@>| !gapinput@result1 := mor1 + mor2;|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( result1 );|
   1 2 .
   2 2 .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@one2 := IdentityMorphism( V2 );|
  <An identity morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@result2 := PreCompose( UniversalMorphismIntoDirectSum( [ one2, one2 ] ),|
  !gapprompt@>| !gapinput@  UniversalMorphismFromDirectSum( [ mor1, mor2 ] ) );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( result2 );|
   1 2 .
   2 2 .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@result1 = result2;|
  true
  !gapprompt@gap>| !gapinput@result3 := PreCompose( UniversalMorphismIntoDirectSum( [ mor1, mor2 ] ),|
  !gapprompt@>| !gapinput@  UniversalMorphismFromDirectSum( [ one3, one3 ] ) );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@result3 = result2;|
  true
\end{Verbatim}
\end{computation}

\begin{doctrine}[Algorithms in $\kmat$ for $\mathtt{IsAdditive}$]

\begin{itemize}
\item $\mathtt{DirectSum (V, W) := VectorSpaceObject( Dimension( V ) + Dimension( W ), R )}$
\item $\mathtt{UniversalMorphismIntoDirectSum}$
\end{itemize}

\end{doctrine}

\begin{example}[Block-Diagonal matrices]\phantom{}\label{ex:block_diagonal_matrix}\\
In a situation with an index set $I = \{1,\dots,N\}$, two families of objects $\{m_{i}\}_{i\in I}, \{n_{i}\}_{i\in I}$ and a family of
morphisms $\{a_{i} : m_{i} \rightarrow n_{i}\}_{i\in I}$ we have the two direct sums
\begin{alignat}{4}
m &:= \bigoplus_{i\in I} m_{i},\quad &&(\pi_{i})_{m} : m \rightarrow m_{i},\quad &&(\iota_{i})_{m} : m_{i} \rightarrow m, \\
n &:= \bigoplus_{i\in I} n_{i},\quad &&(\pi_{i})_{n} : n \rightarrow n_{i},\quad &&(\iota_{i})_{n} : n_{i} \rightarrow n.
\end{alignat}
This situation is displayed in the following diagram
\[
\begin{tikzcd}
m \arrow[dd, "(\pi_{i})_{m}", shift left=2]                           &  & n \arrow[dd, "(\pi_{i})_{n}", shift left=2]       \\
                                                                      &  &                                                   \\
m_{i} \arrow[uu, "(\iota_{i})_{m}", shift left=2] \arrow[rr, "a_{i}"] &  & n_{i} \arrow[uu, "(\iota_{i})_{n}", shift left=2]
\end{tikzcd}
\]
The morphism $a : m \rightarrow n$ defined as
\begin{align}
a = \sum_{i \in I} (\pi_{i})_{m} a_{i} (\iota_{i})_{n}
\end{align}
satisfies
\begin{align}
(\iota_{i})_{m} a (\pi_{i})_{n} &= a_{i}
\end{align}
This an be interpreted in two ways:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item For the family $\iota_{m} a := \{ (\iota_{i})_{m} a : m_{i} \rightarrow n \}$ of morphisms with same target $n$, we have the morphism
$u_{\text{out}}(\iota_{m} a) : m \rightarrow n$ such that $(\iota_{i})_{m} u_{\text{out}}(\iota_{m} a) = (\iota_{i})_{m} a$, and
\item For the family $a \pi_{n} := \{ a (\pi_{i})_{n} : m \rightarrow n_{i} \}$ of morphisms with same source $m$, we have the morphism
$u_{\text{in}}(a \pi_{n}) : m \rightarrow n$ such that $u_{\text{in}}(a \pi_{n}) (\pi_{i})_{n} = a (\pi_{i})_{n}$.
\end{enumerate}
So we have
\begin{align}
(\iota_{i})_{m} u_{\text{out}}(\iota_{m} a) (\pi_{i})_{n} = a_{i} = (\iota_{i})_{m} u_{\text{in}}(a \pi_{n}) (\pi_{i})_{n}
\end{align}
\end{example}

\begin{example}[$\kmat$ is a pre-abelian category]\label{ex:kmat_pre-abelian}
Construction 2.14 in \cite{[Posur]} defines four algorithms deduced from Gaussian elimination
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item SyzygiesOfRows
\item SyzygiesOfColumns
\item LeftDivide
\item RightDivide
\end{enumerate}
from which we can build kernels and cokernels in the matrix category:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item Let $A \in \Bbbk^{m\times n}$, then we define:
\begin{enumerate}
\renewcommand{\labelenumii}{(\alph{enumii})}
\item $\mathrm{ker}(A) :=\,\text{ number of rows of }\,\mathrm{SyzygiesOfRows}(A)$,
\item $\mathrm{KernelEmbedding}(A) := \mathrm{SyzygiesOfRows}(A) \in \mathrm{Hom}_{\kmat}(\mathrm{ker}(A), m)$,
\item for any $T \in \Bbbk^{o\times m}$ such that $TA = 0$, set the universal morphism
\[
\mathrm{KernelLift}(A,T) := \mathrm{RightDivide}(T, \mathrm{SyzygiesOfRows}(A)).
\]
\end{enumerate}
\item Let $A \in \Bbbk^{m\times n}$, then we define:
\begin{enumerate}
\renewcommand{\labelenumii}{(\alph{enumii})}
\item $\mathrm{coker}(A) :=\,\text{ number of columns of }\,\mathrm{SyzygiesOfColumns}(A)$,
\item $\mathrm{CokernelProjection}(A) := \mathrm{SyzygiesOfColumns}(A) \in \mathrm{Hom}_{\kmat}(n, \mathrm{coker}(A))$,
\item for any $T \in \Bbbk^{n\times o}$ such that $AT = 0$, set the universal morphism
\[
\mathrm{CokernelColift}(A,T) := \mathrm{LeftDivide}(\mathrm{SyzygiesOfColumns}(A), T).
\]
\end{enumerate}
\end{enumerate}
With these constructions, $\kmat$ becomes a pre-abelian category.
\end{example}





%%% functors between abelian categories.

\begin{theorem}
The functor category has all limits, colimits and bilimits which exist in the target category.
\end{theorem}

Instead of proving this in general, we prove this as part of \ref{thm:functor_category_abelian} for the direct sum, which is a very special bilimit.

