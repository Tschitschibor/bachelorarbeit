% mainfile: ../main.tex

\subsection{Limit and colimit of a functor}

\begin{definition}{(Source of a functor)}
Let $D : \mathbf{I} \rightarrow \mathcal{C}$ be a functor. A \ul{source} of $D$ consists of the following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $S \in \mathcal{C}$.
\item A dependent function $s$ mapping an object $i \in \mathbf{I}_{0}$ to a morphism
$s(i) : S \rightarrow D(i)$ such that for all $i, j \in \mathbf{I}, \iota : i \rightarrow j$, we have $D(\iota) \cdot s(i) = s(j)$.
\end{enumerate}
\end{definition}

\begin{definition}{(Limit and colimit of a functor)}\label{def:limit}
Let $D : \mathbf{I} \rightarrow \mathcal{C}$ be a functor. A \ul{limit} of $D$ consists of the
following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item A source of $D$ given by the data $(\mathrm{lim}\, D, (\lambda(i) : \mathrm{lim}\, D \rightarrow D(i))_{i\in\mathbf{I}_{0}})$.
\item A dependent function $u$, called the \ul{lift}, mapping every source $\tau = (T, (\tau(i) : T \rightarrow D(i))_{i \in \mathbf{I}})$ to a
morphism $u(\tau) : T \rightarrow \mathrm{lim}\, D$ such that $\lambda(i) \cdot u(\tau) = \tau(i)$ for all $i \in \mathbf{I}$.
This dependent function $u$ is unique with this property.
\end{enumerate}
A \ul{colimit} in $\mathcal{C}$ is a limit in $\mathcal{C}^{\mathrm{op}}$.
\end{definition}

\begin{definition}[Limits of type \textbf{I}]
Let $\mathbf{I}$ be a category. We say a category $\mathcal{C}$ \ul{has limits of type} $\mathbf{I}$ if it is
equipped with a dependent function $\lambda$ mapping a functor $D : \mathbf{I} \rightarrow \mathcal{C}$ to a limit
$(\mathrm{lim}\, D, \lambda_{D}, u_{D})$ of $D$.
We say $\mathcal{C}$ \ul{has colimits of type} $\mathbf{I}$ if $\mathcal{C}^{\mathrm{op}}$ has limits of that type.
\end{definition}

\begin{example}\label{ex:limits}
Depending on \textbf{I} some limits and colimits have special names:
\begin{center}
\begin{tabular}{c|c|c}
generating quiver of $\mathbf{I}$ & limit & colimit \\
\hline
$\emptyset$ & terminal object & initial object \\
$\cdot \text{\phantom{$\rightarrow$}} \cdot$ & binary product & binary coproduct \\
$\cdot \rightarrow \cdot \leftarrow \cdot$ & binary pullback & - \\
$\cdot \leftarrow \cdot \rightarrow \cdot$  & - & binary pushout \\
$ \cdot \rightrightarrows \cdot$ & binary equalizer & binary coequalizer
\end{tabular}
\end{center}
\end{example}

A category having or lacking limits and colimits of a certain type formalizes the notion of what one can or cannot \textit{do} in a category.
Since we are \textit{doing} constructive category theory, this all boils down to which limits and colimits we can \ul{compute}, i.e. for which we
have algorithms, and what needs to be true for the category in order for those algorithms to terminate with a correct output.
Just as in algebra words like ``field'' or ``ring'' or ``abelian group'' are established names and adjectives for sets with additional structure,
in category theory we give special names for categories which have certain limits. This is summarized under the vaguely defined
notion of ``doctrine''.

We say a category is of a certain \ul{categorical doctrine}, if it has all categorical operations appearing in the
defining axioms of the doctrine, in particular if it has all limits and colimits of a required set of types.
In this thesis, we will define a categorical doctrine by specifying a set of algorithms for all existential quantifyers and
disjunctions appearing in the defining axioms of the doctrine, in particular by specifying all algorithms needed to
compute the required (co-)limits.

Being a skeletal category ($\mathtt{IsSkeletalCategory}$) is not a categorical doctrine. Still, it is of high computational benefit
if we can represent a category by a skeletal model.

\subsection{A hierarchy of categorical doctrines}

In this subsection, we give explicit definitions for the (co-)limits in \ref{ex:limits} and define the
doctrines for our categories with such (co-)limits. The doctrine we are interested in is that of an abelian category with
enough projectives and enough injectives. For now we will describe the doctrines up to and including abelian categories, and
leave projective and injective objects for section 5. In section 3 we will work on the doctrine of $\Bbbk$-algebroids or $\Bbbk$-linear
categories.

\begin{doctrine}[Category]\label{doc:category}
The doctrine $\mathtt{IsCategory}$ involves the two algorithms
\begin{itemize}
\item $\mathtt{Source}$\endnote{The two algorithms $\mathtt{Source}$ and $\mathtt{Range}$ are implicit since
each morphism in \CAP has to be defined with source and target.},
\item $\mathtt{Range}$,
\item $\mathtt{PreCompose}$,
\item $\mathtt{IdentityMorphism}$.
\end{itemize}
\end{doctrine}


\subsubsection{Ab-categories}
We are starting simple with Ab-categories. All we need is an abelian group structure on the hom-set between two objects.

\begin{definition}[Zero morphism]\label{def:zero_morphism}\phantom{}\\
A \ul{zero morphism} from $M$ to $N$ is the neutral element of the abelian group $\mathrm{Hom}_{\mathcal{C}}(M,N)$.
\end{definition}
Note that every hom-set has its own unique zero morphism. E.g. in $\kmat$ the $2 \times 3$ zero-matrix
$0_{2,3} \in \textup{Hom}_{\kmat}(2,3)$ is different from the $4 \times 4$ zero-matrix $0_{4,4} \in \textup{Hom}_{\kmat}(4,4)$.

\begin{definition}[Ab-category]
An \ul{Ab-category} (also called \ul{pre-additive category}) is a category in which all homomorphism sets are abelian groups,
and composition distributes over addition.\\
In other words, a category $\mathcal{C}$ is an Ab-category if for every pair of objects $M,N \in \mathcal{C}_{0}$,
$( \mathrm{Hom}_{\mathcal{C}}(M,N), + )$ is an abelian group (with the zero morphism $0_{M,N}$ as the neutral element),
and for all morphisms $\gamma, \delta \in \mathrm{Hom}_{\mathcal{C}}(M,N),
\alpha, \beta \in \mathrm{Hom}_{\mathcal{C}}(N,L)$
\begin{align}
(\gamma + \delta)\alpha &=\label{eq:dist1} \gamma\alpha + \delta\alpha\quad \mathrm{ and }\\
\gamma(\alpha+\beta) &=\label{eq:dist2} \gamma\alpha + \gamma\beta.
\end{align}
\end{definition}

\begin{doctrine}[Ab-category]\label{doc:ab-category}
The doctrine $\mathtt{IsAbCategory}$ therefore involves algorithms for $\mathtt{IsCategory}$ and
\begin{itemize}
\item $\mathtt{AdditionForMorphisms}$,
\item $\mathtt{AdditiveInverseForMorphisms}$,
\item ($\mathtt{SubtractionForMorphisms}$),
\item $\mathtt{ZeroMorphism}$,
\item $\mathtt{IsZeroForMorphisms}$.
\end{itemize}
\end{doctrine}

\begin{definition}[Ab-functor]
A functor between Ab-categories is called an \ul{Ab-functor} if in the functor definition \ref{def:functor} the function $Ff$ for each
morphism $f$ is a homomorphism of abelian groups, i.e. $F(f+g) = Ff + Fg$.
\end{definition}

\subsubsection{Categories with a zero object}

\begin{remark}[Terminal object, initial object, zero object]\label{def:init_term_zero_object}
The limit / colimit of $\emptyset$.
\renewcommand{\labelenumi}{(\theenumi)}
\begin{enumerate}
\item A \ul{terminal object} $T$ in a category $\mathcal{C}$ is an object such that $\textup{Hom}_{\mathcal{C}}(-,T)$ is a singleton.
\item An \ul{initial object} $I$ in a category $\mathcal{C}$ is an object such that $\textup{Hom}_{\mathcal{C}}(I,-)$ is a singleton.
\item An object $Z$ or $0$ is a \ul{zero object} if it is both initial and terminal. (Bilimit of $\emptyset$).
\end{enumerate}
\end{remark}

\begin{definition}[Zero morphism]\label{def:zero_morphism}\phantom{}\\
A \ul{zero morphism} in a category with a zero object $0$ is a morphism factoring over $0$, i.e. $\varphi : M \rightarrow N$ is called a zero
morphism, if\\
\begin{minipage}{.35\textwidth}
\begin{tikzcd}
M \arrow[rr, "\varphi"] \arrow[rd, "\varphi_{1}"] &                              & N \\
                                                  & 0 \arrow[ru, "\varphi_{2}"'] &  
\end{tikzcd}
\end{minipage}
\begin{minipage}{.65\textwidth}
$\exists \varphi_{1} : M \rightarrow 0, \varphi_{2} : 0 \rightarrow N$\\
such that $\varphi = \varphi_{1}\varphi_{2}$.
\end{minipage}
Since the zero object $0$ is both initial and terminal, a zero morphism is uniquely defined by its source and target, thus we can
talk about \textit{the} zero morphism from $M$ to $N$, which we denote by $0_{M,N}$.\endnote{We could define the zero morphism without
the zero object, just as the neutral element of the abelian group $\mathrm{Hom}_{\mathcal{C}}(M,N)$. Therefore $\mathtt{ZeroMorphism}(M,N)$
is needed in the doctrine of $\mathtt{IsAbCategory}$, but the $\mathtt{ZeroObject}$ is not. Eventually at additive categories the
zero object arrises naturally as the direct sum of $\emptyset$, which is why $\mathtt{ZeroObject}$ is listed only there.}
\end{definition}

\begin{doctrine}[Category with zero object]
The doctrine $\mathtt{IsCategoryWithZeroObject}$ therefore involves algorithms for
\begin{itemize}
 \item $\mathtt{ZeroObject}$,
 \item $\mathtt{UniversalMorphismFromZeroObject}$,
 \item $\mathtt{UniversalMorphismIntoZeroObject}$.
\end{itemize}
\end{doctrine}

If an Ab-category has a zero object, then both notions of a zero morphism coincide.

\subsubsection{Additive categories}
The definition of the binary operation $+$ in a pre-additive category came as arbitrary outside data and could be defined
in multiple ways. A category with the following limits is additive in at most one way, warrenting the name additive category.

\begin{definition}[Product, coproduct]\label{def:prod_coprod}
The limit / colimit of a set of objects $\,\cdot \text{\phantom{$\rightarrow$}} \cdot$\\
Let $I$ be an index set and $\{A_{i}\}_{i\in I}$ a family of objects in a category $\mathcal{C}$.
\setlist[description]{font=\normalfont}
\begin{description}
\item[(prod)] The \ul{product} of the family $\{A_{i}\}_{i\in I}$ is an object $\invamalg A_{i}$ together with a family of morphisms
\[
\{ \pi_{i} : \invamalg A_{i} \rightarrow A_{i} \}
\]
called \ul{projections}, such that the following universal property is satisfied:\\
For any object $M \in \mathcal{C}_{0}$ and any family $\{ \varphi_{i} : M \rightarrow A_{i} \}_{i\in I}$ of morphisms, there exists
a unique morphism $\varphi : M \rightarrow \invamalg A_{i}$ called the \ul{product morphism} such that
\[
\varphi \pi_{i} = \varphi_{i} \, \forall i \in I.
\]
\begin{tikzcd}
                                                                                                                            &  &                                                          & A_{1} \\
M \arrow[rrru, "\varphi_{1}", bend left] \arrow[rrrd, "\varphi_{2}"', bend right] \arrow[rr, "\exists^{1} \varphi", dashed] &  & A_{1}\invamalg A_{2} \arrow[ru, "\pi_{1}"] \arrow[rd, "\pi_2"] &       \\
                                                                                                                            &  &                                                          & A_{2}
\end{tikzcd}
\item[(coprod)] The dual notion to product is the \ul{coproduct} of the family $\{A_{i}\}_{i\in I}$, that is an object $\amalg A_{i}$ together with
a family of morphisms
\[
\{ \iota_{i} : A_{i} \rightarrow \amalg A_{i} \}
\]
called \ul{coprojections} or sometimes \ul{injections}, \ul{inclusions} or \ul{embeddings}, such that the following universal property is satisfied:\\
For any object $M \in \mathcal{C}$ and any family $\{ \psi_{i} : A_{i} \rightarrow M \}$ of morphisms, there exists a unique
morphism $\psi : \amalg A_{i} \rightarrow M$ called the \ul{coproduct morphism} such that
\[
\iota_{i} \psi = \psi_{i} \, \forall i \in I.
\]
\begin{tikzcd}
  &  &                                                           & A_{1} \arrow[llld, "\psi_{1}"', bend right] \arrow[ld, "\iota_{1}"'] \\
M &  & A_{1}\amalg A_{2} \arrow[ll, "\exists^{1} \psi"', dashed] &                                                                      \\
  &  &                                                           & A_{2} \arrow[lllu, "\psi_{2}", bend left] \arrow[lu, "\iota_2"]     
\end{tikzcd}
\end{description}
\end{definition}

\begin{definition}[Biproduct]\label{def:biproduct}
Let $I$ be an index set and $\{S_{i}\}_{i\in I}$ a family of objects in a category $\mathcal{C}$.
A \ul{biproduct} is a product and a coproduct simultaneously, i.e. consists of the following data:
\begin{itemize}
\item an object $S \in \mathcal{C}_{0}$,
\item a family of morphisms $\pi = \{ \pi_{i} : S \rightarrow S_{i} \}_{i\in I}$,
\item a family of morphisms $\iota = \{ \iota_{i} : S_{i} \rightarrow S \}_{i\in I}$,
\item a dependent function $u_{\text{in}}$ mapping every family $\tau = \{ \tau_{i} : T \rightarrow S_{i} \}_{i\in I}$ of morphisms
with the same source $T$ to a morphism
$u_{\text{in}}(\tau) : T \rightarrow S$ such that $u_{\text{in}}(\tau) \pi_{i} \sim \tau_{i}$ for all $i \in I$,
\item a dependent function $u_{\text{out}}$ mapping every family $\rho = \{ \rho_{i} : S_{i} \rightarrow R \}_{i\in I}$ of morphisms
with the same target $R$ to a morphism
$u_{\text{out}}(\rho) : S \rightarrow R$ such that $\iota_{i} u_{\text{out}}(\rho) \sim \rho_{i}$ for all $i \in I$,
\end{itemize}
\end{definition}

\begin{definition}{(Direct sum)}\label{def:direct_sum}
A \ul{direct sum} is a biproduct of objects in an Ab-category such that
\begin{itemize}
\item $\sum_{i\in I}  \pi_{i} \iota_{i} \sim 1_{S}$,
\item $ \iota_{i} \pi_{j} \sim \delta_{i, j} =  \begin{cases}
            1_{S_{i}} & \text{ if } i = j  \\
            0_{ij} & \text{ if } i \neq j
        \end{cases}$,
\end{itemize}
where $\delta_{i, j} \in \mathrm{Hom}(S_{i}, S_{j})$ is the identity if $i = j$, and the zero morphism $0_{ij} := 0_{S_{i}, S_{j}}$ otherwise.
\end{definition}

\begin{example}[The direct sum of $\emptyset$]\label{ex:sum_of_empty}
For the index set $I = \emptyset$ we get an empty family of objects in a category $\mathcal{C}$. Its direct sum is
\begin{itemize}
\item an object $Z \in \mathcal{C}_{0}$,
\item empty morphism sets $\pi$ and $\iota$,
\item a dependent function $u_{\text{in}}$ maps an empty collection $\tau$ of morphisms with same source $T$ to a unique
morphism $u_{\text{in}}(\tau) : T \rightarrow Z$.
\item a dependent function $u_{\text{out}}$ maps an empty collection $\rho$ of morphisms with same target $R$ to a unique
morphism $u_{\text{out}}(\rho) : Z \rightarrow R$.
\end{itemize}
The unique morphisms $T \rightarrow Z$ and $Z \rightarrow T$ for any object $T$ (the empty family $\tau$ imposing no further condition)
suggests that our object $Z = \mathrm{DirectSum}(\emptyset)$ is in fact the zero object from \ref{def:init_term_zero_object}, and the
unique morphisms are the unique zero morphisms in $\mathrm{Hom}(Z,T)$ and $\mathrm{Hom}(T,Z)$ from \ref{def:zero_morphism}.
\end{example}

\begin{definition}\label{def:additive_category}
An \ul{additive category} is a pre-additive category $\mathcal{C}$ together with a dependent function $\oplus^{\mathcal{C}}$ mapping
a finite set $I$ and a family $(A_{i})_{i\in I}$ of objects in $\mathcal{C}$ to a corresponding direct sum $(\oplus_{i\in I}^{\mathcal{C}} A_{i},
(\pi_{i})_{i\in I}, (\iota_{i})_{i\in I})$.
\end{definition}

\begin{remark}[Addition of morphisms]\label{rmk:addition_derived_from_direct_sum}
In an additive category the abelian group structure on $\mathrm{Hom}_{\mathcal{C}}(M,N)$ can be derived from the direct sum:
For $\rho_{1}, \rho_{2} \in \mathrm{Hom}_{\mathcal{C}}(M,N)$
\[
\rho_{1} + \rho_{2} = u_{\mathrm{in}}(1_{M},1_{M}) u_{\mathrm{out}}(\rho_{1},\rho_{2}) 
= u_{\mathrm{in}}(\rho_{1},\rho_{2}) u_{\mathrm{out}}(1_{N},1_{N})
\]
The above equation illustrates that an additive category is
pre-additive in at most one way, i.e. we don't have a choice how we define the abelian group structure on the hom-sets.
\endnote{This result is already implemented in \textsc{Cap} as a derivation of \texttt{AdditionForMorphisms} from the four morphisms
\texttt{UniversalMorphismIntoDirectSum}, \texttt{IdentityMorphism}, \texttt{UniversalMorphismFromDirectSum} and \texttt{PreCompose}.
See 
\url{https://github.com/homalg-project/CAP_project/blob/v2019.06.06/CAP/gap/DerivedMethods.gi\#L1024}}
\end{remark}

\begin{doctrine}[Additive category]
The doctrine $\mathtt{IsAdditiveCategory}$ therefore involves algorithms of $\mathtt{IsAbCategory}$ and
$\mathtt{IsCategoryWithZeroObject}$ together with algorithms for
\begin{itemize}
 \item $\mathtt{DirectSum}$,
 \item $\mathtt{ProjectionInFactorOfDirectSum}$,
 \item $\mathtt{InjectionOfCofactorOfDirectSum}$,
 \item $\mathtt{UniversalMorphismIntoDirectSum}$,
 \item $\mathtt{UniversalMorphismFromDirectSum}$.
\end{itemize}
\end{doctrine}

\subsubsection{Pre-abelian categories}

A pre-abelian category is an additive category with kernels and cokernels, and hence images and coimages. To define
kernels and cokernels we need the following definition.

\begin{definition}[binary equalizer]
The limit of two parallel morphisms $\,\cdot \rightrightarrows \cdot$\\
If it exists in a category $\mathcal{C}$, the \ul{equalizer} of two morphisms $f, g : A \rightrightarrows B \in \mathcal{C}_{1}$
consists of the data
\begin{itemize}
\item an object $E := \mathrm{Eq}(f,g) \in \mathcal{C}_{0}$
\item a morphism $\iota := E \hookrightarrow A$ such that pulled back to $E$, both morphisms are equal $\iota\,f = \iota\,g$:
\begin{align*}
&E \xrightarrow{\iota} A \xrightarrow{f} B \\
=\, &E \xrightarrow{\iota} A \xrightarrow{g} B
\end{align*}
\item a dependent function $u$ such that for any other morphism $\tau : T \rightarrow A$ with
\begin{align*}
&T \xrightarrow{\tau} A \xrightarrow{f} B \\
=\, &T \xrightarrow{\tau} A \xrightarrow{g} B
\end{align*}
we have a unique morphism $u( \tau ) : T \rightarrow E$ such that $u( \tau ) \iota = \tau$.
\[
\begin{tikzcd}
E \arrow[r, "\iota", hook]                              & A \arrow[r, "f", shift left] \arrow[r, "g"', shift right] & B \\
T \arrow[ru, "\tau"] \arrow[u, "u(\tau)", dashed] &                                                           &  
\end{tikzcd}
\]
\end{itemize}
The dual concept is that of a \ul{coequalizer}, which is the colimit of $\,\cdot \rightrightarrows \cdot$.
\end{definition}

The following definition is a special case of an equalizer where $g = 0_{A,B}$. We will write it all out explicitly with their
own names for objects, morphisms and (co-)lifts.

\begin{definition}[Kernel]\label{def:kernel}\phantom{}\\
In an additive category $\mathcal{C}$, the \ul{kernel} of a morphism $f : A \rightarrow B \in \mathcal{C}_{1}$ is the equalizer
of $f$ and $0_{A,B}$, i.e. consists of the data
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $K = \mathrm{Ker}(f)$
\item A morphism $\mathrm{KernelEmbedding}(f) := \kappa : K \rightarrow A$ such that $\kappa\,f = \kappa\,0_{A,B} = 0_{K,B}$:
\begin{align*}
\begin{tikzcd}[
  ampersand replacement=\&,
  row sep=1em,
]
{\phantom{=\, }K} \arrow[r, "\kappa"]                 \& A \arrow[r, "f"] \& B \\
{=\, K} \arrow[r, "\kappa"]   \& A \arrow[r, "0_{A,B}"] \& B \\
{= \, K} \arrow[rr, "{0_{K,B}}"] \&                            \& B
\end{tikzcd}
\end{align*}
\item A unique dependent function $\mathrm{KernelLift}(f,-) := ( - /\kappa)$ mapping a morphism $\tau : T \rightarrow A$ with $\tau f = 0_{T,B}$ to a
morphism $\mathrm{KernelLift}(f,\tau) = (\tau / \kappa) : T \rightarrow K$ such that
\[
\tau = (\tau / \kappa)\, \kappa.
\]
\end{enumerate}
\[
\begin{tikzcd}
K \arrow[r, "\kappa"]                            & A \arrow[r, "f"] & B \\
T \arrow[ru, "\tau"'] \arrow[u, "(\tau/\kappa)", dashed] &                  &  
\end{tikzcd}
\]
The last property means that the kernel embedding $\kappa$ dominates every such $\tau$, and that the kernel lift
$(\tau/\kappa)$ is the unique lift of $\tau$ along $\kappa$ in the sense of \ref{def:lift_colift_codominate}(1).
\end{definition}

\begin{definition}[Cokernel]
In an additive category $\mathcal{C}$, the \ul{cokernel} of a morphism $f : A \rightarrow B \in \mathcal{C}_{1}$ is the coequalizer of
$f$ and $0_{A,B}$, i.e. consists of the data
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An object $C = \mathrm{Coker}(f)$
\item A morphism $\mathrm{CokernelProjection}(f) := \varepsilon : B \rightarrow C$ such that $f\,\varepsilon = 0_{A,B}\,\varepsilon = 0_{A,C}$:
\begin{align*}
\begin{tikzcd}[
  ampersand replacement=\&,
  row sep=1em,
]
{\phantom{=\, }A} \arrow[r, "f"]                 \& B \arrow[r, "\varepsilon"] \& C \\
{=\, A} \arrow[r, "{0_{A,B}}"]   \& B \arrow[r, "\varepsilon"] \& C \\
{= \, A} \arrow[rr, "{0_{A,C}}"] \&                            \& C
\end{tikzcd}
\end{align*}
\item A unique dependent function $\mathrm{CokernelColift}(f,-) := ( \varepsilon \backslash -)$ mapping a morphism $\tau : B \rightarrow T$ with
$f \tau  = 0_{A,T}$ to a morphism $\mathrm{CokernelColift}(f,\tau) = ( \varepsilon \backslash \tau) : C \rightarrow T$ such that
\[
\tau =\label{eq:cokernel_colift} \varepsilon \, (\varepsilon \backslash \tau).
\]
\end{enumerate}
\[
\begin{tikzcd}
A \arrow[r, "f"] & B \arrow[r, "\varepsilon", two heads] \arrow[rd, "\tau"] & C \arrow[d, "(\varepsilon\backslash\tau)", dashed] \\
                 &                                                          & T                                                 
\end{tikzcd}
\]
The last property means that the cokernel projection $\varepsilon$ codominates every such $\tau$, and that the cokernel colift
$(\varepsilon \backslash \tau)$ is the unique colift of $\tau$ along $\varepsilon$ in the sense of \ref{def:lift_colift_codominate}(2).
\end{definition}

\begin{definition}[Image]
In an additive category $\mathcal{C}$ we define the \ul{image} of a morphism\\
$f : A \rightarrow B \in \mathcal{C}_{1}$ as the kernel of its cokernel:\\
\begin{minipage}{.06\textwidth} \phantom{} \end{minipage}
\begin{minipage}{.39\textwidth}
\[
\begin{tikzcd}[
  ampersand replacement=\&,
]
A \arrow[r, "f"] \arrow[d, "(f/\kappa_{\varepsilon})"', dashed]         \& B \arrow[r, "\varepsilon", shift left, two heads]
\arrow[r, "{0_{B,C}}"', shift right] \& C \\
K \arrow[ru, "\kappa_{\varepsilon}", hook]                                    \&                            \&   \\
T \arrow[u, "(\tau/\kappa_{\varepsilon})", dashed] \arrow[ruu, "\tau"'] \&                            \&  
\end{tikzcd}
\]
\end{minipage}
\begin{minipage}{.49\textwidth}
Since $\varepsilon$ is the cokernel projection of $f$, the morphism $f : A \rightarrow B$ with $f\,\varepsilon = 0_{A,C}$ plays the
same role as any $\tau : T \rightarrow B$ with $\tau\,\varepsilon = 0_{T,C}$ in that it factors over the kernel object $K$ in a
unique way: 
\[
f = (f/\kappa_{\varepsilon})\,\kappa_{\varepsilon}
\]
\end{minipage}
\begin{minipage}{.06\textwidth} \phantom{} \end{minipage}

Thus, the image is
\begin{itemize}
\item An object $\mathrm{Im}(f) := \mathrm{Ker}(\varepsilon)$ where $\varepsilon = \mathrm{CokernelProjection}(f)$,
\item A morphism $\mathrm{ImageEmbedding}(f) := \mathrm{KernelEmbedding}(\mathrm{CokernelProjection}(f))$
\end{itemize}
To differentiate the image of $f$ (which is a kernel, but not the kernel of $f$) from the kernel of $f$,
we are using $I$ for $\mathrm{Im}(f)$ and $\iota$ for $\mathrm{ImageEmbedding}(f)$.
\end{definition}

\begin{definition}[Coimage]
In an additive category $\mathcal{C}$ we define the \ul{coimage} of a morphism $f : A \rightarrow B \in \mathcal{C}_{1}$ as the 
cokernel of its kernel:\\
\begin{minipage}{.06\textwidth} \phantom{} \end{minipage}
\begin{minipage}{.39\textwidth}
\[
\begin{tikzcd}[
  ampersand replacement=\&,
]
K \arrow[r, "\kappa", hook, shift left] \arrow[r, "{0_{K,A}}"', shift right] \& A \arrow[r, "f"] \arrow[rd, "{\varepsilon_{\kappa}}", two heads] \arrow[rdd, "\tau"'] \& B                                                                                                   \\
                                                                             \&                                                                            \& C \arrow[u, "({\varepsilon_{\kappa}}\backslash f)"', dashed] \arrow[d, "({\varepsilon_{\kappa}}\backslash \tau)", dashed] \\
                                                                             \&                                                                            \& T                                                                                                  
\end{tikzcd}
\]
\end{minipage}
\begin{minipage}{.49\textwidth}
Since $\kappa$ is the kernel embedding of $f$, the morphism $f : A \rightarrow B$ with $\kappa\,f = 0_{K,B}$ plays the
same role as any $\tau : A \rightarrow T$ with $\kappa\,\tau = 0_{K,T}$ in that it factors over the cokernel object $C$ in a
unique way:
\[
f = \varepsilon_{\kappa}\,(\varepsilon_{\kappa}\backslash f)
\]
\end{minipage}
\begin{minipage}{.06\textwidth} \phantom{} \end{minipage}

Thus, the coimage is
\begin{itemize}
\item An object $\mathrm{Coim}(f) := \mathrm{Coker}(\kappa)$ where $\kappa = \mathrm{KernelEmbedding}(f)$,
\item A morphism $\varepsilon_{\kappa} := \mathrm{CoimageProjection}(f) := \mathrm{CokernelProjection}(\mathrm{KernelEmbedding}(f))$
\end{itemize}
Since it was reserved for cokernel, we are not using $C$ to denote the coimage object.
\end{definition}

\begin{definition}{(Pre-Abelian category)}
A \ul{pre-abelian category} consists of the following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item An additive category $\mathcal{C}$.
\item A dependent function mapping every morphism $f : A \rightarrow B$ for $A, B \in \mathcal{C}_{0}$ to a
kernel of $f$.
\item A dependent function mapping every morphism $f : A \rightarrow B$ for $A, B \in \mathcal{C}_{0}$ to a
cokernel of $f$.
\end{enumerate}
\end{definition}

\begin{doctrine}[Pre-abelian category]\label{doc:pre-abelian}
The doctrine $\mathtt{IsPreAbelianCategory}$ therefore involves algorithms of $\mathtt{IsAdditiveCategory}$ together with algorithms for
\begin{itemize}
\item $\mathtt{KernelObject}$,
\item $\mathtt{KernelEmbedding}$,
\item $\mathtt{KernelLift}$,
\item $\mathtt{CokernelObject}$,
\item $\mathtt{CokernelProjection}$,
\item $\mathtt{CokernelColift}$
\end{itemize}
\end{doctrine}

\begin{remark}[Kernel lift of cokernel colift $=$ cokernel colift of kernel lift]\label{rmk:kerl_col_col_kerl}\phantom{}\\
In categories with kernels and cokernels we can compute images and coimages together with an induced morphism
\begin{align}
\overline{\varphi} : \mathrm{Coim}(\varphi) \rightarrow \mathrm{Im}(\varphi).
\end{align}
This morphism being an isomorphism is one of the defining axioms of Abelian categories.
\end{remark}
\begin{proof}
Given a morphism $\varphi : M \rightarrow N$ in a pre-Abelian category $\mathcal{C}$, we can compute its kernel embedding
$\kappa : \mathrm{Ker}(\varphi) \hookrightarrow M$ and its cokernel projection
$\varepsilon : N \twoheadrightarrow \mathrm{Coker}(\varphi)$. They are the equalizer and coequalizer of $\varphi$ and $0_{M,N}$,
in particular we have $\kappa \, \varphi = 0_{\mathrm{Ker}(\varphi),N}$ and
$\varphi \, \varepsilon = 0_{M,\mathrm{Coker}(\varphi)}$ (the two $0$-arrows on the top).

For the kernel embedding $\kappa$ we can compute its cokernel projection
$\varepsilon_{\kappa} : M \twoheadrightarrow \mathrm{Coim}(\varphi)$ which we called the coimage projection of $\varphi$.
Keeping in mind, that it is the cokernel of $\kappa$, i.e. the coequalizer of $\kappa$ and $0_{\mathrm{Ker}(\varphi),M}$, we get
the zero morphism $0_{\mathrm{Ker}(\varphi),\mathrm{Coim}(\varphi)}$ (the bottom left $0$-arrow).

Dually for the cokernel projection $\varepsilon$ we can compute its kernel embedding
$\kappa_{\varepsilon} : \mathrm{Im} \hookrightarrow N$ which we called the image embedding of $\varphi$. Again we see
that we have the zero morphism $0_{\mathrm{Im}(\varphi),\mathrm{Coker}(\varphi)}$ (the bottom right $0$-arrow).

The two morphisms $\varphi$ and its coimage projection $\varepsilon_{\kappa}$ have the same source $M$ and
composed with $\kappa$, both yield zero morphisms. Since $\varepsilon_{\kappa}$ codominates $\varphi$, we have
a unique cokernel colift\\
$(\varepsilon_{\kappa}\backslash \varphi) : \mathrm{Coim}(\varphi) \rightarrow N$, which is one of the two diagonals
in the square diagram, and for which\\
$\varepsilon_{\kappa} \cdot (\varepsilon_{\kappa}\backslash \varphi) = \varphi$.

Now $\kappa_{\varepsilon}$ and the above colift $(\varepsilon_{\kappa}\backslash \varphi)$ both have the same target $N$.
For $\kappa_{\varepsilon}$ we already know that composed with $\varepsilon$ we get the zero morphism.
If we also proved that
$(\varepsilon_{\kappa}\backslash \varphi) \cdot \varepsilon = 0_{\mathrm{Coim}(\varphi),\mathrm{Coker}(\varphi)}$, i.e.
the red $0$-arrow in the picture, then since $\kappa_{\varepsilon}$ dominates $(\varepsilon_{\kappa}\backslash \varphi)$
we get the existence of the kernel lift of the cokernel colift
\[
(\varepsilon_{\kappa}\backslash \varphi) / \kappa_{\varepsilon} : \mathrm{Coim}(\varphi) \rightarrow \mathrm{Im}(\varphi)
\]

\[
\begin{tikzcd}
\mathrm{Ker}(\varphi) \arrow[rd, "\kappa", hook] \arrow[rddd, "0"', bend right] \arrow[rrrd, "0", pos=0.3, bend left] &                                                                                                                                                                                             &  &                                                                                               & \mathrm{Coker}(\varphi) \\
                                                                                                             & M \arrow[rrru, "0", pos=0.7, bend left] \arrow[rr, "\varphi"] \arrow[dd, "\varepsilon_{\kappa}"', two heads]                                                                                         &  & N \arrow[ru, "\varepsilon", two heads]                                                        &                         \\
                                                                                                             &                                                                                                                                                                                             &  &                                                                                               &                         \\
                                                                                                             & \mathrm{Coim}(\varphi) \arrow[rruu, "(\varepsilon_{\kappa}\backslash \varphi)"'] \arrow[rr, "(\varepsilon_{\kappa}\backslash\varphi)/\kappa_{\varepsilon}"'] \arrow[rrruuu, "0", pos=0.7, color=red, bend left] &  & \mathrm{Im}(\varphi) \arrow[uu, "\kappa_{\varepsilon}"', hook] \arrow[ruuu, "0"', bend right] &                        
\end{tikzcd}
\]

\begin{subproof}[Proof that $(\varepsilon_{\kappa}\backslash \varphi) \cdot \varepsilon = 0_{\mathrm{Coim}(\varphi),\mathrm{Coker}(\varphi)}$]\phantom{}\\
We have $\varepsilon_{\kappa} \cdot (\varepsilon_{\kappa}\backslash \varphi) = \varphi$, i.e. the top left triangle
of the square commutes. But then since composition with a zero morphism gives a zero morphism we have
\begin{align*}
&\varepsilon_{\kappa} \cdot 0_{\mathrm{Coim}(\varphi),\mathrm{Coker}(\varphi)} : M \rightarrow \mathrm{Coker}(\varphi) \\
=\, &0_{M,\mathrm{Coker}(\varphi)} \\
=\, &\varphi \cdot \varepsilon \\
=\, &\varepsilon_{\kappa} \cdot (\varepsilon_{\kappa}\backslash \varphi) \cdot \varepsilon
\end{align*}
And pre-cancellation of the epimorphism $\varepsilon_{\kappa}$ gives
\begin{align*}
0_{\mathrm{Coim}(\varphi),\mathrm{Coker}(\varphi)} = (\varepsilon_{\kappa}\backslash \varphi) \cdot \varepsilon.
\end{align*}
\end{subproof}

Dual to the above picture, the two morphisms $\varphi$ and its image embedding $\kappa_{\varepsilon}$ both have the same
target $N$ and composed with $\varepsilon$, both yield zero morphisms. Since $\kappa_{\varepsilon}$ dominates $\varphi$,
we have a unique kernel lift
$(\varphi / \kappa_{\varepsilon}) : M \rightarrow \mathrm{Im}(\varphi)$, which is the other diagonal in the square diagram,
and for which $(\varphi / \kappa_{\varepsilon})\cdot \kappa_{\varepsilon} = \varphi$.

Now $\varepsilon_{\kappa}$ and $(\varphi / \kappa_{\varepsilon})$ both have the same source $M$. For $\varepsilon_{\kappa}$
we already know that composed with $\kappa$ we get the zero morphism. If we also proved that
$\kappa \cdot (\varphi / \kappa_{\varepsilon}) = 0_{\mathrm{Ker}(\varphi),\mathrm{Im}(\varphi)}$, i.e. the red $0$-arrow in the
picture, then, since $\varepsilon_{\kappa}$ codominates $(\varphi / \kappa_{\varepsilon})$ we get the existence of the
cokernel colift of the kernel lift
\[
\varepsilon_{\kappa}\backslash(\varphi/\kappa_{\varepsilon}) : \mathrm{Coim}(\varphi) \rightarrow \mathrm{Im}(\varphi)
\]

\[
\begin{tikzcd}
\mathrm{Ker}(\varphi) \arrow[rd, "\kappa", hook] \arrow[rddd, "0"', bend right] \arrow[rrrd, "0", pos=0.3, bend left] \arrow[rrrddd, "0"', pos=0.25, color=red, shift left=2, bend right] &                                                                                                                                                    &  &                                                                                               & \mathrm{Coker}(\varphi) \\
                                                                                                                                             & M \arrow[rrru, "0", pos=0.7, bend left] \arrow[rr, "\varphi"] \arrow[dd, "\varepsilon_{\kappa}"', two heads] \arrow[rrdd, "(\varphi/\kappa_{\varepsilon})"] &  & N \arrow[ru, "\varepsilon", two heads]                                                        &                         \\
                                                                                                                                             &                                                                                                                                                    &  &                                                                                               &                         \\
                                                                                                                                             & \mathrm{Coim}(\varphi) \arrow[rr, "\varepsilon_{\kappa}\backslash(\varphi/\kappa_{\varepsilon})"']                                                 &  & \mathrm{Im}(\varphi) \arrow[uu, "\kappa_{\varepsilon}"', hook] \arrow[ruuu, "0"', bend right] &                        
\end{tikzcd}
\]

\begin{subproof}[Proof that $\kappa \cdot (\varphi / \kappa_{\varepsilon}) = 0_{\mathrm{Ker}(\varphi),\mathrm{Im}(\varphi)}$]\phantom{}\\
We have $(\varphi / \kappa_{\varepsilon}) \cdot \kappa_{\varepsilon} = \varphi$, i.e. the top right triangle
of the square commutes. But then since composition with a zero morphism gives a zero morphism we have
\begin{align*}
&0_{\mathrm{Ker}(\varphi),\mathrm{Im}(\varphi)} \cdot \kappa_{\varepsilon} : \mathrm{Ker}(\varphi) \rightarrow N \\
=\, &0_{\mathrm{Ker}(\varphi),N} \\
=\, &\kappa \cdot \varphi \\
=\, &\kappa \cdot (\varphi / \kappa_{\varepsilon}) \cdot \kappa_{\varepsilon}
\end{align*}
And post-cancellation of the monomorphism $\kappa_{\varepsilon}$ gives
\begin{align*}
0_{\mathrm{Ker}(\varphi),\mathrm{Im}(\varphi)} = \kappa \cdot (\varphi / \kappa_{\varepsilon}).
\end{align*}
\end{subproof}

So we have two morphisms from $\mathrm{Coim}(\varphi)$ to $\mathrm{Im}(\varphi)$:
\begin{alignat*}{3}
\underbrace{(\varepsilon_{\kappa}\backslash \varphi) / \kappa_{\varepsilon}}_{\alpha} & \quad\text{and}\quad
&& \underbrace{\varepsilon_{\kappa}\backslash(\varphi/\kappa_{\varepsilon})}_{\beta}.
\end{alignat*}
In fact they are equal since the two commutative traingles give commutative squares.
\begin{align*}
\varepsilon_{\kappa}\, \alpha \, \kappa_{\varepsilon} = \varphi = \varepsilon_{\kappa}\, \beta \, \kappa_{\varepsilon} 
\end{align*}
Since the epi $\varepsilon_{\kappa}$ is pre-cancelable and the mono $\kappa_{\varepsilon}$ is post-cancelable, we get $\alpha = \beta$, i.e.
\begin{align*}
(\varepsilon_{\kappa}\backslash \varphi) / \kappa_{\varepsilon} = \varepsilon_{\kappa}\backslash(\varphi/\kappa_{\varepsilon})
\end{align*}
This justifies the notation
\begin{align}\label{eq:natural_morphism}
\overline{\varphi} := \varepsilon_{\kappa}\backslash \varphi / \kappa_{\varepsilon} : \mathrm{Coim}(\varphi) \rightarrow \mathrm{Im}(\varphi).
\end{align}
In this context associativity holds, i.e. we can leave out the parentheses of the lift and colift.
\end{proof}






\newpage
\subsubsection{Abelian categories}

In this section we give three equivalent definitions for Abelian categories, starting abstractly from the above diagrams
and ending with the existence of two algorithms needed for the doctrine $\mathtt{IsAbelianCategory}$.

\begin{definition}[Abelian category]
A pre-Abelian category $\mathcal{C}$ is Abelian if for every morphism $\varphi \in \mathcal{C}_{1}$, the natural morphism
in \eqref{eq:natural_morphism}
\[
\overline{\varphi} := \varepsilon_{\kappa}\backslash \varphi/\kappa_{\varepsilon} : \mathrm{Coim}(\varphi)
\xrightarrow{\sim} \mathrm{Im}(\varphi)
\]
is an isomorphism.
\end{definition}
Therefore in the doctrine of Abelian categories we will not need to distinguish between coimages and images\endnote{Especially
in a skeletal category such as $\kmat$.}, and
the diagrams from \ref{rmk:kerl_col_col_kerl} simplify into an epi-mono factorization diagram.

\begin{corollary}\label{cor:kernel_cokernel_sequence}
Every morphism $\varphi : M \rightarrow N$ in an abelian category $\mathcal{C}$ can be factored as the
composition of an epimorphism $\pi : M \twoheadrightarrow I$ and a monomorphism $\iota : I \hookrightarrow N$\\
where $I \cong \mathrm{Im}(\varphi) \cong \mathrm{Coim}(\varphi)$.
\[
\begin{tikzcd}
K \arrow[rd, "\kappa", hook] &                                                       &                             &                                        & C \\
                             & M \arrow[rr, "\varphi"] \arrow[rd, "\pi"', two heads] &                             & N \arrow[ru, "\varepsilon", two heads] &   \\
                             &                                                       & I \arrow[ru, "\iota", hook] &                                        &  
\end{tikzcd}
\]
The factorization is unique up to unique isomorphism.
\end{corollary}

\begin{definition}[Abelian category]
An \ul{abelian category} is
\begin{itemize}
\item a pre-abelian category $\mathcal{C}$ where
\item every monomorphism $\kappa$ is a kernel-embedding of its cokernel-projection and
\item every epimorphism $\varepsilon$ is a cokernel-projection of  its kernel-embedding.
\end{itemize}
\end{definition}

\begin{remark}
The above definition, that we can regard
\begin{itemize}
\item every monomorphism $\kappa : K \hookrightarrow A$ as a kernel-embedding
of its cokernel-projection $\varepsilon_{\kappa} : A \twoheadrightarrow C$, with $K$ being the kernel object
$\mathrm{Ker}(\varepsilon_{\kappa}) = s(\kappa)$,
\item and every epimorphism
$\varepsilon : B \twoheadrightarrow C$ as a cokernel-projection of its kernel-embedding $\kappa_{\varepsilon} : K \hookrightarrow B$,
with $C$ being the cokernel object $\mathrm{Coker}(\kappa_{\varepsilon}) = t(\varepsilon)$
\end{itemize}
implies that we also have the third ingredient
for kernels and cokernels, namely the dependent functions
\begin{itemize}
\item kernel lift $(-/\kappa) : \underline{\phantom{T}} \rightarrow K$ mapping a morphism $\tau : T \rightarrow A$ with same
target $t(\tau) = t(\kappa) = A$ and same cokernel $\varepsilon_{\kappa} = \varepsilon_{\tau}$ (i.e. $\tau\varepsilon_{\kappa} = 0_{T,C}$)
as $\kappa$ to a unique kernel lift $(\tau / \kappa) : T \rightarrow K$
\[
\begin{tikzcd}
K \arrow[r, "\kappa", hook] \arrow[r, "{0_{K,A}}", bend left, shift left=2]                                & A \arrow[r, "\varepsilon_{\kappa}", two heads] \arrow[r, "\varepsilon_{\tau}"', two heads] & C \\
T \arrow[ru, "{0_{T,A}}"', bend right, shift right=2] \arrow[ru, "\tau"] \arrow[u, "(\tau/\kappa)", dashed] &                                                                                            &  
\end{tikzcd}
\]
\item cokernel colift $(\varepsilon \backslash - ) : C \rightarrow \underline{\phantom{T}}$ mapping a morphism $\tau : B \rightarrow T$ with
same source $s(\tau) = s(\varepsilon) = B$ and same kernel $\kappa_{\varepsilon} = \kappa_{\tau}$
(i.e. $\kappa_{\varepsilon}\tau = 0_{K,T}$)  as $\varepsilon$ to a unique cokernel
colift $(\varepsilon \backslash \tau) : C \rightarrow T$.
\[
\begin{tikzcd}
K \arrow[r, "\kappa_{\varepsilon}", hook] \arrow[r, "\kappa_{\tau}"', hook] & B \arrow[r, "\varepsilon", two heads] \arrow[r, "{0_{B,C}}", bend left, shift left=2] \arrow[rd, "\tau"] \arrow[rd, "{0_{B,T}}"', bend right, shift right=2] & C \arrow[d, "(\varepsilon\backslash\tau)", dashed] \\
                                                                            &                                                                                                                                                   & T                                                 
\end{tikzcd}
\]
\end{itemize}
\end{remark}

The existence of \ul{lifts along monos} and \ul{colifts along epis} (in the sense of the above remark)
in a pre-abelian category is therefore an equivalent definition of an abelian category.

\begin{definition}[Abelian category]\label{def:abelian_category}
An \ul{Abelian category} consists of the following data:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item A pre-abelian category $\mathcal{C}$.
\item A dependent function $( - / - )$ mapping a monomorphism $\kappa : K \hookrightarrow A$ and a morphism $\tau : T \rightarrow A$ with
the same target $t(\tau) = t(\kappa)$ and the same cokernel projection $\varepsilon_{\tau} = \varepsilon_{\kappa}$ to a lift $(\tau / \kappa)$ of
$\tau$ along $\kappa$.
\item A dependent function $( - \backslash - )$ mapping an epimorphism $\varepsilon : B \twoheadrightarrow C$ and a morphism
$\tau : B \rightarrow T$ with same source $s(\tau) = s(\varepsilon)$ and the same kernel embedding $\kappa_{\tau} = \kappa_{\varepsilon}$
to a colift $(\varepsilon \backslash \tau)$ of $\tau$ along $\varepsilon$.
\end{enumerate}
\end{definition}

\begin{doctrine}[Abelian category]
The doctrine $\mathtt{IsAbelianCategory}$ therefore involves algorithms of $\mathtt{IsPreAbelianCategory}$ together
with two additional algorithms
\begin{itemize}
\item $\mathtt{LiftAlongMonomorphism}$,
\item $\mathtt{ColiftAlongEpimorphism}$,
\end{itemize}
fulfilling the specification of definition \ref{def:abelian_category}
\end{doctrine}

\newpage
\subsection{The matrix category $\kmat$ is an abelian category}

The following is an example of a category which has all the limits and colimits mentioned so far, and has them implemented constructively.
We will check the four doctrines $\mathtt{IsAbCategory}$, $\mathtt{IsAdditiveCategory}$, $\mathtt{IsPreAbelianCategory}$ and
$\mathtt{IsAbelianCategory}$ by providing the needed algorithms.

\begin{example}{(The matrix category $\kmat$ over a commutative ring $\Bbbk$)}\label{ex:kmat_skeletal}
\begin{itemize}
\item Objects are natural numbers $\kmat_{0} = \mathbb{N} = \mathbb{N}_{0} = \{0,1,2,\dots\}$ for wich we use small latin letters
($m, n, k,\dots$).
\item Morphisms $(m \rightarrow n) \in \kmat_{1}$ are $m \times n$ matrices over $\Bbbk$.
We write the set of morphisms between $m$ and $n$, as $\Bbbk^{m\times n} := \textup{Hom}_{\kmat}(m,n)$. 
For variables that are Matrices we use small greek letters ($\varphi, \psi,\dots$) or capital latin letters ($A, B, C,\dots$). When only source and target are relevant,
we write $(m \times n)$.
\item $s(\varphi) = \mathtt{Source}(\varphi) := \mathtt{NrRows}(\varphi)$
\item $t(\varphi) = \mathtt{Range}(\varphi) := \mathtt{NrColumns}(\varphi)$
\item Identity morphisms are the identity matrices.
\[
1_{m} = \mathtt{IdentityMorphism}(m) := \mathtt{IdentityMat}(m,\Bbbk).
\]
\item Composition is matrix multiplication which is associative.
\[
\varphi\psi = \mathtt{PreCompose}(\varphi,\psi) := \mathtt{MatMul}(\varphi,\psi).
\]
\item It is a skeletal category, i.e. $m \cong n \Rightarrow m = n$. Only quadratic matrices ($m = n$) can be
isomorphisms.
\end{itemize}
\end{example}

\begin{example}[$\kmat$ is an Ab-category]\label{ex:kmat_pre-additive}
In $\kmat$, the number $0$ is the zero object. $\mathtt{ZeroObject := 0}$\\
A zero matrix (zero morphism) is a matrix factoring through the zero object $0$.\\
\begin{minipage}{.2\textwidth}\phantom{ }\end{minipage}
\begin{minipage}{.25\textwidth}
$\Bbbk^{m\times n} \ni A = 0_{m,n}$
\end{minipage}
\begin{minipage}{.08\textwidth}
$\Longleftrightarrow$
\end{minipage}
\begin{minipage}{.32\textwidth}
\begin{tikzcd}
m \arrow[rr, "A"] \arrow[rd, "(m \times 0)"'] &                               & n \\
                                              & 0 \arrow[ru, "(0 \times n)"'] &  
\end{tikzcd}\\
$\Rightarrow A = (m \times 0) \cdot (0 \times n)$.
\end{minipage}
\begin{minipage}{.15\textwidth}\phantom{ }\end{minipage}\\

\noindent The matrices $(m \times 0)$ and $(0 \times n)$ have zero columns or zero rows respectively, but it is
important to note that for each $m \in \kmat_{0}$ there is exactly one such matrix $(m \times 0)$ and $(0 \times m)$
(that's what initial and terminal object means), and for different $m$, these morphisms are different.\endnote{It is
challenging to decide between different types of zero matrices with zero rows or zero columns, if they
are represented by lists of lists with their entries. How many rows does the $(3 \times 0)$ matrix have, if you represent it
by the empty list \texttt{[ ]}? That's why the implenentation in \homalgProject uses a special function
\texttt{HomalgZeroMatrix}, and why the morphisms in \CAP are always implemented with their source and target defined.}

\begin{itemize}
\item For the matrix $(m \times 0)$ we have\\
$\mathtt{UniversalMorphismIntoZeroObject (m) := ZeroMorphism(m, 0) := ZeroMatrix( m, 0 )}$,
\item For the matrix $(0 \times n)$ we have\\
$\mathtt{UniversalMorphismFromZeroObject (n) := ZeroMorphism(0, n) := ZeroMatrix( 0, n )}$,
\item For zero matrices $(m \times n)$ we write $\mathtt{ZeroMorphism(m, n) := ZeroMatrix( m, n )}$.
\end{itemize}

For two natural numbers $m,n \in {\kmat}_{0} = \mathbb{N} = \mathbb{N}_{0}$, the set of morphisms with source $m$ and target $n$ is
$\Bbbk^{m\times n}$, the set of $m \times n$-matrices. This is an abelian group:
\begin{itemize}
\item The neutral element of the addition is the $m \times n$ zero matrix $0_{m,n}$.
\item Addition of matrices $\mathtt{AdditionForMorphisms( phi, psi ) := phi + psi}$ is associative and commutative.
\item For every matrix $A \in \Bbbk^{m\times n}$ there is a negative matrix $-A \in \Bbbk^{m \times n}$ such that $A + (-A) = 0_{m,n}$.
\end{itemize}
Composition of matrices is defined as matrix multiplication, which is bilinear, i.e. satisfies the distributive laws \eqref{eq:dist1} and
\eqref{eq:dist2}.\\
It is an easy exercise to provide the algorithms for an Ab-category mentioned in doctrine \ref{doc:ab-category}.
\end{example}

\begin{example}[$\kmat$ is an additive category]\label{ex:kmat_additive}
Let for $I = \{1,\dots,N\},$ the set $\{n_{1},\dots,n_{N}\}$ be a family of objects in $\kmat_{0}$. Their direct sum is
\begin{itemize}
\item the object $n := \bigoplus_{i=1}^{N} n_{i} := \sum_{i=1}^{N} n_{i} = \mathtt{Sum}$
\item For $i \in I$ we have as identity morphism $1_{n_{i}}$ of the object $n_{i}$ the $n_{i} \times n_{i}$ identity matrix.
Define
\[
n_{<i} := \sum_{j=1}^{i-1} n_{j}\quad \text{ and }\quad n_{>i} := \sum_{j=i+1}^{N} n_{j}.
\]
Then we have
\item The projection $\pi_{i} : n \rightarrow n_{i}$ is an $n \times n_{i}$ matrix that is a stacked matrix of the $n_{j}\times n_{i}$
zero matrices not including $0_{n_{i},n_{i}}$ and the identity matrix $1_{n_{i}}$.
\begin{align}
\pi_{i} = \label{eq:projection_direct_sum_matrix}
\begin{pmatrix}
0_{n_{1},\,n_{i}} \\
0_{n_{2},\,n_{i}} \\
\vdots \\
0_{n_{i-1},\,n_{i}} \\
1_{n_{i}} \\
0_{n_{i+1},\,n_{i}} \\
\vdots \\
0_{n_{N},\,n_{i}}
\end{pmatrix}
=
\begin{pmatrix}
0_{n_{<i},\,n_{i}} \\
1_{n_{i}} \\
0_{n_{>i},\,n_{i}}
\end{pmatrix}
\end{align}
\item The coprojection $\iota_{i} : n_{i} \rightarrow n$ is the transposed matrix $\iota_{i} = \pi_{i}^{T}$, i.e. an $n_{i} \times n$ matrix of
the $n_{i} \times n_{j}$ zero matrices not including $0_{n_{i},n_{i}}$ and the identity matrix $1_{n_{i}}$ lined up next to each other.
\begin{align}
\iota_{i} = \label{eq:coprojection_direct_sum_matrix}
\begingroup
\setlength\arraycolsep{2pt}
\begin{pmatrix}
0_{n_{i},n_{1}} & 0_{n_{i},n_{2}} & \dots & 0_{n_{i},n_{i-1}} & 1_{n_{i}} & 0_{n_{i},n_{i+1}} & \dots & 0_{n_{i},n_{N}}
\end{pmatrix}
= \begin{pmatrix}
0_{n_{i},\,n_{<i}} & 1_{n_{i}} & 0_{n_{i},\,n_{>i}}
\end{pmatrix} \endgroup
\end{align}

\item For a family $\tau = (\tau_{i} : t \rightarrow n_{i})_{i\in I}$ we have the morphism $u_{\text{in}}(\tau)$ which is a $t \times n$ block matrix of
the $\tau_{i}$:
\begin{align}
u_{\text{in}}(\tau) = \label{eq:u_in_direct_sum_matrix}
\begin{pmatrix}
\tau_{1} & \cdots & \tau_{N}
\end{pmatrix}
\end{align}
with $u_{\text{in}}(\tau) \pi_{i} = \tau_{i}$.
\item For a family $\tau = (\tau_{i} : n_{i} \rightarrow t)_{i \in I}$ we have the morphism $u_{\text{out}}(\tau)$ which is an $n \times t$ block matrix
of the $\tau_{i}$:
\begin{align}
u_{\text{out}}(\tau) = \label{eq:u_out_direct_sum_matrix}
\begin{pmatrix}
\tau_{1} \\
\vdots \\
\tau_{N}
\end{pmatrix}
\end{align}
with $\iota_{i} u_{\text{out}}(\tau) = \tau_{i}$.
\end{itemize}
One can easily verify the conditions for $\pi$, $\iota$, $u_{\text{in}}$ and $u_{\text{out}}$ in Definitions \ref{def:biproduct} and \ref{def:direct_sum}.
\end{example}

\begin{computation} 
If we assume algorithms for adding natural numbers
\begin{alignat*}{3}
&\mathtt{Sum}( [ m, n &&] ) = m + n, \\
&\mathtt{Sum}( [  &&] ) = 0,
\end{alignat*}
for stacking two matrices with the same number of columns (same target) on top of each other
\begin{align*}
\varphi &: k \rightarrow n \\
\psi &: m \rightarrow n\\
\mathtt{StackMatrix}( \varphi, \psi ) =
\begin{pmatrix}
\varphi \\
\psi
\end{pmatrix} &: k + m \rightarrow n,
\end{align*}
and for aligning two matrices with the same number of rows (same source) next to each other
\begin{align*}
\varphi &: m \rightarrow k \\
\psi &: m \rightarrow n\\
\mathtt{AugmentMatrix}( \varphi, \psi ) =
\begin{pmatrix}
\varphi & \psi
\end{pmatrix} &: m \rightarrow k + n.
\end{align*}
Together with the algorithms $\mathtt{IdentityMorphism( n )}$ and $\mathtt{ZeroMorphism( m, n )}$ from $\mathtt{IsAbCategory}$
we can then calculate all the algorithms in the doctrine $\mathtt{IsAdditiveCategory}$:

The direct sum of the objects $\mathtt{D := [ V1, V2, \dots, VN ]}$ in $\kmat$ is defined as
\begin{itemize}
\item \texttt{DirectSum ( D ) := VectorSpaceObject( Sum( List( D, V $\mapsto$ Dimension( V ) ) ), k )}
\item \texttt{ProjectionInFactorOfDirectSum( D, i ) := StackMatrix( [ \\
\phantom{x}\hspace{3ex}List( D[1, \dots, (i-1)], V $\mapsto$ ZeroMorphism( V, D[i] ) ), \\
\phantom{x}\hspace{3ex}IdentityMorphism( D[i] ), \\
\phantom{x}\hspace{3ex}List( D[(i+1), \dots, N], V $\mapsto$ ZeroMorphism( V, D[i] ) ) ] )}
\item \texttt{InjectionOfCofactorOfDirectSum( D, i ) := AugmentMatrix( [ \\
\phantom{x}\hspace{3ex}List( D[1, \dots, (i-1)], V $\mapsto$ ZeroMorphism( D[i], V ) ), \\
\phantom{x}\hspace{3ex}IdentityMorphism( D[i] ), \\
\phantom{x}\hspace{3ex}List( D[(i+1), \dots, N], V $\mapsto$ ZeroMorphism( D[i], V ) ) ] )}
\item \texttt{UniversalMorphismIntoDirectSum( [ phi, psi ] ) := StackMatrix( [ phi, psi ] )}
\item \texttt{UniversalMorphismFromDirectSum( [ phi, psi ] ) := AugmentMatrix( [ phi, psi ] )}
\end{itemize}

In the following \Gap{} session, we demonstrate the algorithms of $\mathtt{IsAdditiveCategory}$ and verify in
an example the two axioms of the direct sum in \ref{def:direct_sum}. To verify two these properties for a general case
of a direct sum of objects in the matrix category is left as an exercise.

The implementation of objects in the matrix category $\kmat$ in \textsc{Cap} is slightly different than simply natural numbers, since
we always have to mention the commutative ring $\Bbbk$ for the objects. We are using the finite field
$\Bbbk := \mathbb{F}_{3}$ for our calculations below.
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@LoadPackage("LinearAlgebraForCAP");|
  true
  !gapprompt@gap>| !gapinput@GF3 := HomalgRingOfIntegers( 3 );|
  GF(3)
  !gapprompt@gap>| !gapinput@V3 := VectorSpaceObject( 3, GF3 );|
  <A vector space object over GF(3) of dimension 3>
  !gapprompt@gap>| !gapinput@V5 := VectorSpaceObject( 5, GF3 );|
  <A vector space object over GF(3) of dimension 5>
  !gapprompt@gap>| !gapinput@V2 := VectorSpaceObject( 2, GF3 );|
  <A vector space object over GF(3) of dimension 2>
  !gapprompt@gap>| !gapinput@D := [ V3, V5, V2 ];|
  [ <A vector space object over GF(3) of dimension 3>,
    <A vector space object over GF(3) of dimension 5>,
    <A vector space object over GF(3) of dimension 2> ]
  !gapprompt@gap>| !gapinput@S := DirectSum( D );|
  <A vector space object over GF(3) of dimension 10>
  !gapprompt@gap>| !gapinput@zero35 := ZeroMorphism( V3, V5 );|
  <A zero morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( zero35 );|
   . . . . .
   . . . . .
   . . . . .
   
   A zero morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@one5 := IdentityMorphism( V5 );|
  <An identity morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( one5 );|
   1 . . . .
   . 1 . . .
   . . 1 . .
   . . . 1 .
   . . . . 1
   
   An identity morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@zero25 := ZeroMorphism( V2, V5 );|
  <A zero morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( zero25 );|
   . . . . .
   . . . . .
   
   A zero morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@pi2 := ProjectionInFactorOfDirectSum( D, 2 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( pi2 );|
   . . . . .
   . . . . .
   . . . . .
   1 . . . .
   . 1 . . .
   . . 1 . .
   . . . 1 .
   . . . . 1
   . . . . .
   . . . . .
  
  A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@iota1 := InjectionOfCofactorOfDirectSum( D, 1 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( iota1 );|
   1 . . . . . . . . .
   . 1 . . . . . . . .
   . . 1 . . . . . . .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@Display( PreCompose( iota1, pi2 ) );|
   . . . . .
   . . . . .
   . . . . .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@IsEqualForMorphisms( PreCompose( iota1, pi2 ), ZeroMorphism( V3, V5 ) );|
  true
  !gapprompt@gap>| !gapinput@iota2 := InjectionOfCofactorOfDirectSum( D, 2 );;|
  !gapprompt@gap>| !gapinput@Display( iota2 );|
   . . . 1 . . . . . .
   . . . . 1 . . . . .
   . . . . . 1 . . . .
   . . . . . . 1 . . .
   . . . . . . . 1 . .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@Display( PreCompose( iota2, pi2 ) );|
   1 . . . .
   . 1 . . .
   . . 1 . .
   . . . 1 .
   . . . . 1
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@IsEqualForMorphisms( PreCompose( iota2, pi2 ), IdentityMorphism( V5 ) );|
  true
  !gapprompt@gap>| !gapinput@Display( PreCompose( pi2, iota2 ) );|
   . . . . . . . . . .
   . . . . . . . . . .
   . . . . . . . . . .
   . . . 1 . . . . . .
   . . . . 1 . . . . .
   . . . . . 1 . . . .
   . . . . . . 1 . . .
   . . . . . . . 1 . .
   . . . . . . . . . .
   . . . . . . . . . .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@iota3 := InjectionOfCofactorOfDirectSum( D, 3 );;|
  !gapprompt@gap>| !gapinput@pi1 := ProjectionInFactorOfDirectSum( D, 1 );;|
  !gapprompt@gap>| !gapinput@pi3 := ProjectionInFactorOfDirectSum( D, 3 );;|
  !gapprompt@gap>| !gapinput@Display( PreCompose( pi1, iota1 ) + PreCompose( pi2, iota2 )|
  !gapprompt@>| !gapinput@   + PreCompose( pi3, iota3 ) );|
   1 . . . . . . . . .
   . 1 . . . . . . . .
   . . 1 . . . . . . .
   . . . 1 . . . . . .
   . . . . 1 . . . . .
   . . . . . 1 . . . .
   . . . . . . 1 . . .
   . . . . . . . 1 . .
   . . . . . . . . 1 .
   . . . . . . . . . 1
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@IsEqualForMorphisms(|
  !gapprompt@>| !gapinput@     PreCompose( pi1, iota1 )|
  !gapprompt@>| !gapinput@   + PreCompose( pi2, iota2 )|
  !gapprompt@>| !gapinput@   + PreCompose( pi3, iota3 ),|
  !gapprompt@>| !gapinput@   IdentityMorphism( S ) );|
  true
\end{Verbatim}

We can also verify the result in \ref{rmk:addition_derived_from_direct_sum} that the abelian group operation
$\mathtt{AdditionForMorphisms}$ can be derived from $\mathtt{UniversalMorphismIntoDirectSum}$,
$\mathtt{UniversalMorphismFromDirectSum}$,\\
$\mathtt{IdentityMorphism}$ and
$\mathtt{PreCompose}$. As an example we add two $\mathrm{GF}_{3}$-matrices from $\mathtt{V2}$ to $\mathtt{V3}$ in three
different ways.

\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@mat1 := HomalgMatrix( [ 0, 1, 2, 1, 1, 2 ], 2, 3, GF3 );|
  <A 2 x 3 matrix over an internal ring>
  !gapprompt@gap>| !gapinput@mat2 := HomalgMatrix( [ 1, 1, 1, 1, 1, 1 ], 2, 3, GF3 );|
  <A 2 x 3 matrix over an internal ring>
  !gapprompt@>| !gapinput@mor1 := VectorSpaceMorphism( V2, mat1, V3 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( mor1 );|
   . 1 2
   1 1 2
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@>| !gapinput@mor2 := VectorSpaceMorphism( V2, mat2, V3 );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( mor2 );|
   1 1 1
   1 1 1
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@>| !gapinput@result1 := mor1 + mor2;|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( result1 );|
   1 2 .
   2 2 .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@one2 := IdentityMorphism( V2 );|
  <An identity morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@result2 := PreCompose( UniversalMorphismIntoDirectSum( [ one2, one2 ] ),|
  !gapprompt@>| !gapinput@   UniversalMorphismFromDirectSum( [ mor1, mor2 ] ) );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( result2 );|
   1 2 .
   2 2 .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@result1 = result2;|
  true
  !gapprompt@gap>| !gapinput@one3 := IdentityMorphism( V3 );|
  <An identity morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@result3 := PreCompose( UniversalMorphismIntoDirectSum( [ mor1, mor2 ] ),|
  !gapprompt@>| !gapinput@  UniversalMorphismFromDirectSum( [ one3, one3 ] ) );|
  <A morphism in Category of matrices over GF(3)>
  !gapprompt@gap>| !gapinput@Display( result3 );|
   1 2 .
   2 2 .
   
   A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@result3 = result2;|
  true
\end{Verbatim}
\end{computation}

Next we provide the algorithms from \ref{doc:pre-abelian} that make $\kmat$ into a pre-abelian category.
They are all based on the well-known $\mathtt{Gauss}$ algorithm that gives us the row echolon form (REF) and
the column echolon form (CEF) of a matrix.

\begin{computation}\label{comp:gauss-algorithms}
Let $\varphi : m \rightarrow n \in \kmat_{1}$ be a matrix. We assume algorithms for 
\begin{itemize}
\item The rank of a matrix, $r := \mathtt{Rank( phi )}$, defined as $\Bbbk$-dimension of the column space
$\mathrm{dim_{Col}}\,( \varphi ) = r$ which is the
same\endnote{The result ``row-rank = column-rank'' whose importance a first-year student might not understand
right away, is a very nice property of matrices.}
as the $\Bbbk$-dimension of the row space $\mathrm{dim_{Row}}( \varphi ) = r$,
\item The left nullspace of a matrix $\varphi$ is a matrix $x = \mathtt{LeftNullSpace( phi )}$ satisfying $x\, \varphi = 0$ and
for each matrix $y$ with $y\,\varphi = 0$ there exists a matrix $z$ with $zx = y$.
\item The right nullspace of a matrix $\varphi$ is a matrix $x = \mathtt{RightNullSpace( phi )}$ satisfying $\varphi \,x= 0$ and
for each matrix $y$ with $\varphi \,y= 0$ there exists a matrix $z$ with $xz = y$.
\item As the standardized form to represent these subspaces, the $\mathtt{Gauss}$-algorithm can calculate the
row-echolon-form $\mathtt{REF( LeftNullSpace( phi ) )}$ and the\\
column-echolon-form $\mathtt{CEF( RightNullSpace( phi ) )}$.
\end{itemize}
\end{computation}

\begin{example}[$\kmat$ is a pre-abelian category]\label{ex:kmat_pre-abelian}
With the algorithms in \ref{comp:gauss-algorithms} taken as given, we now give all the algorithms needed for the doctrine
$\mathtt{IsPreAbelianCategory}$ in \ref{doc:pre-abelian}:
\begin{itemize}
\item $\mathtt{KernelObject( phi ) := NrRows( phi ) - Rank( phi )}$
\item $\mathtt{KernelEmbedding( phi ) := REF( LeftNullSpace( phi ) )}$
\item $\mathtt{KernelLift( phi, tau ) := Solve( x \cdot REF( LeftNullSpace( phi ) ) = tau )}$
\item $\mathtt{CokernelObject( phi ) := NrColumns( phi ) - Rank( phi )}$
\item $\mathtt{CokernelProjection( phi ) := CEF( RightNullSpace( phi ) )}$
\item $\mathtt{CokernelColift( phi, tau ) := Solve( CEF( RightNullSpace( phi ) ) \cdot x = tau )}$
\end{itemize}
With these constructions, $\kmat$ becomes a pre-abelian category.
\end{example}

Note that the right-hand side $B$ in the equation 
\[
A \cdot x = B
\]
can be more than a single column vector, but a matrix with multiple columns, as long as they have the same number of rows as $A$.
This corresponds to solving the system of equations simultaneously for different right-hand sides. In case that it is solvable,
we get a particular solution as a matrix $x = \mathtt{LeftDivide( A, B )}$.

Dually for $B$ and $A$ matrices having the same number of columns, for the equation
\[
x \cdot A = B
\]
we get a particular solution as a matrix $x = \mathtt{RightDivide( B, A )}$, if it exists.

\begin{example}[$\kmat$ is an Abelian category]\phantom{}\\
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item Let $\kappa : K \hookrightarrow A \in \kmat_{1}$ and $\tau : T \rightarrow A \in \kmat_{1}$ be as in
\ref{def:abelian_category}(2).
Then with the algorithms from \ref{comp:gauss-algorithms} we define
\begin{itemize}
\item $\mathtt{LiftAlongMonomorphism( kappa, tau ) := Solve( x \cdot kappa = tau )}$\\
$\mathtt{ := RightDivide( tau, kappa )}$.
\end{itemize}
\item Let $\varepsilon : B \twoheadrightarrow C \in \kmat_{1}$ and $\tau : B \rightarrow T \in \kmat_{1}$ be as in
\ref{def:abelian_category}(3).
Then with the algorithms from \ref{comp:gauss-algorithms} we define
\begin{itemize}
\item $\mathtt{ColiftAlongEpimorphism( epsilon, tau ) := Solve( epsilon \cdot x = tau )}$\\
$\mathtt{ := LeftDivide( epsilon, tau )}$
\end{itemize}
\end{enumerate}

Since a matrix $\kappa : m \rightarrow n$ is a monomorphism iff its kernel is $0$ iff it has full row rank $\mathtt{Rank(kappa) = m}$,
the lift along monomorphism $\mathtt{RightDivide( tau, kappa )}$ always exists.

Since a matrix $\varepsilon : m \rightarrow n$ is an epimorphism iff its image is $n$ iff it has full column rank
$\mathtt{Rank(kappa) = n}$, the colift along epimorphism $\mathtt{LeftDivide( epsilon, tau )}$ always exists.

With these algorithms, $\kmat$ becomes an abelian category. In particular we have
\begin{align*}
\mathrm{Coim}(\varphi) &\cong \mathrm{Im}(\varphi)\quad\text{and since $\kmat$ is skeletal}\\
\Rightarrow\, \mathrm{Coim}(\varphi) &=\mathrm{Im}(\varphi).
\end{align*}
\end{example}


The following situation where we have a family of matrices $\{a_{i} : m_{i} \rightarrow n_{i}\}_{i\in I}$,
i.e. a family $\{m_{i}\}_{i\in I}$ of sources and $\{n_{i}\}_{i\in I}$ of targets, is useful to understand. There are two
different direct sums involved, one of the $m_{i}$'s and one of the $n_{i}$'s. We will need this construction in section 4
for the direct sum of functors, and in section 6 for the Sylvester equations.

\begin{example}[Block-Diagonal matrices]\phantom{}\label{ex:block_diagonal_matrix}\\
In a situation with an index set $I = \{1,\dots,N\}$, two families of objects $\{m_{i}\}_{i\in I}, \{n_{i}\}_{i\in I}$ and a family of
morphisms $\{a_{i} : m_{i} \rightarrow n_{i}\}_{i\in I}$ in $\kmat$, we have the two direct sums
\begin{alignat}{4}
m &:= \bigoplus_{i\in I} m_{i},\quad &&(\pi_{i})_{m} : m \rightarrow m_{i},\quad &&(\iota_{i})_{m} : m_{i} \rightarrow m, \\
n &:= \bigoplus_{i\in I} n_{i},\quad &&(\pi_{i})_{n} : n \rightarrow n_{i},\quad &&(\iota_{i})_{n} : n_{i} \rightarrow n.
\end{alignat}
This situation is displayed in the following diagram
\[
\begin{tikzcd}
m \arrow[dd, "(\pi_{i})_{m}", shift left=2] \arrow[rr, "a"]           &  & n \arrow[dd, "(\pi_{i})_{n}", shift left=2]       \\
                                                                      &  &                                                   \\
m_{i} \arrow[uu, "(\iota_{i})_{m}", shift left=2] \arrow[rr, "a_{i}"] &  & n_{i} \arrow[uu, "(\iota_{i})_{n}", shift left=2]
\end{tikzcd}
\]
The morphism $a : m \rightarrow n$ defined as
\begin{align}
a = \sum_{i \in I} (\pi_{i})_{m} a_{i} (\iota_{i})_{n}
\end{align}
satisfies
\begin{align}
(\iota_{i})_{m}\, a &= a_{i}\, (\iota_{i})_{n}, \\
a\, (\pi_{i})_{n} &= (\pi_{i})_{m}\, a_{i}\,\text{ and }\\
(\iota_{i})_{m}\, a\, (\pi_{i})_{n} &= a_{i}.
\end{align}
This an be interpreted in two ways:
\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item For the family $\iota_{m} a := \{ (\iota_{i})_{m} a : m_{i} \rightarrow n \} := \{ a_{i}\,(\iota_{i})_{n} : m_{i} \rightarrow n \}$
of morphisms with same target $n$, we have the morphism
$u_{\text{out}}(\iota_{m} a) : m \rightarrow n$ such that\\
$(\iota_{i})_{m} u_{\text{out}}(\iota_{m} a) = (\iota_{i})_{m} a = a_{i}\,(\iota_{i})_{n}$, and
\item For the family $a \pi_{n} := \{ a (\pi_{i})_{n} : m \rightarrow n_{i} \} := \{ (\pi_{i})_{m}\,a_{i} : m \rightarrow n_{i} \}$ of
morphisms with same source $m$, we have the morphism
$u_{\text{in}}(a \pi_{n}) : m \rightarrow n$ such that\\
$u_{\text{in}}(a \pi_{n}) (\pi_{i})_{n} = a (\pi_{i})_{n} = (\pi_{i})_{m}\,a_{i}$.
\end{enumerate}
So we have
\begin{alignat}{3}
(\iota_{i})_{m} u_{\text{out}}(\iota_{m} a) (\pi_{i})_{n} &= a_{i} &&= (\iota_{i})_{m} u_{\text{in}}(a \pi_{n}) (\pi_{i})_{n}\,
\text{ and }\\
u_{\text{out}}(\iota_{m} a) &= a &&= u_{\text{in}}(a \pi_{n})
\end{alignat}
\end{example}

%%% functors between abelian categories.

\begin{theorem}
The functor category has all limits, colimits and bilimits which exist in the target category.
\end{theorem}

Instead of proving this in general, we prove this as part of \ref{thm:functor_category_abelian} for the direct sum, from which
the procedure of the general proof becomes apparent.

