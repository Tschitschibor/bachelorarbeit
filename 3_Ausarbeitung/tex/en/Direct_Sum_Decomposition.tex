
We have shown in section \ref{sect:abelian_cat} that for a family $\{F_{i}\}_{i\in I}$ of functors in $\HomAkmat$, there is the
direct sum $F := \bigoplus_{i\in I} F_{i}$ with embeddings $\iota_{i} : F_{i} \rightarrow F$ (and projections $\pi_{i} : F \rightarrow F_{i}$).
In this section we show constructively the other direction, i.e. that for each $F$ there is a direct sum decomposition
$\{F_{i}\}_{i\in I}$ and $\iota_{i} : F_{i} \rightarrow F$ such that
\[
F = \bigoplus_{i\in I} F_{i}
\]

\subsection{The algorithm $\mathtt{WeakDirectSumDecomposition}$}

\begin{algorithm}[H]\capstart
    \caption{\texttt{WeakDirectSumDecomposition}}\label{algo:WeakDirectSumDecomposition}
	\SetKwInput{Input}{Input~}
	\SetKwInput{Output}{Output~}
	\Input{~a functor $F$ in a functor category}
	\Output{~a list $[\iota_i : F_{i} \rightarrow F]$ of coprojections such that $\oplus_{i \in I} F_{i} = F$ and each $F_{i}$ is indecomposable.}
	\BlankLine
	let $\mathtt{queue} := [ 1_{F} ]$\;
	let $\mathtt{summands} := [ \quad ]$\;
	
	\While{ $\mathtt{queue} \neq \emptyset$ }{
	    let $\eta$ be the latest element in $\mathtt{queue}$\;
	    delete $\eta$ from $\mathtt{queue}$\;
	    \eIf{$s(\eta)$ is indecomposable by $\mathtt{DecomposeOnceByRandomEndomorphism}$}{
	        add $\eta$ to $\mathtt{summands}$\;
	    }{
	        $[\iota,\kappa] = \mathtt{DecomposeOnceByRandomEndomorphism}(s(\eta))$\;
	        append $[\iota\eta, \kappa\eta]$ to $\mathtt{queue}$\;
	    }
	}
	\BlankLine
	\Return $\mathtt{summands}$\;
\end{algorithm}

\begin{lemma}
\algoref{WeakDirectSumDecomposition} terminates with the correct output.
\end{lemma}
\begin{proof} We assert certain truths about the algorithm by formulating invariants, and how they stay constant in each line of the algorithm.\\

\noindent In line 1, the morphism $1_{F} : F \rightarrow F$, which is initially the only morphism in $\mathtt{queue}$, satisfies $t(1_{F}) = F$.\\
In line 10, provided $\iota : I \rightarrow s(\eta)$ and $\kappa : K \rightarrow s(\eta)$ are each composable with $\eta$, then we are
appending the list $[\iota\eta, \kappa\eta]$ of morphisms with target $t(\iota\eta) = t(\kappa\eta) = F$ to the $\mathtt{queue}$.\\
Thus in each step of the algorithm the $\mathtt{queue}$ only contains morphisms $\eta$ with target $t(\eta) = F$.\\

\noindent In line 2, the list $\mathtt{summands}$ is initially empty.\\
In line 7, we add a morphism $\eta$ from the $\mathtt{queue}$ to the list $\mathtt{summands}$ only if
in line 6 we checked that $s(\eta)$ is indecomposable.\\
Thus in each step of the algorithm the list $\mathtt{summands}$ only contains indecomposable morphisms with target $F$.\\

\noindent Initially with $\mathtt{queue} = [1_{F}]$ and $\mathtt{summands} = \emptyset$ we have
\begin{align}
F = \label{eq:direct_sum_decomposition}
\bigoplus_{\eta \in \mathtt{queue}} s(\eta) \oplus \bigoplus_{\varphi \in \mathtt{summands}} s(\varphi)
\end{align}
For the first run of the while loop we take $\eta_{1} := 1_{F}$ from the $\mathtt{queue}$. Then there are two possibilities:\\
If $F$ was indecomposable, we now add $\eta_{1}$ to $\mathtt{summands}$, and have $\mathtt{queue} = \emptyset$ and
$\mathtt{summands} = [1_{F}]$ which also satisfy \eqref{eq:direct_sum_decomposition}.\\
Otherwise we get a decomposition of $F$ with $\iota_{1} : I_{1} \rightarrow F$ and $\kappa_{1} : K_{1} \rightarrow F$. In this case
$\mathtt{summands}$ stays empty, and instead we have $\mathtt{queue} = [\iota_{1}\eta_{1}, \kappa_{1}\eta_{1}]$. Since
$\eta_{1} = 1_{F}$, that's the same as $\mathtt{queue} = [\iota_{1},\kappa_{1}]$. (In the following steps we can't assume the
$\eta \in \mathtt{queue}$ to be the identity). For \eqref{eq:direct_sum_decomposition} to hold, we need to prove that
\[
I_{1} \oplus K_{1} = F
\]
which is exactly what we show for the output of $\mathtt{DecomposeOnceByRandomEndomorphism}$.


If in the first run of the while loop, $s(\eta) = s(1_{F}) = F$ was decomposable with $[\iota,\kappa]$ in line 9, then

In line 9, the output $[\iota, \kappa]$ of $\mathtt{DecomposeOnceByRandomEndomorphism}(s(\eta))$ satisfies
$s(\iota) \oplus s(\kappa) = t(\eta)$ which we still have to show.\\

Thus in each step, equation \eqref{eq:direct_sum_decomposition} holds.\\

\end{proof}

$\kappa = \mathrm{KernelEmbedding}(\alpha)$ with $\alpha^{2} = \alpha$ and $\alpha : F \rightarrow F$ an endomorphism.


\[
\begin{tikzcd}
                                                          &                                                                                   &                                                          & F                                                      &                                                           &                                                                                       &                                                          \\
                                                          & F \arrow[rru, "\eta_{1}", bend left]                                              &                                                          &                                                        &                                                           & F \arrow[llu, "\eta_{1}"', bend right]                                                &                                                          \\
                                                          & I_{1} \arrow[u, "\iota_{1}"] \arrow[rr, dash] \arrow[rruu, "\iota_{1}\eta_{1}"] &                                                          & \bigoplus \arrow[uu, "I_{1} \oplus K_{1}" description] &                                                           & K_{1} \arrow[u, "\kappa_{1}"'] \arrow[ll, dash] \arrow[lluu, "\kappa_{1}\eta_{1}"'] &                                                          \\
I_{1} \arrow[ru, "\eta_{11}"', bend left=49, shift right] &                                                                                   & I_{1} \arrow[lu, "\eta_{11}", bend right=49, shift left] &                                                        & K_{1} \arrow[ru, "\eta_{12}"', bend left=49, shift right] &                                                                                       & K_{1} \arrow[lu, "\eta_{12}", bend right=49, shift left] \\
I_{11} \arrow[u, "\iota_{11}"] \arrow[r, dash]          & \bigoplus \arrow[uu, "I_{11}\oplus K_{11}" description]                           & K_{11} \arrow[u, "\kappa_{11}"] \arrow[l, dash]        &                                                        & I_{12} \arrow[u, "\iota_{12}"] \arrow[r, dash]          & \bigoplus \arrow[uu, "I_{12} \oplus K_{12}" description]                              & K_{12} \arrow[u, "\kappa_{12}"'] \arrow[l, dash]      
\end{tikzcd}
\]



Invariant:

In each step:

\[
F = \bigoplus_{\eta \in \mathtt{queue}} s(\eta) \oplus \bigoplus_{\varphi \in \mathtt{summands}} s(\varphi).
\]

When $\mathtt{queue} = \emptyset$, then
\[
F = \bigoplus_{\varphi \in \mathtt{summands}} s(\varphi).
\]

Why is $\mathtt{queue}$ going to be $\emptyset$?

$5 = 4+1 = 2+2+1 = 2+2+1$.

In each step we remove the last $\eta$ from the $\mathtt{queue}$. If $s(\eta)$ was indecomposable, it doesn't get replaced, i.e.
$\mathtt{queue}$ becomes smaller by 1. If $s(\eta)$ was decomposable, we replace $\eta$ by $\iota\eta$ and $\kappa\eta$ with

\begin{align}
\iota : I \rightarrow s(\eta) \\
\kappa : K \rightarrow s(\eta)
\end{align}
and in some sense
\begin{align}
I \preceq s(\eta) \\
K \preceq s(\eta)
\end{align}
Which sense?
\begin{align}
I \oplus K &= s(\eta) \\
s(\eta)(i) &= (I \oplus K)(i) = I(i) + K(i)\, \forall i \in \mathcal{A}_{0}
\end{align}
Since $\iota \neq 0$ and $\kappa \neq 0$, $I \neq 0$ and $K \neq 0$, so for some objects $i,j \in \mathcal{A}_{0}$ we have
$I(i) > 0$ and $K(j) > 0$, and thus $s(\eta)(i) > 0$ for some $i$.

For all objects $i\in \mathcal{A}_{0}$ $I(i) \leq s(\eta)(i)$ and $K(i) \leq s(\eta)(i)$.

$\mathtt{queue} := \{1_{F}\} \mapsto \{\iota 1_{F}, \kappa 1_{F}\} = \{\iota, \kappa \}
\mapsto \{ \iota_{1}\iota, \kappa_{1}\iota, \iota_{2}\kappa, \kappa_{2}\kappa \}$

\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item We are starting with a trivial decomposition $\iota : F \rightarrow F$, i.e. the embedding $\iota = 1_{F}$ is
our only morphism in the queue.
\item In each step we take a morphism $\eta : s(\eta) \rightarrow F$ from the queue and try to decompose $s(\eta)$
with $\mathtt{DecomposeOnceByRandomEndomorphism}(s(\eta))$ (see next section).
\item If it fails, i.e. the functor $s(\eta)$ was already indecomposable, then we add $\eta$ to our resulting list of $\mathtt{summands}$ and
remove $\eta$ from the queue.
\item Otherwise, we get a decomposition of $s(\eta)$ into an $\mathrm{ImageEmbedding}( \alpha )$ and $\mathrm{KernelEmbedding}( \alpha )$
for some endomorphism $\alpha : s(\eta) \rightarrow s(\eta)$, i.e. embeddings $\iota : I \rightarrow s(\eta)$ and $\kappa : K \rightarrow s(\eta)$
with $I \oplus K = s(\eta)$.
\item We then replace $\eta$ in our queue with the two morphisms $\iota \eta : I \rightarrow F$ and $\kappa \eta : K \rightarrow F$.
\item The morphisms in our queue are therefore always morphisms with target $F$, but the sources $I$ and $K$ get more and more
decomposed.
\item If $\mathtt{DecomposeOnceByRandomEndomorphism}(s(\eta))$ fails for all $\eta$ in our queue, we are finished and output the list
$\mathtt{summands}$ of our embeddings $\iota_{i} : F_{i} \rightarrow F$, from which we can get the direct sum decomposition
$F_{i} = s(\iota_{i}),\, i\in I$, i.e. $F = \bigoplus_{i\in I} F_{i}$.
\end{enumerate}


Input: Functor $F$.\\
Output: Tupel $(\mathrm{ImageEmbedding}( \alpha ), \mathrm{KernelEmbedding}( \alpha ) )$

such that
\[
\begin{tikzcd}
                                       & F &                                         \\
s(\eta) \arrow[ru, "\eta", bend left=49]     &   & s(\eta) \arrow[lu, "\eta"', bend right=49]    \\
I \arrow[u, "\iota"] &   & K \arrow[u, "\kappa"']
\end{tikzcd}
\]
and
\[
F = I \oplus K
\]

When we input I and K into DecomposeOnce, we get a further decomposition:
\[
\begin{tikzcd}
                                                 &                                                &                                                  & F &                                                  &                                                 &                                                   \\
                                                 & F \arrow[rru, "\eta_{1}", bend left]           &                                                  &   &                                                  & F \arrow[llu, "\eta_{1}"', bend right]          &                                                   \\
                                                 & I_{1} \arrow[u, "\mathrm{ImgEmb}(\alpha_{1})"] &                                                  &   &                                                  & K_{1} \arrow[u, "\mathrm{KerEmb}(\alpha_{1})"'] &                                                   \\
I_{1} \arrow[ru, "\eta_{11}", bend left=49]      &                                                & I_{1} \arrow[lu, "\eta_{11}", bend right=49]     &   & K_{1} \arrow[ru, "\eta_{12}", bend left=49]      &                                                 & K_{1} \arrow[lu, "\eta_{12}", bend right=49]      \\
I_{11} \arrow[u, "\mathrm{ImgEmb}(\alpha_{11})"] &                                                & K_{11} \arrow[u, "\mathrm{KerEmb}(\alpha_{11})"] &   & I_{12} \arrow[u, "\mathrm{ImgEmb}(\alpha_{12})"] &                                                 & K_{12} \arrow[u, "\mathrm{KerEmb}(\alpha_{12})"']
\end{tikzcd}
\]

The direct sum decomposition in each step looks like this:

\[
\begin{tikzcd}
                                                                   &                                                                   &                                                                    & F                                                      &                                                                    &                                                                    &                                                                     \\
                                                                   & F \arrow[rru, "\eta_{1}", bend left]                              &                                                                    &                                                        &                                                                    & F \arrow[llu, "\eta_{1}"', bend right]                             &                                                                     \\
                                                                   & I_{1} \arrow[u, "\mathrm{ImgEmb}(\alpha_{1})"] \arrow[rr, dash] &                                                                    & \bigoplus \arrow[uu, "I_{1} \oplus K_{1}" description] &                                                                    & K_{1} \arrow[u, "\mathrm{KerEmb}(\alpha_{1})"'] \arrow[ll, dash] &                                                                     \\
I_{1} \arrow[ru, "\eta_{11}"', bend left=49, shift right]           &                                                                   & I_{1} \arrow[lu, "\eta_{11}", bend right=49, shift left]           &                                                        & K_{1} \arrow[ru, "\eta_{12}"', bend left=49, shift right]                        &                                                                    & K_{1} \arrow[lu, "\eta_{12}", bend right=49, shift left]                        \\
I_{11} \arrow[u, "\mathrm{ImgEmb}(\alpha_{11})"] \arrow[r, dash] & \bigoplus \arrow[uu, "I_{11}\oplus K_{11}" description]           & K_{11} \arrow[u, "\mathrm{KerEmb}(\alpha_{11})"] \arrow[l, dash] &                                                        & I_{12} \arrow[u, "\mathrm{ImgEmb}(\alpha_{12})"] \arrow[r, dash] & \bigoplus \arrow[uu, "I_{12} \oplus K_{12}" description]           & K_{12} \arrow[u, "\mathrm{KerEmb}(\alpha_{12})"'] \arrow[l, dash]
\end{tikzcd}
\]
That is we have 
\begin{alignat}{5}
F &=  &&I_{1} &&\oplus &&K_{1} \\
F &= (I_{11} &&\oplus K_{11}) &&\oplus (I_{12} &&\oplus K_{12})
\end{alignat}


\subsection{The algorithm $\mathtt{DecomposeOnceByRandomEndomorphism}$}

\begin{algorithm}[H]\capstart
    \caption{\texttt{DecomposeOnceByRandomEndomorphism}}\label{algo:DecomposeOnceByRandomEndomorphism}
	\SetKwInput{Input}{Input~}
	\SetKwInput{Output}{Output~}
	\Input{~a functor $F$ in a functor category}
	\Output{~a pair $[\iota : I \rightarrow F, \kappa : K \rightarrow F]$ of morphisms such that $I \oplus K = F$ or
	$\mathtt{fail}$ if $F$ was indecomposable}
	\BlankLine
	let $d := \max \{ \mathrm{dim}_{\Bbbk}Fc \}_{c \in \mathcal{A}}$\;
	let $\mathcal{B} = [\beta_{1},\dots,\beta_{\mathrm{Length}(\mathcal{B})}]$ be a $\Bbbk$-basis of $\mathrm{Hom}_{\HomAkmat}(F,F)$\;
	add $0_{F,F}$ to $\mathcal{B}$\;
	let $n := \log_{2}(d) + 1$\;
	\BlankLine
	\For{$b \in [\mathrm{Length}(\mathcal{B}),\mathrm{Length}(\mathcal{B}) - 1,\dots,2]$}{
	    let $\alpha := \beta_{b} + \mathrm{random}(\Bbbk) \beta_{b-1}$\;
	    \For{$i \in [ 1, \dots, n ]$}{
	        $\alpha_{2} := \alpha^{2}$\;
	        \If{$\alpha = \alpha_{2}$}{
	            \Break\;
	        }
	        $\alpha := \alpha_{2}$\;
	    }
	    \BlankLine
	    
	    \If{$\alpha = 0$}{
	        \Continue\;
	    }
	    
	    $\kappa := \mathrm{KernelEmbedding}(\alpha)$\;
	    
	    \If{$\kappa = 0$}{
	        \Continue\;
	    }
	    \BlankLine
	    $\iota := \mathrm{ImageEmbedding}(\alpha)$\;
	    \Return $[ \iota, \kappa ]$\;
	}
	\BlankLine
	\Return $\mathtt{fail}$\;
\end{algorithm}




\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item Let $F \neq 0$ be a functor in $\HomAkmat$. Then there is a maximum dimension $d := \max_{i \in \mathcal{A}_{0}} \mathrm{dim}\, F(i)$ with
$d \geq 1$.
\item The vector space $\mathrm{Hom}_{\HomAkmat}(F,F) = \mathrm{End}_{\HomAkmat}(F)$ is finite-dimensional, i.e. we can find a
finite basis $\mathtt{endbas}$ of our external hom using the algorithm $\mathtt{BasisOfExternalHom}(F,F)$. Since $F \neq 0$, the
identity morphism $1_{F}$ 
\item If $\mathrm{End}_{\HomAkmat}(F)$ has dimension 1, i.e. each morphism in $\mathrm{End}_{\HomAkmat}(F)$ is of the form
$\lambda \alpha$ for some $\lambda \in \Bbbk$ and the one $\alpha \in \mathtt{endbas}$, then $\alpha = 1_{F}$ is the identity morphism.
In this case, 

The process $\alpha \mapsto \alpha^{2}$ will end when for some $k \in \mathbb{N},\, \alpha^{2^{k+1}} = \alpha^{2^{k}},$ i.e.
$\alpha^{2^{k}+2^{k}} = \alpha^{2^{k}}$ which is the $\sigma$-lemma with $m = n = 2^{k}$.

\end{enumerate}

The algorithm $\mathtt{DecomposeOnceByRandomEndomorphism}$ will terminate without $\mathtt{fail}$ only if
\[
\mathrm{ImgEmb}(\alpha) \neq 0\,\text{ and }\, \mathrm{KerEmb}(\alpha) \neq 0
\]
for some $\alpha$.

When we have $\mathrm{ImgEmb}(\alpha) = 0$ or $\mathrm{KerEmb}(\alpha) = 0$ for all $\alpha : F \rightarrow F$, we have
\begin{alignat}{4}
&F &&= \{0\} &&\oplus K\quad\text{ or }\\
&F &&= I &&\oplus \{0\},
\end{alignat}
i.e. F was indecomposable.



\begin{tikzcd}
F1 \arrow["Fa"', loop, distance=2em, in=125, out=55] \arrow[rr, "Fb"] \arrow[dd, "\eta_{1}"]
&  & F2 \arrow["Fc"', loop, distance=2em, in=125, out=55] \arrow[dd, "\eta_{2}"] \\
&  &                                                                                 \\
G1 \arrow["Ga"', loop, distance=2em, in=305, out=235] \arrow[rr, "Gb"]
&  & G2 \arrow["Gc"', loop, distance=2em, in=305, out=235]
\end{tikzcd}

\begin{align}
Fa\,\eta_{1} &= \eta_{1} Ga \\
Fb\,\eta_{2} &= \eta_{1} Gb \\
Fc\,\eta_{2} &= \eta_{2} Gc
\end{align}

For the first equation we have

\begin{align}
Fa\,\eta_{1} - \eta_{1} Ga = 0
\end{align}

thus

\begin{align}
\left( Fa\,\eta_{1} - \eta_{1} Ga \right)_{i,j} = 0,\, 1\leq i \leq 5, 1\leq j \leq 3
\end{align}

Sylvester equations

\texttt{BasisOfExternalHom}
\texttt{WeakDirectSumDecomposition}

InstallMethod( DecomposeOnceByRandomEndomorphism,
        "for an object in a Hom-category",
        [ IsCapCategoryObjectInHomCategory ],
        
  function( F )
    local d, n, endbas, k, b, alpha, i, alpha2, keremb;
    
    d := Maximum( List( ValuesOnAllObjects( F ), Dimension ) );
    
    endbas := ShallowCopy( BasisOfExternalHom( F, F ) );
    
    Add( endbas, ZeroMorphism( F, F ) );
    
    k := CommutativeRingOfLinearCategory( CapCategory( F ) );
    
    n := Int( Log2( Float( d ) ) ) + 1;
    
    for b in Reversed( [ 2 .. Length( endbas ) ] ) do
        
        alpha := endbas[b] + Random( k ) * endbas[b-1];
        
        SetFilterObj( alpha, IsMultiplicativeElementWithInverse );
        
        for i in [ 1 .. n ] do
            alpha2 := PreCompose( alpha, alpha );
            if IsCongruentForMorphisms( alpha, alpha2 ) then
                break;
            fi;
            alpha := alpha2;
        od;
        
        if IsZero( alpha ) then
            continue;
        fi;
        
        keremb := KernelEmbedding( alpha );
        
        if IsZero( keremb ) then
            continue;
        fi;
        
        return [ ImageEmbedding( alpha ), keremb ];
        
    od;
    
    return fail;
    
end );


InstallMethod( WeakDirectSumDecomposition,
        "for an object in a Hom-category",
        [ IsCapCategoryObjectInHomCategory ],
        
  function( F )
    local queue, summands, eta, result;
    
    queue := [ IdentityMorphism( F ) ];
    
    summands := [ ];
    
    while not IsEmpty( queue ) do
        
        eta := Remove( queue );
        
        result := DecomposeOnceByRandomEndomorphism( Source( eta ) );
        
        if result = fail then
            Add( summands, eta );
        else
            Append( queue, List( result, emb -> PreCompose( emb, eta ) ) );
        fi;
        
    od;
    
    return summands;
    
end );



















