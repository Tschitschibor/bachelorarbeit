
We have shown in section \ref{sect:abelian_cat} that for a family $\{F_{i}\}_{i\in I}$ of functors in $\HomAkmat$, there is the
direct sum $F := \bigoplus_{i\in I} F_{i}$ with embeddings $\iota_{i} : F_{i} \rightarrow F$ (and projections $\pi_{i} : F \rightarrow F_{i}$).
In this section we show constructively the other direction, i.e. that for each $F$ there is a direct sum decomposition
$\{F_{i}\}_{i\in I}$ and $\iota_{i} : F_{i} \rightarrow F$ such that
\[
F = \bigoplus_{i\in I} F_{i}
\]

\subsection{The algorithm $\mathtt{WeakDirectSumDecomposition}$}

\begin{algorithm}[H]\capstart
    \caption{\texttt{WeakDirectSumDecomposition}}\label{algo:WeakDirectSumDecomposition}
	\SetKwInput{Input}{Input~}
	\SetKwInput{Output}{Output~}
	\Input{~a functor $F$ in a functor category}
	\Output{~a list $[\eta_i : F_{i} \rightarrow F]$ of coprojections such that $\oplus_{i} F_{i} = F$ and each $F_{i}$ is indecomposable.}
	\BlankLine
	let $\mathtt{queue} := [ 1_{F} ]$\;
	let $\mathtt{summands} := [ \quad ]$\;
	
	\While{ $\mathtt{queue} \neq \emptyset$ }{
	    let $\eta$ be the latest element in $\mathtt{queue}$\;
	    delete $\eta$ from $\mathtt{queue}$\;
	    \eIf{$s(\eta)$ is indecomposable by $\mathtt{DecomposeOnceByRandomEndomorphism}$}{
	        add $\eta$ to $\mathtt{summands}$\;
	    }{
	        $[\iota,\kappa] = \mathtt{DecomposeOnceByRandomEndomorphism}(s(\eta))$\;
	        append $[\iota\eta, \kappa\eta]$ to $\mathtt{queue}$\;
	    }
	}
	\BlankLine
	\Return $\mathtt{summands}$\;
\end{algorithm}

\begin{lemma}
\algoref{WeakDirectSumDecomposition} terminates with the correct output.
\end{lemma}
\begin{proof} We assert certain truths about the algorithm by formulating invariants, and how they stay constant in each line of the algorithm.\\

\begin{subproof}[Proof that the output is correct]\phantom{}\\
\noindent In line 1, the morphism $1_{F} : F \rightarrow F$, which is initially the only morphism in $\mathtt{queue}$, satisfies $t(1_{F}) = F$.\\
In line 10, since $\iota : I \rightarrow s(\eta)$ and $\kappa : K \rightarrow s(\eta)$ are each composable with $\eta$, then we are
appending the list $[\iota\eta, \kappa\eta]$ of morphisms with target $t(\iota\eta) = t(\kappa\eta) = F$ to the $\mathtt{queue}$.\\
Thus in each step of the algorithm the $\mathtt{queue}$ only contains morphisms $\eta$ with target $t(\eta) = F$.\\

\noindent In line 2, the list $\mathtt{summands}$ is initially empty.\\
In line 7, we add a morphism $\eta$ from the $\mathtt{queue}$ to the list $\mathtt{summands}$ only if
in line 6 we checked that $s(\eta)$ is indecomposable.\\
Thus in each step of the algorithm the list $\mathtt{summands}$ only contains indecomposable morphisms with target $F$.\\

\noindent Initially with $\mathtt{queue} = [1_{F}]$ and $\mathtt{summands} = \emptyset$ we have
\begin{align}
F = \label{eq:direct_sum_decomposition}
\bigoplus_{\eta \in \mathtt{queue}} s(\eta) \oplus \bigoplus_{\eta \in \mathtt{summands}} s(\eta)
\end{align}
For the first run of the while loop we take $\eta_{1} := 1_{F}$ from the $\mathtt{queue}$. Then there are two possibilities:\\
If $F$ was indecomposable, we now add $\eta_{1}$ to $\mathtt{summands}$, and have $\mathtt{queue} = \emptyset$ and
$\mathtt{summands} = [1_{F}]$ which also satisfies \eqref{eq:direct_sum_decomposition}.\\
Otherwise we get a decomposition of $F$ with $\iota_{1} : I_{1} \rightarrow F$ and $\kappa_{1} : K_{1} \rightarrow F$. In this case
$\mathtt{summands}$ stays empty, and instead we have $\mathtt{queue} = [\iota_{1}\eta_{1}, \kappa_{1}\eta_{1}]$. Since
$\eta_{1} = 1_{F}$, that's the same as $\mathtt{queue} = [\iota_{1},\kappa_{1}]$. (In the following steps we can't assume the
$\eta \in \mathtt{queue}$ to be the identity). For \eqref{eq:direct_sum_decomposition} to hold, we need to prove that
\[
I_{1} \oplus K_{1} = F
\]
which is exactly what we assert for the output of $\mathtt{DecomposeOnceByRandomEndomorphism}$.\\
Thus after the first while loop, equation \eqref{eq:direct_sum_decomposition} holds.\\
In each run of the while loop, we are replacing $I_{j}$ with $I_{j,1}$ and $K_{j,1}$ with $I_{j} = I_{j,1} \oplus K_{j,1}$ and
$K_{j}$ with $I_{j,2} \oplus K_{j,2}$. That is we have 
\begin{alignat}{5}
F &=  &&I_{1} &&\oplus &&K_{1} \\
&= (I_{11} &&\oplus K_{11}) &&\oplus (I_{12} &&\oplus K_{12})
\end{alignat}

With the $\mathtt{queue} = \emptyset$ and $\mathtt{summands}$ containing only $\eta$ with indecomposable $s(\eta)$,
equation \eqref{eq:direct_sum_decomposition} becomes
\begin{align}
F = \bigoplus_{\eta \in \mathtt{summands}} s(\eta)
\end{align}
\end{subproof}

\begin{subproof}[Proof that the algorithm terminates]\phantom{}\\
\noindent In each run of the while loop, a morphism $\eta$ from the $\mathtt{queue}$ gets either deleted and not replaced,
since $s(\eta)$ was indecomposable, or it gets deleted and replaced by two morphisms $[\iota\eta, \kappa\eta]$.\\
If at some point, $s(\eta)$ is indecomposable for every $\eta \in \mathtt{queue}$, then the $\eta$ will be deleted from the
$\mathtt{queue}$ (and added to $\mathtt{summands}$) until the $\mathtt{queue}$ is empty. Then the while loop will end.\\

\noindent The case that each $\eta$ gets replaced by $[\iota\eta, \kappa\eta]$ where again the $s(\iota\eta)$ and $s(\kappa\eta)$ are
decomposable must come to an end after a finite number of steps:\\

\noindent Whenever $G := s(\eta)$ is decomposable with $I \oplus K = G$, we have
\begin{align}
Gc = (I \oplus K)c = Ic \oplus Kc = Ic + Kc \,\forall c \in \mathcal{A}_{0} \\
d_{G} :=\max_{c \in \mathcal{A}_{0}} Gc = \max_{c \in \mathcal{A}_{0}} Ic + Kc \\
d_{I} := \max_{c \in \mathcal{A}_{0}} Ic > 0 \\
d_{K} := \max_{c \in \mathcal{A}_{0}} Kc > 0 \\
0 < d_{I} \leq d_{G} \leq d_{I} + d_{K} \\
0 < d_{K} \leq d_{G} \leq d_{I} + d_{K} \\
0 < d_{I} < d_{G} \\
0 < d_{K} < d_{G}
\end{align}
Thus with each step where $\eta : G \rightarrow F$ gets replaced with $\iota\eta : I \rightarrow F$ and $\kappa\eta : K \rightarrow F$,
both $d_{I} < d_{G}$ and $d_{K} < d_{G}$,
and both have the lower bound of $0$. Thus after a finite number of steps there are only $\eta$ with indecomposable $s(\eta)$ in the $\mathtt{queue}$
so that by the above result, $\mathtt{queue}$ will eventually become empty.
\end{subproof}
\end{proof}


\[
\begin{tikzcd}
                                                          &                                                                                   &                                                          & F                                                      &                                                           &                                                                                       &                                                          \\
                                                          & F \arrow[rru, "\eta_{1}", bend left]                                              &                                                          &                                                        &                                                           & F \arrow[llu, "\eta_{1}"', bend right]                                                &                                                          \\
                                                          & I_{1} \arrow[u, "\iota_{1}"] \arrow[rr, dash] \arrow[rruu, "\iota_{1}\eta_{1}"] &                                                          & \bigoplus \arrow[uu, "I_{1} \oplus K_{1}" description] &                                                           & K_{1} \arrow[u, "\kappa_{1}"'] \arrow[ll, dash] \arrow[lluu, "\kappa_{1}\eta_{1}"'] &                                                          \\
I_{1} \arrow[ru, "\eta_{11}"', bend left=49, shift right] &                                                                                   & I_{1} \arrow[lu, "\eta_{11}", bend right=49, shift left] &                                                        & K_{1} \arrow[ru, "\eta_{12}"', bend left=49, shift right] &                                                                                       & K_{1} \arrow[lu, "\eta_{12}", bend right=49, shift left] \\
I_{11} \arrow[u, "\iota_{11}"] \arrow[r, dash]          & \bigoplus \arrow[uu, "I_{11}\oplus K_{11}" description]                           & K_{11} \arrow[u, "\kappa_{11}"] \arrow[l, dash]        &                                                        & I_{12} \arrow[u, "\iota_{12}"] \arrow[r, dash]          & \bigoplus \arrow[uu, "I_{12} \oplus K_{12}" description]                              & K_{12} \arrow[u, "\kappa_{12}"'] \arrow[l, dash]      
\end{tikzcd}
\]



Invariant:

In each step:

\[
F = \bigoplus_{\eta \in \mathtt{queue}} s(\eta) \oplus \bigoplus_{\varphi \in \mathtt{summands}} s(\varphi).
\]

When $\mathtt{queue} = \emptyset$, then
\[
F = \bigoplus_{\varphi \in \mathtt{summands}} s(\varphi).
\]

Why is $\mathtt{queue}$ going to be $\emptyset$?

$5 = 4+1 = 2+2+1 = 2+2+1$.

In each step we remove the last $\eta$ from the $\mathtt{queue}$. If $s(\eta)$ was indecomposable, it doesn't get replaced, i.e.
$\mathtt{queue}$ becomes smaller by 1. If $s(\eta)$ was decomposable, we replace $\eta$ by $\iota\eta$ and $\kappa\eta$ with

\begin{align}
\iota : I \rightarrow s(\eta) \\
\kappa : K \rightarrow s(\eta)
\end{align}
and in some sense
\begin{align}
I \preceq s(\eta) \\
K \preceq s(\eta)
\end{align}
Which sense?
\begin{align}
I \oplus K &= s(\eta) \\
s(\eta)(i) &= (I \oplus K)(i) = I(i) + K(i)\, \forall i \in \mathcal{A}_{0}
\end{align}
Since $\iota \neq 0$ and $\kappa \neq 0$, $I \neq 0$ and $K \neq 0$, so for some objects $i,j \in \mathcal{A}_{0}$ we have
$I(i) > 0$ and $K(j) > 0$, and thus $s(\eta)(i) > 0$ for some $i$.

For all objects $i\in \mathcal{A}_{0}$ $I(i) \leq s(\eta)(i)$ and $K(i) \leq s(\eta)(i)$.

$\mathtt{queue} := \{1_{F}\} \mapsto \{\iota 1_{F}, \kappa 1_{F}\} = \{\iota, \kappa \}
\mapsto \{ \iota_{1}\iota, \kappa_{1}\iota, \iota_{2}\kappa, \kappa_{2}\kappa \}$


Input: Functor $F$.\\
Output: Tupel $(\mathrm{ImageEmbedding}( \alpha ), \mathrm{KernelEmbedding}( \alpha ) )$

such that
\[
\begin{tikzcd}
                                       & F &                                         \\
s(\eta) \arrow[ru, "\eta", bend left=49]     &   & s(\eta) \arrow[lu, "\eta"', bend right=49]    \\
I \arrow[u, "\iota"] &   & K \arrow[u, "\kappa"']
\end{tikzcd}
\]
and
\[
F = I \oplus K
\]

When we input I and K into DecomposeOnce, we get a further decomposition:
\[
\begin{tikzcd}
                                                 &                                                &                                                  & F &                                                  &                                                 &                                                   \\
                                                 & F \arrow[rru, "\eta_{1}", bend left]           &                                                  &   &                                                  & F \arrow[llu, "\eta_{1}"', bend right]          &                                                   \\
                                                 & I_{1} \arrow[u, "\mathrm{ImgEmb}(\alpha_{1})"] &                                                  &   &                                                  & K_{1} \arrow[u, "\mathrm{KerEmb}(\alpha_{1})"'] &                                                   \\
I_{1} \arrow[ru, "\eta_{11}", bend left=49]      &                                                & I_{1} \arrow[lu, "\eta_{11}", bend right=49]     &   & K_{1} \arrow[ru, "\eta_{12}", bend left=49]      &                                                 & K_{1} \arrow[lu, "\eta_{12}", bend right=49]      \\
I_{11} \arrow[u, "\mathrm{ImgEmb}(\alpha_{11})"] &                                                & K_{11} \arrow[u, "\mathrm{KerEmb}(\alpha_{11})"] &   & I_{12} \arrow[u, "\mathrm{ImgEmb}(\alpha_{12})"] &                                                 & K_{12} \arrow[u, "\mathrm{KerEmb}(\alpha_{12})"']
\end{tikzcd}
\]

The direct sum decomposition in each step looks like this:

\[
\begin{tikzcd}
                                                                   &                                                                   &                                                                    & F                                                      &                                                                    &                                                                    &                                                                     \\
                                                                   & F \arrow[rru, "\eta_{1}", bend left]                              &                                                                    &                                                        &                                                                    & F \arrow[llu, "\eta_{1}"', bend right]                             &                                                                     \\
                                                                   & I_{1} \arrow[u, "\mathrm{ImgEmb}(\alpha_{1})"] \arrow[rr, dash] &                                                                    & \bigoplus \arrow[uu, "I_{1} \oplus K_{1}" description] &                                                                    & K_{1} \arrow[u, "\mathrm{KerEmb}(\alpha_{1})"'] \arrow[ll, dash] &                                                                     \\
I_{1} \arrow[ru, "\eta_{11}"', bend left=49, shift right]           &                                                                   & I_{1} \arrow[lu, "\eta_{11}", bend right=49, shift left]           &                                                        & K_{1} \arrow[ru, "\eta_{12}"', bend left=49, shift right]                        &                                                                    & K_{1} \arrow[lu, "\eta_{12}", bend right=49, shift left]                        \\
I_{11} \arrow[u, "\mathrm{ImgEmb}(\alpha_{11})"] \arrow[r, dash] & \bigoplus \arrow[uu, "I_{11}\oplus K_{11}" description]           & K_{11} \arrow[u, "\mathrm{KerEmb}(\alpha_{11})"] \arrow[l, dash] &                                                        & I_{12} \arrow[u, "\mathrm{ImgEmb}(\alpha_{12})"] \arrow[r, dash] & \bigoplus \arrow[uu, "I_{12} \oplus K_{12}" description]           & K_{12} \arrow[u, "\mathrm{KerEmb}(\alpha_{12})"'] \arrow[l, dash]
\end{tikzcd}
\]
That is we have 
\begin{alignat}{5}
F &=  &&I_{1} &&\oplus &&K_{1} \\
F &= (I_{11} &&\oplus K_{11}) &&\oplus (I_{12} &&\oplus K_{12})
\end{alignat}


\subsection{The algorithm $\mathtt{DecomposeOnceByRandomEndomorphism}$}

\begin{algorithm}[H]\capstart
    \caption{\texttt{DecomposeOnceByRandomEndomorphism}}\label{algo:DecomposeOnceByRandomEndomorphism}
	\SetKwInput{Input}{Input~}
	\SetKwInput{Output}{Output~}
	\Input{~a functor $F$ in a functor category}
	\Output{~a pair $[\iota : I \rightarrow F, \kappa : K \rightarrow F]$ of morphisms such that $I \oplus K = F$ with $I \neq 0$ and $K \neq 0$ or
	$\mathtt{fail}$ if $F$ was indecomposable}
	\BlankLine
	let $d := \max \{ \mathrm{dim}_{\Bbbk}Fc \}_{c \in \mathcal{A}_{0}}$\;
	\If{$d = 0$}{
	    \Return $\mathtt{fail}$\;
	}
	let $\mathcal{B} = [\beta_{1},\dots,\beta_{\mathrm{Length}(\mathcal{B})}]$ be a $\Bbbk$-basis of $\mathrm{Hom}_{\HomAkmat}(F,F)$\;
	add $0_{F,F}$ to $\mathcal{B}$\;
	let $n := \log_{2}(d) + 1$\;
	\BlankLine
	\For{$b \in [\mathrm{Length}(\mathcal{B}),\mathrm{Length}(\mathcal{B}) - 1,\dots,2]$}{
	    let $\alpha := \beta_{b} + \mathrm{random}(\Bbbk) \beta_{b-1}$\;
	    \For{$i \in [ 1, \dots, n ]$}{
	        $\alpha_{2} := \alpha^{2}$\;
	        \If{$\alpha = \alpha_{2}$}{
	            \Break\;
	        }
	        $\alpha := \alpha_{2}$\;
	    }
	    \BlankLine
	    
	    \If{$\alpha = 0$}{
	        \Continue\;
	    }
	    
	    $\kappa := \mathrm{KernelEmbedding}(\alpha)$\;
	    
	    \If{$\kappa = 0$}{
	        \Continue\;
	    }
	    \BlankLine
	    $\iota := \mathrm{ImageEmbedding}(\alpha)$\;
	    \Return $[ \iota, \kappa ]$\;
	}
	\BlankLine
	\Return $\mathtt{fail}$\;
\end{algorithm}

\begin{lemma}
\algoref{DecomposeOnceByRandomEndomorphism} terminates with the correct output.
\end{lemma}
\begin{proof} We assert certain truths about the algorithm by formulating invariants, and how they stay constant in each line of the algorithm.\\

\noindent For the input $F = 0$ we have $Fc = 0\,\forall c \in \mathcal{A}$ and thus $d = 0$ which returns $\mathtt{fail}$, i.e. there is no
decomposition $0 = I \oplus K$ with $I \neq 0$ and $K \neq 0$.\\

\noindent For any other input $F \neq 0$ there is a $c \in \mathcal{A}_{0}$ with $Fc > 0$, thus in line 1 we have $d > 0$.\\
Since $F \neq 0$ we also have $1_{F} \neq 0_{F,F}$, thus after line 6 we can assume $\mathrm{Length}(\mathcal{B}) \geq 2$ and
the list $[\mathrm{Length}(\mathcal{B}),\mathrm{Length}(\mathcal{B}) - 1,\dots,2]$ in line 8 to be nonempty, thus we will enter the for loop
at least once.\\

\noindent In line 9, the endomorphism $\alpha$ is a linear combination of $\beta_{b}$ and $\beta_{b-1}$. Note that for the initial
$b = \mathrm{Length}(\mathcal{B})$, we have $\beta_{b} = 0_{F,F}$ and, as we added the zero morphism last.\\
Without loss of generality, we can assume that $\alpha_{c}$ is in Jordan normal form for each $c \in \mathcal{A}$.
\end{proof}



\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item Let $F \neq 0$ be a functor in $\HomAkmat$. Then there is a maximum dimension $d := \max_{i \in \mathcal{A}_{0}} \mathrm{dim}\, F(i)$ with
$d \geq 1$.
\item The vector space $\mathrm{Hom}_{\HomAkmat}(F,F) = \mathrm{End}_{\HomAkmat}(F)$ is finite-dimensional, i.e. we can find a
finite basis $\mathtt{endbas}$ of our external hom using the algorithm $\mathtt{BasisOfExternalHom}(F,F)$. Since $F \neq 0$, the
identity morphism $1_{F}$ 
\item If $\mathrm{End}_{\HomAkmat}(F)$ has dimension 1, i.e. each morphism in $\mathrm{End}_{\HomAkmat}(F)$ is of the form
$\lambda \alpha$ for some $\lambda \in \Bbbk$ and the one $\alpha \in \mathtt{endbas}$, then $\alpha = 1_{F}$ is the identity morphism.
In this case, 

The process $\alpha \mapsto \alpha^{2}$ will end when for some $k \in \mathbb{N},\, \alpha^{2^{k+1}} = \alpha^{2^{k}},$ i.e.
$\alpha^{2^{k}+2^{k}} = \alpha^{2^{k}}$ which is the $\sigma$-lemma with $m = n = 2^{k}$.

\end{enumerate}

The algorithm $\mathtt{DecomposeOnceByRandomEndomorphism}$ will terminate without $\mathtt{fail}$ only if
\[
\mathrm{ImgEmb}(\alpha) \neq 0\,\text{ and }\, \mathrm{KerEmb}(\alpha) \neq 0
\]
for some $\alpha$.

When we have $\mathrm{ImgEmb}(\alpha) = 0$ or $\mathrm{KerEmb}(\alpha) = 0$ for all $\alpha : F \rightarrow F$, we have
\begin{alignat}{4}
&F &&= \{0\} &&\oplus K\quad\text{ or }\\
&F &&= I &&\oplus \{0\},
\end{alignat}
i.e. F was indecomposable.



\begin{tikzcd}
F1 \arrow["Fa"', loop, distance=2em, in=125, out=55] \arrow[rr, "Fb"] \arrow[dd, "\eta_{1}"]
&  & F2 \arrow["Fc"', loop, distance=2em, in=125, out=55] \arrow[dd, "\eta_{2}"] \\
&  &                                                                                 \\
G1 \arrow["Ga"', loop, distance=2em, in=305, out=235] \arrow[rr, "Gb"]
&  & G2 \arrow["Gc"', loop, distance=2em, in=305, out=235]
\end{tikzcd}

\begin{align}
Fa\,\eta_{1} &= \eta_{1} Ga \\
Fb\,\eta_{2} &= \eta_{1} Gb \\
Fc\,\eta_{2} &= \eta_{2} Gc
\end{align}

For the first equation we have

\begin{align}
Fa\,\eta_{1} - \eta_{1} Ga = 0
\end{align}

thus

\begin{align}
\left( Fa\,\eta_{1} - \eta_{1} Ga \right)_{i,j} = 0,\, 1\leq i \leq 5, 1\leq j \leq 3
\end{align}

Sylvester equations

\texttt{BasisOfExternalHom}
\texttt{WeakDirectSumDecomposition}

InstallMethod( DecomposeOnceByRandomEndomorphism,
        "for an object in a Hom-category",
        [ IsCapCategoryObjectInHomCategory ],
        
  function( F )
    local d, n, endbas, k, b, alpha, i, alpha2, keremb;
    
    d := Maximum( List( ValuesOnAllObjects( F ), Dimension ) );
    
    endbas := ShallowCopy( BasisOfExternalHom( F, F ) );
    
    Add( endbas, ZeroMorphism( F, F ) );
    
    k := CommutativeRingOfLinearCategory( CapCategory( F ) );
    
    n := Int( Log2( Float( d ) ) ) + 1;
    
    for b in Reversed( [ 2 .. Length( endbas ) ] ) do
        
        alpha := endbas[b] + Random( k ) * endbas[b-1];
        
        SetFilterObj( alpha, IsMultiplicativeElementWithInverse );
        
        for i in [ 1 .. n ] do
            alpha2 := PreCompose( alpha, alpha );
            if IsCongruentForMorphisms( alpha, alpha2 ) then
                break;
            fi;
            alpha := alpha2;
        od;
        
        if IsZero( alpha ) then
            continue;
        fi;
        
        keremb := KernelEmbedding( alpha );
        
        if IsZero( keremb ) then
            continue;
        fi;
        
        return [ ImageEmbedding( alpha ), keremb ];
        
    od;
    
    return fail;
    
end );


InstallMethod( WeakDirectSumDecomposition,
        "for an object in a Hom-category",
        [ IsCapCategoryObjectInHomCategory ],
        
  function( F )
    local queue, summands, eta, result;
    
    queue := [ IdentityMorphism( F ) ];
    
    summands := [ ];
    
    while not IsEmpty( queue ) do
        
        eta := Remove( queue );
        
        result := DecomposeOnceByRandomEndomorphism( Source( eta ) );
        
        if result = fail then
            Add( summands, eta );
        else
            Append( queue, List( result, emb -> PreCompose( emb, eta ) ) );
        fi;
        
    od;
    
    return summands;
    
end );



















