For a finite dimensional algebra $A$ over a field $k$ we define its decomposition algebroid $A^\mathrm{dec}$ as the $k$-linear full subcategory of $A\mathrm{-mod}$ consisting of the summands of a direct sum decomposition of $A$ in indecomposables, which are necessarily projective $A$-modules. The additive closure $A^\mathrm{dec}_\oplus$ of the algebroid $A^\mathrm{dec}$ is then the closure of $A$ (considered as a linear category on one object) under direct sums and direct summands (in $A\mathrm{-mod}$). One recovers $A$ as the direct sum of the $\mathrm{Hom}$-groups of $A^\mathrm{dec}$. If $A^\mathrm{sdec}$ is a skeleton of $A^\mathrm{dec}$, then the direct sum of $\mathrm{Hom}$-groups of $A^\mathrm{sdec}$ is the basic algebra which is Morita-equivalent to $A$.

The category $A^\mathrm{dec}_\oplus \simeq A^\mathrm{sdec}_\oplus$ is a model for the additive full subcategory of projective objects in $A\mathrm{-mod}$, where the second model is skeletal.

We model $A\mathrm{-mod}$ as the functor category $[A^\mathrm{op}, k\mathrm{-vec}]$, where $A^\mathrm{op}$ is the opposite algebra of $A$ (viewed as an algebroid with one object), and $k\mathrm{-vec}$ is the (skeletal) Abelian category of finite dimensional $k$-vector spaces. This is equivalent to the category of representations of the quiver underlying the algebroid $(A^\mathrm{op})^\mathrm{dec} \simeq (A^\mathrm{dec})^\mathrm{op}$. The identification of $A^\mathrm{dec}$ with the $k$-linear full subcategory of indecomposable projective objects in the Abelian category $A\mathrm{-mod} := [A^\mathrm{op}, k\mathrm{-vec}] \simeq [(A^\mathrm{op})^\mathrm{dec}, k\mathrm{-vec}] \simeq [(A^\mathrm{dec})^\mathrm{op}, k\mathrm{-vec}]$ is then nothing but Yoneda's embedding. This embedding factors over the embedding $A^\mathrm{dec}_\oplus \hookrightarrow [(A^\mathrm{dec})^\mathrm{op}, k\mathrm{-vec}] \simeq A\mathrm{-mod}$.








\begin{tikzcd}
F1 \arrow["Fa"', loop, distance=2em, in=125, out=55] \arrow[rr, "Fb"] \arrow[dd, "\eta_{1}"]
&  & F2 \arrow["Fc"', loop, distance=2em, in=125, out=55] \arrow[dd, "\eta_{2}"] \\
&  &                                                                                 \\
G1 \arrow["Ga"', loop, distance=2em, in=305, out=235] \arrow[rr, "Gb"]
&  & G2 \arrow["Gc"', loop, distance=2em, in=305, out=235]
\end{tikzcd}

\begin{align}
Fa\,\eta_{1} &= \eta_{1} Ga \\
Fb\,\eta_{2} &= \eta_{1} Gb \\
Fc\,\eta_{2} &= \eta_{2} Gc
\end{align}

For the first equation we have

\begin{align}
Fa\,\eta_{1} - \eta_{1} Ga = 0
\end{align}

thus

\begin{align}
\left( Fa\,\eta_{1} - \eta_{1} Ga \right)_{i,j} = 0,\, 1\leq i \leq 5, 1\leq j \leq 3
\end{align}

Sylvester equations

\texttt{BasisOfExternalHom}
\texttt{WeakDirectSumDecomposition}

InstallMethod( DecomposeOnceByRandomEndomorphism,
        "for an object in a Hom-category",
        [ IsCapCategoryObjectInHomCategory ],
        
  function( F )
    local d, n, endbas, k, b, alpha, i, alpha2, keremb;
    
    d := Maximum( List( ValuesOnAllObjects( F ), Dimension ) );
    
    endbas := ShallowCopy( BasisOfExternalHom( F, F ) );
    
    Add( endbas, ZeroMorphism( F, F ) );
    
    k := CommutativeRingOfLinearCategory( CapCategory( F ) );
    
    n := Int( Log2( Float( d ) ) ) + 1;
    
    for b in Reversed( [ 2 .. Length( endbas ) ] ) do
        
        alpha := endbas[b] + Random( k ) * endbas[b-1];
        
        SetFilterObj( alpha, IsMultiplicativeElementWithInverse );
        
        for i in [ 1 .. n ] do
            alpha2 := PreCompose( alpha, alpha );
            if IsCongruentForMorphisms( alpha, alpha2 ) then
                break;
            fi;
            alpha := alpha2;
        od;
        
        if IsZero( alpha ) then
            continue;
        fi;
        
        keremb := KernelEmbedding( alpha );
        
        if IsZero( keremb ) then
            continue;
        fi;
        
        return [ ImageEmbedding( alpha ), keremb ];
        
    od;
    
    return fail;
    
end );


InstallMethod( WeakDirectSumDecomposition,
        "for an object in a Hom-category",
        [ IsCapCategoryObjectInHomCategory ],
        
  function( F )
    local queue, summands, eta, result;
    
    queue := [ IdentityMorphism( F ) ];
    
    summands := [ ];
    
    while not IsEmpty( queue ) do
        
        eta := Remove( queue );
        
        result := DecomposeOnceByRandomEndomorphism( Source( eta ) );
        
        if result = fail then
            Add( summands, eta );
        else
            Append( queue, List( result, emb -> PreCompose( emb, eta ) ) );
        fi;
        
    od;
    
    return summands;
    
end );



















