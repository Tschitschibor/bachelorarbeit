
We have shown in section \ref{sect:abelian_cat} that for a family $\{F_{i}\}_{i\in I}$ of functors in $\HomAkmat$, there is the
direct sum $F := \bigoplus_{i\in I} F_{i}$ with embeddings $\iota_{i} : F_{i} \rightarrow F$ (and projections $\pi_{i} : F \rightarrow F_{i}$).
In this section we show constructively the other direction, i.e. that for each $F$ there is a direct sum decomposition
$\{F_{i}\}_{i\in I}$ and $\iota_{i} : F_{i} \rightarrow F$ such that
\[
F = \bigoplus_{i\in I} F_{i}
\]

\subsection{The algorithm $\mathtt{DecomposeOnceByRandomEndomorphism}$}

\begin{algorithm}[H]\capstart
    \caption{\texttt{DecomposeOnceByRandomEndomorphism}}\label{algo:DecomposeOnceByRandomEndomorphism}
	\SetKwInput{Input}{Input~}
	\SetKwInput{Output}{Output~}
	\Input{~a functor $F$ in a functor category}
	\Output{~a pair $[\iota : I \rightarrow F, \kappa : K \rightarrow F]$ of morphisms such that $I \oplus K = F$ with $I \neq 0$ and $K \neq 0$ or
	$\mathtt{fail}$ if it was unable to further decompose $F$; }
	\BlankLine
	$d := \max \{ \mathrm{dim}_{\Bbbk}Fc \}_{c \in \mathcal{A}_{0}}$\;
	\If{$d = 0$}{
	    \Return $\mathtt{fail}$\;
	}
	$\mathcal{B} = [\beta_{1},\dots,\beta_{h}]$ is a $\Bbbk$-basis of $\mathrm{Hom}_{\HomAkmat}(F,F)$\;
	add $0_{F,F}$ to $\mathcal{B}$\;
	$n := \lfloor\log_{2}(d)\rfloor + 1$\;
	\BlankLine
	\For{$b \in [h+1, h, \dots,2]$}{
	    $\alpha := \beta_{b} + \mathrm{random}(\Bbbk) \cdot \beta_{b-1}$\tcp*{a heuristic ansatz for a random endomorphism}
	    \For{$i \in [ 1, \dots, n ]$}{
	        $\alpha_{2} := \alpha^{2}$\;
	        \nl\tcc{We do not expect the exponentiation to produce an idempotent, still this is a very cheap test:}
	        \If{$\alpha = \alpha_{2}$}{
	            \Break\;
	        }
	        $\alpha := \alpha_{2}$\;
	    }
	    \BlankLine
	    
	    \If{$\alpha = 0$}{
	        \Continue\tcp*{try another endomorphism}
	    }
	    
	    $\kappa := \mathrm{KernelEmbedding}(\alpha)$\;
	    
	    \If{$\kappa = 0$}{
	        \Continue\tcp*{try another endomorphism}
	    }
	    \BlankLine
	    $\iota := \mathrm{ImageEmbedding}(\alpha)$\;
	    \Return $[ \iota, \kappa ]$\;
	}
	\BlankLine
	\Return $\mathtt{fail}$\tcp*{The input functor $F$ is indecomposable with a high probability.}
\end{algorithm}

To justify proposition \ref{prop:Decompose_terminates_correct} below we need the following lemma which is a linear analogue of the
$\sigma$-lemma \ref{la:sigma-lemma}.

\begin{lemma}
If $\alpha$ is an endomorphism of a $d$-dimensional vector space, then $\alpha^{e}\restrict{\mathrm{Im}(\alpha^{d})}$ is an automorphism for
all $e \geq d$.
\end{lemma}
\begin{proof}
This follows from the inclusion $\mathrm{Im}(\alpha^{2}) \subseteq \mathrm{Im}(\alpha)$ and that the dimension of the vector space is equal to
$d$.
\end{proof}

\begin{proposition}\label{prop:Decompose_terminates_correct}
\algoref{DecomposeOnceByRandomEndomorphism} terminates with the correct output.
\end{proposition}
\begin{proof}
For the input $F = 0$ we have $Fc = 0\,\forall c \in \mathcal{A}$ and thus $d = 0$ which returns $\mathtt{fail}$, i.e. there is no
decomposition $0 = I \oplus K$ with $I \neq 0$ and $K \neq 0$.\\

\noindent For any other input $F \neq 0$ there is a $c \in \mathcal{A}_{0}$ with $Fc > 0$, thus in line 1 we have $d > 0$.\\
Since $F \neq 0$ the vector space $\mathrm{End}_{\HomAkmat}(F)$ is at least $1$-dimensional, so our basis $\mathcal{B}$ has
length $h \geq 1$ and doesn't contain $0_{F,F}$. Thus after line 6 we can assume $\mathrm{Length}(\mathcal{B}) = h+1 \geq 2$ and
the list $[h+1,h,\dots,2]$ in line 8 to be nonempty, thus we will enter the for loop at least once.\\

\noindent In the for-loop in lines 10-17, we are squaring $\alpha$ at most $n$ times with
\[
2^{n} = 2^{\lfloor\log_{2}(d)\rfloor+1} \geq d.
\]
Hence $\alpha_{c}^{2^{n}}$ is an automorphism on its image $\mathrm{Im}(\alpha_{c}^{2^{n}}) = \mathrm{Im}(\alpha_{c}^{d})$
by the above lemma and with the definition of $d$. Let $I = \mathrm{Im}(\alpha^{2^{n}})$ and $K = \mathrm{Ker}(\alpha^{2^{n}})$
with image embedding $\iota : I \rightarrow F$ and kernel embedding $\kappa : K \rightarrow F$. Then 
\begin{align}
F = I \oplus K.
\end{align}
\end{proof}

\begin{remark}
The set of endomorphisms which yield a nontrivial decomposition of a decomposable functor is Zariski-open and hence Zariski-dense in
the vector space $\mathrm{End}_{\HomAkmat}(F)$.
\end{remark}

%gap example DecomposeOnce (fortyone)
\begin{computation} In this \Gap{} session we will apply \algoref{DecomposeOnceByRandomEndomorphism}
first on an indecomposable representation, which will $\mathtt{fail}$ as expected, and then on a decomposable one,
resulting in the two embeddings $\mathtt{iota}$ and $\mathtt{kappa}$. The former with indecomposable source,
and the latter $\mathtt{kappa}$ with a source that can be further decomposed.\\

\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@c3c3 := ConcreteCategoryForCAP( [ [2,3,1], [4,5,6], [,,,5,6,4] ] );
|
  A finite concrete category
  !gapprompt@gap>| !gapinput@GF3 := HomalgRingOfIntegers( 3 );
|
  GF(3)
  !gapprompt@gap>| !gapinput@kq := Algebroid( GF3, c3c3 );
|
  Algebroid generated by the right quiver q(2)[a:1->1,b:1->2,c:2->2]
  !gapprompt@gap>| !gapinput@SetIsLinearClosureOfACategory( kq, true );
|
  !gapprompt@gap>| !gapinput@CatReps := Hom( kq, GF3 );
|
  The category of functors: Algebroid generated by the right quiver
  q(2)[a:1->1,b:1->2,c:2->2] -> Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@d := [[1,1,0,0,0],[0,1,1,0,0],[0,0,1,0,0],[0,0,0,1,1],[0,0,0,0,1]];;
|
  !gapprompt@gap>| !gapinput@e := [[0,1,0,0],[0,0,1,0],[0,0,0,0],[0,1,0,1],[0,0,1,0]];;
|
  !gapprompt@gap>| !gapinput@f := [[1,1,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,1]];;
|
  !gapprompt@gap>| !gapinput@nine := AsObjectInHomCategory( kq, [ 5, 4 ], [ d, e, f ] );
|
  <(1)->5, (2)->4; (a)->5x5, (b)->5x4, (c)->4x4>
  !gapprompt@gap>| !gapinput@DecomposeOnceByRandomEndomorphism( nine );
|
  fail
\end{Verbatim}
 The above shows that our representation \texttt{nine} is indecomposable (with a high probability). We use the tensor product to generate another
representation \texttt{fortyone}, that is hopefully decomposable, and inspect the two resulting embeddings \texttt{iota} and \texttt{kappa}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@fortyone := TensorProductOnObjects( nine, nine );
|
  <(1)->25, (2)->16; (a)->25x25, (b)->25x16, (c)->16x16>
  !gapprompt@gap>| !gapinput@result := DecomposeOnceByRandomEndomorphism( fortyone );
|
  [ <(1)->3x25, (2)->1x16>, <(1)->22x25, (2)->15x16> ]
  !gapprompt@gap>| !gapinput@iota := result[1];
|
  <(1)->3x25, (2)->1x16>
  !gapprompt@gap>| !gapinput@kappa := result[2];
|
  <(1)->22x25, (2)->15x16>
  !gapprompt@gap>| !gapinput@Display( fortyone );
|
  An object in The category of functors: Algebroid generated by the
  right quiver q(2)[a:1->1,b:1->2,c:2->2] -> Category of matrices
  over GF(3) defined by the following data:
  
  
  Image of <(1)>:
  A vector space object over GF(3) of dimension 25
  
  Image of <(2)>:
  A vector space object over GF(3) of dimension 16
  
  Image of (1)-[{ Z(3)^0*(a) }]->(1):
   1 1 . . . 1 1 . . . . . . . . . . . . . . . . . .
   . 1 1 . . . 1 1 . . . . . . . . . . . . . . . . .
   . . 1 . . . . 1 . . . . . . . . . . . . . . . . .
   . . . 1 1 . . . 1 1 . . . . . . . . . . . . . . .
   . . . . 1 . . . . 1 . . . . . . . . . . . . . . .
   . . . . . 1 1 . . . 1 1 . . . . . . . . . . . . .
   . . . . . . 1 1 . . . 1 1 . . . . . . . . . . . .
   . . . . . . . 1 . . . . 1 . . . . . . . . . . . .
   . . . . . . . . 1 1 . . . 1 1 . . . . . . . . . .
   . . . . . . . . . 1 . . . . 1 . . . . . . . . . .
   . . . . . . . . . . 1 1 . . . . . . . . . . . . .
   . . . . . . . . . . . 1 1 . . . . . . . . . . . .
   . . . . . . . . . . . . 1 . . . . . . . . . . . .
   . . . . . . . . . . . . . 1 1 . . . . . . . . . .
   . . . . . . . . . . . . . . 1 . . . . . . . . . .
   . . . . . . . . . . . . . . . 1 1 . . . 1 1 . . .
   . . . . . . . . . . . . . . . . 1 1 . . . 1 1 . .
   . . . . . . . . . . . . . . . . . 1 . . . . 1 . .
   . . . . . . . . . . . . . . . . . . 1 1 . . . 1 1
   . . . . . . . . . . . . . . . . . . . 1 . . . . 1
   . . . . . . . . . . . . . . . . . . . . 1 1 . . .
   . . . . . . . . . . . . . . . . . . . . . 1 1 . .
   . . . . . . . . . . . . . . . . . . . . . . 1 . .
   . . . . . . . . . . . . . . . . . . . . . . . 1 1
   . . . . . . . . . . . . . . . . . . . . . . . . 1
  
  A morphism in Category of matrices over GF(3)
  
  
  Image of (1)-[{ Z(3)^0*(b) }]->(2):
   . . . . . 1 . . . . . . . . . .
   . . . . . . 1 . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . 1 . 1 . . . . . . . .
   . . . . . . 1 . . . . . . . . .
   . . . . . . . . . 1 . . . . . .
   . . . . . . . . . . 1 . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . 1 . 1 . . . .
   . . . . . . . . . . 1 . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . 1 . . . . . . . 1 . .
   . . . . . . 1 . . . . . . . 1 .
   . . . . . . . . . . . . . . . .
   . . . . . 1 . 1 . . . . . 1 . 1
   . . . . . . 1 . . . . . . . 1 .
   . . . . . . . . . 1 . . . . . .
   . . . . . . . . . . 1 . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . 1 . 1 . . . .
   . . . . . . . . . . 1 . . . . .
  
  A morphism in Category of matrices over GF(3)
  
  
  Image of (2)-[{ Z(3)^0*(c) }]->(2):
   1 1 . . 1 1 . . . . . . . . . .
   . 1 1 . . 1 1 . . . . . . . . .
   . . 1 . . . 1 . . . . . . . . .
   . . . 1 . . . 1 . . . . . . . .
   . . . . 1 1 . . 1 1 . . . . . .
   . . . . . 1 1 . . 1 1 . . . . .
   . . . . . . 1 . . . 1 . . . . .
   . . . . . . . 1 . . . 1 . . . .
   . . . . . . . . 1 1 . . . . . .
   . . . . . . . . . 1 1 . . . . .
   . . . . . . . . . . 1 . . . . .
   . . . . . . . . . . . 1 . . . .
   . . . . . . . . . . . . 1 1 . .
   . . . . . . . . . . . . . 1 1 .
   . . . . . . . . . . . . . . 1 .
   . . . . . . . . . . . . . . . 1
  
  A morphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@S := DirectSum( [ Source( iota ), Source( kappa ) ] );
|
  <(1)->25, (2)->16; (a)->25x25, (b)->25x16, (c)->16x16>
  !gapprompt@gap>| !gapinput@Display( S );
|
  An object in The category of functors: Algebroid generated by the
  right quiver q(2)[a:1->1,b:1->2,c:2->2] -> Category of matrices
  over GF(3) defined by the following data:
  
  
  Image of <(1)>:
  A vector space object over GF(3) of dimension 25
  
  Image of <(2)>:
  A vector space object over GF(3) of dimension 16
  
  Image of (1)-[{ Z(3)^0*(a) }]->(1):
   . 2 . . . . . . . . . . . . . . . . . . . . . . .
   1 2 2 . . . . . . . . . . . . . . . . . . . . . .
   . . 1 . . . . . . . . . . . . . . . . . . . . . .
   . . . 1 1 . . . 1 1 . . . . . . . . . . . . . . .
   . . . . 1 1 . . . 1 1 . . . . . . . . . . . . . .
   . . . . . 1 . . . . 1 . . . . . . . . . . . . . .
   . . . . . . 1 1 . . . 1 1 . . . . . . . . . . . .
   . . . . . . . 1 . . . . 1 . . . . . . . . . . . .
   . . . . . . . . 1 1 . . . 1 1 . . . . . . . . . .
  . . . . . . . . . 1 1 . . . 1 1 . . . . . . . . .
  . . . . . . . . . . 1 . . . . 1 . . . . . . . . .
  . . . . . . . . . . . 1 1 . . . 1 1 . . . . . . .
  . . . . . . . . . . . . 1 . . . . 1 . . . . . . .
  . . . . . . . . . . . . . 1 1 . . . . . . . . . .
  . . . . . . . . . . . . . . 1 1 . . . . . . . . .
  . . . . . . . . . . . . . . . 1 . . . . . . . . .
  . . . . . . . . . . . . . . . . 1 1 . . . . . . .
  . . . . . . . . . . . . . . . . . 1 . . . . . . .
  . . . . . . . . . . . . . . . . . . 1 1 . 1 1 . .
  . . . . . . . . . . . . . . . . . . . 1 1 . 1 1 .
  . . . . . . . . . . . . . . . . . . . . 1 . . 1 .
  . . . . . . . . . . . . . . . . . . . . . 1 1 . .
  . . . . . . . . . . . . . . . . . . . . . . 1 1 .
  . . . . . . . . . . . . . . . . . . . . . . . 1 .
  . . . . . . . . . . . . . . . . . . . . . . . . 1
  
  A morphism in Category of matrices over GF(3)
  
  
  Image of (1)-[{ Z(3)^0*(b) }]->(2):
   2 . . . . . . . . . . . . . . .
   1 . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . 1 . . . . . . . . .
   . . . . . . . 1 . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . 1 . 1 . . . . . . .
   . . . . . . . 1 . . . . . . . .
   . . . . . . . . . . 1 . . . . .
   . . . . . . . . . . . 1 . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . 1 . 1 . . .
   . . . . . . . . . . . 1 . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . 1 . . . . . . . 1 .
   . . . . . . . 1 . . . . . . . 1
   . . . . . . . . . . . . . . . .
   . . . . . . . . . . 1 . . . . .
   . . . . . . . . . . . 1 . . . .
   . . . . . . . . . . . . . . . .
   . . . . . . . 2 . . 1 . 1 . . 2
  
  A morphism in Category of matrices over GF(3)
  
  
  Image of (2)-[{ Z(3)^0*(c) }]->(2):
   1 . . . . . . . . . . . . . . .
   . 1 1 . . 1 1 . . . . . . . . .
   . . 1 1 . . 1 1 . . . . . . . .
   . . . 1 . . . 1 . . . . . . . .
   . . . . 1 . . . 1 . . . . . . .
   . . . . . 1 1 . . 1 1 . . . . .
   . . . . . . 1 1 . . 1 1 . . . .
   . . . . . . . 1 . . . 1 . . . .
   . . . . . . . . 1 . . . 1 . . .
   . . . . . . . . . 1 1 . . . . .
   . . . . . . . . . . 1 1 . . . .
   . . . . . . . . . . . 1 . . . .
   . . . . . . . . . . . . 1 . . .
   . . . . . . . . . . . . . 1 1 .
   . . . . . . . . . . . . . . 1 1
   . . . . . . . . . . . . . . . 1
  
  A morphism in Category of matrices over GF(3)
\end{Verbatim}
 Comparing the matrices of \texttt{fortyone} with those of \texttt{S}, we see that after decomposing once, we have separated one small matrix on
the diagonal: A $3\times 3$-matrix from \texttt{S(kq.a)}, a $3 \times 1$-matrix from \texttt{S(kq.b)} and a $1\times 1$-matrix from \texttt{S(kq.c)}. This matches with the source of the embedding \texttt{iota}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Display( iota );
|
  A morphism in The category of functors: Algebroid generated by the
  right quiver q(2)[a:1->1,b:1->2,c:2->2] -> Category of matrices
  over GF(3) defined by the following data:
  
  
  Image of <(1)>:
   2 2 . 1 1 . . . . . . . . . . 1 2 1 2 1 . . . . .
   1 2 1 2 1 1 2 1 2 1 . . . . . 2 . . 1 . 2 . . 1 .
   . . 2 . . . 1 2 . 2 2 . . 1 . . . 1 . . . 2 . . 1
  
  A split monomorphism in Category of matrices over GF(3)
  
  
  Image of <(2)>:
   . . . . . . . . . . . . . . . 1
  
  A split monomorphism in Category of matrices over GF(3)
  !gapprompt@gap>| !gapinput@Display( Source( iota ) );
|
  An object in The category of functors: Algebroid generated by the
  right quiver q(2)[a:1->1,b:1->2,c:2->2] -> Category of matrices
  over GF(3) defined by the following data:
  
  Image of <(1)>:
  A vector space object over GF(3) of dimension 3
  
  Image of <(2)>:
  A vector space object over GF(3) of dimension 1
  
  Image of (1)-[{ Z(3)^0*(a) }]->(1):
   . 2 .
   1 2 2
   . . 1
  
  A morphism in Category of matrices over GF(3)
  
  
  Image of (1)-[{ Z(3)^0*(b) }]->(2):
   2
   1
   .
  
  A morphism in Category of matrices over GF(3)
  
  
  Image of (2)-[{ Z(3)^0*(c) }]->(2):
   1
  
  A morphism in Category of matrices over GF(3)
\end{Verbatim}
 We can then look at the other embedding of the direct sum decomposition, \texttt{kappa}. The iteration of \texttt{WeakDirectSumDecomposition} will continue then with \texttt{Source( kappa )}. Each time the random endomorphism might decompose the representation.
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Source( kappa );
|
  <(1)->22, (2)->15; (a)->22x22, (b)->22x15, (c)->15x15>
  !gapprompt@gap>| !gapinput@result2 := DecomposeOnceByRandomEndomorphism( Source( kappa ) );
|
  [ <(1)->3x22, (2)->3x15>, <(1)->19x22, (2)->12x15> ]
\end{Verbatim}

\end{computation}

% julia worksheet

\subsection{The algorithm $\mathtt{WeakDirectSumDecomposition}$}

\begin{algorithm}[H]\capstart
    \caption{\texttt{WeakDirectSumDecomposition}}\label{algo:WeakDirectSumDecomposition}
	\SetKwInput{Input}{Input~}
	\SetKwInput{Output}{Output~}
	\Input{~a functor $F$ in a functor category}
	\Output{~a list $[\eta_i : F_{i} \rightarrow F]$ of embeddings such that $\oplus_{i} F_{i} = F$ and each $F_{i}$ is indecomposable
	(with a high probability).}
	\BlankLine
	$\mathtt{queue} := [ 1_{F} ]$\;
	$\mathtt{summands} := [ \quad ]$\;
	
	\While{ $\mathtt{queue} \neq \emptyset$ }{
	    let $\eta$ be the last element in $\mathtt{queue}$ and delete $\eta$ from $\mathtt{queue}$\;
	    $\mathtt{result} := \mathtt{DecomposeOnceByRandomEndomorphism}(s(\eta))$\;
	    \eIf(\tcp*[f]{$s(\eta)$ was indecomposable (with a high probability)}){$\mathtt{result} = \mathtt{fail}$}{
	        add $\eta$ to $\mathtt{summands}$\;
	    }{
	        $[\iota,\kappa] = \mathtt{result}$\;
	        append $[\iota\eta, \kappa\eta]$ to $\mathtt{queue}$\;
	    }
	}
	\BlankLine
	\Return $\mathtt{summands}$\;
\end{algorithm}

\begin{proposition}
\algoref{WeakDirectSumDecomposition} terminates with the correct output.
\end{proposition}
\begin{proof} We assert certain truths about the algorithm by formulating invariants, and how they stay constant in each line of the algorithm.\\

\begin{subproof}[Proof that the output is correct]\phantom{}\\
\noindent In line 1, the morphism $1_{F} : F \rightarrow F$, which is initially the only morphism in $\mathtt{queue}$, satisfies $t(1_{F}) = F$.\\
In line 10, since $\iota : I \rightarrow s(\eta)$ and $\kappa : K \rightarrow s(\eta)$ are each composable with $\eta$, then we are
appending the list $[\iota\eta, \kappa\eta]$ of morphisms with target $t(\iota\eta) = t(\kappa\eta) = F$ to the $\mathtt{queue}$.\\
Thus in each step of the algorithm the $\mathtt{queue}$ only contains morphisms $\eta$ with target $t(\eta) = F$.\\

\noindent In line 2, the list $\mathtt{summands}$ is initially empty.\\
In line 7, we add a morphism $\eta$ from the $\mathtt{queue}$ to the list $\mathtt{summands}$ only if
in line 6 we checked that $s(\eta)$ is indecomposable.\\
Thus in each step of the algorithm the list $\mathtt{summands}$ only contains indecomposable morphisms with target $F$.\\

\noindent Initially with $\mathtt{queue} = [1_{F}]$ and $\mathtt{summands} = \emptyset$ we have
\begin{align}
F = \label{eq:direct_sum_decomposition}
\bigoplus_{\eta \in \mathtt{queue}} s(\eta) \oplus \bigoplus_{\eta \in \mathtt{summands}} s(\eta)
\end{align}
For the first run of the while loop we take $\eta_{1} := 1_{F}$ from the $\mathtt{queue}$. Then there are two possibilities:\\
If $F$ was indecomposable, we now add $\eta_{1}$ to $\mathtt{summands}$, and have $\mathtt{queue} = \emptyset$ and
$\mathtt{summands} = [1_{F}]$ which also satisfies \eqref{eq:direct_sum_decomposition}.\\
Otherwise we get a decomposition of $F$ with $\iota_{1} : I_{1} \rightarrow F$ and $\kappa_{1} : K_{1} \rightarrow F$. In this case
$\mathtt{summands}$ stays empty, and instead we have $\mathtt{queue} = [\iota_{1}\eta_{1}, \kappa_{1}\eta_{1}]$. For
\eqref{eq:direct_sum_decomposition} to hold, we need to prove that
\[
I_{1} \oplus K_{1} = F
\]
which is exactly what we assert for the output of $\mathtt{DecomposeOnceByRandomEndomorphism}$.\\
Thus after the first while loop, equation \eqref{eq:direct_sum_decomposition} holds.\\
In each run of the while loop, we are replacing $I_{j}$ with $I_{j,1}$ and $K_{j,1}$ with $I_{j} = I_{j,1} \oplus K_{j,1}$ and
$K_{j}$ with $I_{j,2} \oplus K_{j,2}$ if possible. That is we have 
\begin{alignat*}{5}
F &=  &&I_{1} &&\oplus &&K_{1} \\
&= (I_{11} &&\oplus K_{11}) &&\oplus (I_{12} &&\oplus K_{12}) \\
&= \dots
\end{alignat*}

\[
\begin{tikzcd}
                                                   &                                                           &                                                                                   &                                                    & F                                                          &                                                           &                                                                                       &                                                           &                                                     \\
                                                   &                                                           & F \arrow[rru, "\eta_{1}", bend left]                                              &                                                    &                                                            &                                                           & F \arrow[llu, "\eta_{1}"', bend right]                                                &                                                           &                                                     \\
                                                   &                                                           & I_{1} \arrow[u, "\iota_{1}"] \arrow[rr, dash] \arrow[rruu, "\iota_{1}\eta_{1}"] &                                                    & \bigoplus \arrow[uu, "I_{1} \oplus K_{1}" description]     &                                                           & K_{1} \arrow[u, "\kappa_{1}"'] \arrow[ll, dash] \arrow[lluu, "\kappa_{1}\eta_{1}"'] &                                                           &                                                     \\
                                                   & I_{1} \arrow[ru, "\eta_{11}"', bend left=49, shift right] &                                                                                   &                                                    & I_{1} \arrow[llu, "\eta_{11}", bend right]                  & K_{1} \arrow[ru, "\eta_{12}"', bend left=49, shift right] &                                                                                       & K_{1} \arrow[lu, "\eta_{12}", bend right=49, shift left]  &                                                     \\
                                                   & I_{11} \arrow[u, "\iota_{11}"] \arrow[r, dash]          & \bigoplus \arrow[uu, "I_{11}\oplus K_{11}" description]                           &                                                    & K_{11} \arrow[ll, dash] \arrow[u, "\kappa_{11}"]         & I_{12} \arrow[u, "\iota_{12}"] \arrow[r, dash]          & \bigoplus \arrow[uu, "I_{12} \oplus K_{12}" description]                              & K_{12} \arrow[u, "\kappa_{12}"'] \arrow[l, dash]        &                                                     \\
I_{11} \arrow[ru, "\eta_{111}"', bend left=49]     &                                                           & I_{11} \arrow[lu, "\eta_{111}", bend right=49]                                    & K_{11} \arrow[ru, "\eta_{112}"', bend left=49]     &                                                            & K_{11} \arrow[lu, "\eta_{112}", bend right=49]            & K_{12} \arrow[ru, "\eta_{122}"', bend left=49]                                        &                                                           & K_{12} \arrow[lu, "\eta_{122}", bend right=49]      \\
I_{111} \arrow[r, dash] \arrow[u, "\iota_{111}"] & \bigoplus \arrow[uu, "I_{111}\oplus K_{111}" description] & K_{111} \arrow[l, dash] \arrow[u, "\kappa_{111}"]                               & I_{112} \arrow[u, "\iota_{112}"] \arrow[r, dash] & \bigoplus \arrow[uu, "I_{112} \oplus K_{112}" description] & K_{112} \arrow[u, "\kappa_{112}"] \arrow[l, dash]       & I_{122} \arrow[r, dash] \arrow[u, "\iota_{122}"]                                    & \bigoplus \arrow[uu, "I_{122}\oplus K_{122}" description] & K_{122} \arrow[l, dash] \arrow[u, "\kappa_{122}"]
\end{tikzcd}
\]

In this example we have

\begin{align*}
F &= I_{1} \oplus K_{1} \\
&= (I_{11} \oplus K_{11}) \oplus (I_{12} \oplus K_{12}) \\
&= I_{111} \oplus K_{111} \oplus I_{112} \oplus K_{112} \oplus I_{12} \oplus I_{122} \oplus K_{122}
\end{align*}
and with $I_{111}, K_{111}, I_{112}, K_{112}, I_{12}, I_{122}, K_{122}$ indecomposable, we are finished. Tracing the morphisms from
the bottom to the top gives us the list of embeddings
\begin{align*}
[ &\iota_{111}\eta_{111}\iota_{11}\eta_{11}\iota_{1}\eta_{1}, \\
&\kappa_{111}\eta_{111}\iota_{11}\eta_{11}\iota_{1}\eta_{1}, \\
&\iota_{112}\eta_{112}\kappa_{11}\eta_{11}\iota_{1}\eta_{1}, \\
&\kappa_{112}\eta_{112}\kappa_{11}\eta_{11}\iota_{1}\eta_{1}, \\
&\iota_{12}\eta_{12}\kappa_{1}\eta_{1}, \\
&\iota_{122}\eta_{122}\kappa_{12}\eta_{12}\kappa_{1}\eta_{1}, \\
&\kappa_{122}\eta_{122}\kappa_{12}\eta_{12}\kappa_{1}\eta_{1} ]\\
\end{align*}

\begin{subproof}[Proof that the $\mathtt{queue}$ will be empty]\phantom{}\\
\noindent In each run of the while loop, a morphism $\eta$ from the $\mathtt{queue}$ gets either deleted and not replaced,
since $s(\eta)$ was indecomposable, or it gets deleted and replaced by two morphisms $[\iota\eta, \kappa\eta]$.\\
If at some point, $s(\eta)$ is indecomposable for every $\eta \in \mathtt{queue}$, then the $\eta$ will be deleted from the
$\mathtt{queue}$ (and added to $\mathtt{summands}$) until the $\mathtt{queue}$ is empty. Then the while loop will end.\\

\noindent The case that each $\eta$ gets replaced by $[\iota\eta, \kappa\eta]$ where again the $s(\iota\eta)$ and $s(\kappa\eta)$ are
decomposable must come to an end after a finite number of steps:\\

\noindent Whenever $G := s(\eta)$ is decomposable with $I \oplus K = G$ and $I, K \neq 0$, the variable
$d_{G} :=\max_{c \in \mathcal{A}_{0}} Gc$ also gets decomposed into $d_{I} := \max_{c \in \mathcal{A}_{0}} Ic$ and
$d_{K} := \max_{c \in \mathcal{A}_{0}} Kc$ with
\begin{align*}
0 < d_{I} < d_{G} \\
0 < d_{K} < d_{G}
\end{align*}
and both have the lower bound of $0$. Thus after a finite number of steps there are only $\eta$ with indecomposable $s(\eta)$ in the $\mathtt{queue}$
so that by the above result, $\mathtt{queue}$ will eventually become empty and the loop will end.
\end{subproof}

\noindent With the $\mathtt{queue} = \emptyset$ and $\mathtt{summands}$ containing only $\eta$ with indecomposable $s(\eta)$,
equation \eqref{eq:direct_sum_decomposition} becomes
\begin{align}
F = \bigoplus_{\eta \in \mathtt{summands}} s(\eta)
\end{align}
\end{subproof}

\end{proof}


\[
\begin{tikzcd}
                                                          &                                                                                   &                                                          & F                                                      &                                                           &                                                                                       &                                                          \\
                                                          & F \arrow[rru, "\eta_{1}", bend left]                                              &                                                          &                                                        &                                                           & F \arrow[llu, "\eta_{1}"', bend right]                                                &                                                          \\
                                                          & I_{1} \arrow[u, "\iota_{1}"] \arrow[rr, dash] \arrow[rruu, "\iota_{1}\eta_{1}"] &                                                          & \bigoplus \arrow[uu, "I_{1} \oplus K_{1}" description] &                                                           & K_{1} \arrow[u, "\kappa_{1}"'] \arrow[ll, dash] \arrow[lluu, "\kappa_{1}\eta_{1}"'] &                                                          \\
I_{1} \arrow[ru, "\eta_{11}"', bend left=49, shift right] &                                                                                   & I_{1} \arrow[lu, "\eta_{11}", bend right=49, shift left] &                                                        & K_{1} \arrow[ru, "\eta_{12}"', bend left=49, shift right] &                                                                                       & K_{1} \arrow[lu, "\eta_{12}", bend right=49, shift left] \\
I_{11} \arrow[u, "\iota_{11}"] \arrow[r, dash]          & \bigoplus \arrow[uu, "I_{11}\oplus K_{11}" description]                           & K_{11} \arrow[u, "\kappa_{11}"] \arrow[l, dash]        &                                                        & I_{12} \arrow[u, "\iota_{12}"] \arrow[r, dash]          & \bigoplus \arrow[uu, "I_{12} \oplus K_{12}" description]                              & K_{12} \arrow[u, "\kappa_{12}"'] \arrow[l, dash]      
\end{tikzcd}
\]



Invariant:

In each step:

\[
F = \bigoplus_{\eta \in \mathtt{queue}} s(\eta) \oplus \bigoplus_{\varphi \in \mathtt{summands}} s(\varphi).
\]

When $\mathtt{queue} = \emptyset$, then
\[
F = \bigoplus_{\varphi \in \mathtt{summands}} s(\varphi).
\]

Why is $\mathtt{queue}$ going to be $\emptyset$?

$5 = 4+1 = 2+2+1 = 2+2+1$.

In each step we remove the last $\eta$ from the $\mathtt{queue}$. If $s(\eta)$ was indecomposable, it doesn't get replaced, i.e.
$\mathtt{queue}$ becomes smaller by 1. If $s(\eta)$ was decomposable, we replace $\eta$ by $\iota\eta$ and $\kappa\eta$ with

\begin{align}
\iota : I \rightarrow s(\eta) \\
\kappa : K \rightarrow s(\eta)
\end{align}
and in some sense
\begin{align}
I \preceq s(\eta) \\
K \preceq s(\eta)
\end{align}
Which sense?
\begin{align}
I \oplus K &= s(\eta) \\
s(\eta)(i) &= (I \oplus K)(i) = I(i) + K(i)\, \forall i \in \mathcal{A}_{0}
\end{align}
Since $\iota \neq 0$ and $\kappa \neq 0$, $I \neq 0$ and $K \neq 0$, so for some objects $i,j \in \mathcal{A}_{0}$ we have
$I(i) > 0$ and $K(j) > 0$, and thus $s(\eta)(i) > 0$ for some $i$.

For all objects $i\in \mathcal{A}_{0}$ $I(i) \leq s(\eta)(i)$ and $K(i) \leq s(\eta)(i)$.

$\mathtt{queue} := \{1_{F}\} \mapsto \{\iota 1_{F}, \kappa 1_{F}\} = \{\iota, \kappa \}
\mapsto \{ \iota_{1}\iota, \kappa_{1}\iota, \iota_{2}\kappa, \kappa_{2}\kappa \}$


Input: Functor $F$.\\
Output: Tupel $(\mathrm{ImageEmbedding}( \alpha ), \mathrm{KernelEmbedding}( \alpha ) )$

such that
\[
\begin{tikzcd}
                                       & F &                                         \\
s(\eta) \arrow[ru, "\eta", bend left=49]     &   & s(\eta) \arrow[lu, "\eta"', bend right=49]    \\
I \arrow[u, "\iota"] &   & K \arrow[u, "\kappa"']
\end{tikzcd}
\]
and
\[
F = I \oplus K
\]

When we input I and K into DecomposeOnce, we get a further decomposition:
\[
\begin{tikzcd}
                                                 &                                                &                                                  & F &                                                  &                                                 &                                                   \\
                                                 & F \arrow[rru, "\eta_{1}", bend left]           &                                                  &   &                                                  & F \arrow[llu, "\eta_{1}"', bend right]          &                                                   \\
                                                 & I_{1} \arrow[u, "\mathrm{ImgEmb}(\alpha_{1})"] &                                                  &   &                                                  & K_{1} \arrow[u, "\mathrm{KerEmb}(\alpha_{1})"'] &                                                   \\
I_{1} \arrow[ru, "\eta_{11}", bend left=49]      &                                                & I_{1} \arrow[lu, "\eta_{11}", bend right=49]     &   & K_{1} \arrow[ru, "\eta_{12}", bend left=49]      &                                                 & K_{1} \arrow[lu, "\eta_{12}", bend right=49]      \\
I_{11} \arrow[u, "\mathrm{ImgEmb}(\alpha_{11})"] &                                                & K_{11} \arrow[u, "\mathrm{KerEmb}(\alpha_{11})"] &   & I_{12} \arrow[u, "\mathrm{ImgEmb}(\alpha_{12})"] &                                                 & K_{12} \arrow[u, "\mathrm{KerEmb}(\alpha_{12})"']
\end{tikzcd}
\]

The direct sum decomposition in each step looks like this:

\[
\begin{tikzcd}
                                                                   &                                                                   &                                                                    & F                                                      &                                                                    &                                                                    &                                                                     \\
                                                                   & F \arrow[rru, "\eta_{1}", bend left]                              &                                                                    &                                                        &                                                                    & F \arrow[llu, "\eta_{1}"', bend right]                             &                                                                     \\
                                                                   & I_{1} \arrow[u, "\mathrm{ImgEmb}(\alpha_{1})"] \arrow[rr, dash] &                                                                    & \bigoplus \arrow[uu, "I_{1} \oplus K_{1}" description] &                                                                    & K_{1} \arrow[u, "\mathrm{KerEmb}(\alpha_{1})"'] \arrow[ll, dash] &                                                                     \\
I_{1} \arrow[ru, "\eta_{11}"', bend left=49, shift right]           &                                                                   & I_{1} \arrow[lu, "\eta_{11}", bend right=49, shift left]           &                                                        & K_{1} \arrow[ru, "\eta_{12}"', bend left=49, shift right]                        &                                                                    & K_{1} \arrow[lu, "\eta_{12}", bend right=49, shift left]                        \\
I_{11} \arrow[u, "\mathrm{ImgEmb}(\alpha_{11})"] \arrow[r, dash] & \bigoplus \arrow[uu, "I_{11}\oplus K_{11}" description]           & K_{11} \arrow[u, "\mathrm{KerEmb}(\alpha_{11})"] \arrow[l, dash] &                                                        & I_{12} \arrow[u, "\mathrm{ImgEmb}(\alpha_{12})"] \arrow[r, dash] & \bigoplus \arrow[uu, "I_{12} \oplus K_{12}" description]           & K_{12} \arrow[u, "\mathrm{KerEmb}(\alpha_{12})"'] \arrow[l, dash]
\end{tikzcd}
\]
That is we have 
\begin{alignat}{5}
F &=  &&I_{1} &&\oplus &&K_{1} \\
F &= (I_{11} &&\oplus K_{11}) &&\oplus (I_{12} &&\oplus K_{12})
\end{alignat}




\begin{enumerate}
\renewcommand{\labelenumi}{(\theenumi)}
\item Let $F \neq 0$ be a functor in $\HomAkmat$. Then there is a maximum dimension $d := \max_{i \in \mathcal{A}_{0}} \mathrm{dim}\, F(i)$ with
$d \geq 1$.
\item The vector space $\mathrm{Hom}_{\HomAkmat}(F,F) = \mathrm{End}_{\HomAkmat}(F)$ is finite-dimensional, i.e. we can find a
finite basis $\mathtt{endbas}$ of our external hom using the algorithm $\mathtt{BasisOfExternalHom}(F,F)$. Since $F \neq 0$, the
identity morphism $1_{F}$ 
\item If $\mathrm{End}_{\HomAkmat}(F)$ has dimension 1, i.e. each morphism in $\mathrm{End}_{\HomAkmat}(F)$ is of the form
$\lambda \alpha$ for some $\lambda \in \Bbbk$ and the one $\alpha \in \mathtt{endbas}$, then $\alpha = 1_{F}$ is the identity morphism.
In this case, 

The process $\alpha \mapsto \alpha^{2}$ will end when for some $k \in \mathbb{N},\, \alpha^{2^{k+1}} = \alpha^{2^{k}},$ i.e.
$\alpha^{2^{k}+2^{k}} = \alpha^{2^{k}}$ which is the $\sigma$-lemma with $m = n = 2^{k}$.

\end{enumerate}

The algorithm $\mathtt{DecomposeOnceByRandomEndomorphism}$ will terminate without $\mathtt{fail}$ only if
\[
\mathrm{ImgEmb}(\alpha) \neq 0\,\text{ and }\, \mathrm{KerEmb}(\alpha) \neq 0
\]
for some $\alpha$.

When we have $\mathrm{ImgEmb}(\alpha) = 0$ or $\mathrm{KerEmb}(\alpha) = 0$ for all $\alpha : F \rightarrow F$, we have
\begin{alignat}{4}
&F &&= \{0\} &&\oplus K\quad\text{ or }\\
&F &&= I &&\oplus \{0\},
\end{alignat}
i.e. F was indecomposable.



\begin{tikzcd}
F1 \arrow["Fa"', loop, distance=2em, in=125, out=55] \arrow[rr, "Fb"] \arrow[dd, "\eta_{1}"]
&  & F2 \arrow["Fc"', loop, distance=2em, in=125, out=55] \arrow[dd, "\eta_{2}"] \\
&  &                                                                                 \\
G1 \arrow["Ga"', loop, distance=2em, in=305, out=235] \arrow[rr, "Gb"]
&  & G2 \arrow["Gc"', loop, distance=2em, in=305, out=235]
\end{tikzcd}

\begin{align}
Fa\,\eta_{1} &= \eta_{1} Ga \\
Fb\,\eta_{2} &= \eta_{1} Gb \\
Fc\,\eta_{2} &= \eta_{2} Gc
\end{align}

For the first equation we have

\begin{align}
Fa\,\eta_{1} - \eta_{1} Ga = 0
\end{align}

thus

\begin{align}
\left( Fa\,\eta_{1} - \eta_{1} Ga \right)_{i,j} = 0,\, 1\leq i \leq 5, 1\leq j \leq 3
\end{align}

Sylvester equations

\texttt{BasisOfExternalHom}
\texttt{WeakDirectSumDecomposition}

InstallMethod( DecomposeOnceByRandomEndomorphism,
        "for an object in a Hom-category",
        [ IsCapCategoryObjectInHomCategory ],
        
  function( F )
    local d, n, endbas, k, b, alpha, i, alpha2, keremb;
    
    d := Maximum( List( ValuesOnAllObjects( F ), Dimension ) );
    
    endbas := ShallowCopy( BasisOfExternalHom( F, F ) );
    
    Add( endbas, ZeroMorphism( F, F ) );
    
    k := CommutativeRingOfLinearCategory( CapCategory( F ) );
    
    n := Int( Log2( Float( d ) ) ) + 1;
    
    for b in Reversed( [ 2 .. Length( endbas ) ] ) do
        
        alpha := endbas[b] + Random( k ) * endbas[b-1];
        
        SetFilterObj( alpha, IsMultiplicativeElementWithInverse );
        
        for i in [ 1 .. n ] do
            alpha2 := PreCompose( alpha, alpha );
            if IsCongruentForMorphisms( alpha, alpha2 ) then
                break;
            fi;
            alpha := alpha2;
        od;
        
        if IsZero( alpha ) then
            continue;
        fi;
        
        keremb := KernelEmbedding( alpha );
        
        if IsZero( keremb ) then
            continue;
        fi;
        
        return [ ImageEmbedding( alpha ), keremb ];
        
    od;
    
    return fail;
    
end );


InstallMethod( WeakDirectSumDecomposition,
        "for an object in a Hom-category",
        [ IsCapCategoryObjectInHomCategory ],
        
  function( F )
    local queue, summands, eta, result;
    
    queue := [ IdentityMorphism( F ) ];
    
    summands := [ ];
    
    while not IsEmpty( queue ) do
        
        eta := Remove( queue );
        
        result := DecomposeOnceByRandomEndomorphism( Source( eta ) );
        
        if result = fail then
            Add( summands, eta );
        else
            Append( queue, List( result, emb -> PreCompose( emb, eta ) ) );
        fi;
        
    od;
    
    return summands;
    
end );



















